<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Base32.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Codec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.codec.binary</a> &gt; <span class="el_source">Base32.java</span></div><h1>Base32.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.codec.binary;

import java.util.Objects;

import org.apache.commons.codec.CodecPolicy;

/**
 * Provides Base32 encoding and decoding as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc4648.txt&quot;&gt;RFC 4648&lt;/a&gt;.
 *
 * &lt;p&gt;
 * The class can be parameterized in the following manner with various constructors:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Whether to use the &quot;base32hex&quot; variant instead of the default &quot;base32&quot;&lt;/li&gt;
 * &lt;li&gt;Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
 * &lt;li&gt;Line separator: Default is CRLF (&quot;\r\n&quot;)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * This class operates directly on byte streams, and not character streams.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 * &lt;p&gt;
 * You can configure instances with the {@link Builder}.
 * &lt;/p&gt;
 * &lt;pre&gt;
 * Base32 base32 = Base32.builder()
 *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient
 *   .setEncodeTable(customEncodeTable)
 *   .setLineLength(0)                          // default is none
 *   .setLineSeparator('\r', '\n')              // default is CR LF
 *   .setPadding('=')                           // default is =
 *   .get()
 * &lt;/pre&gt;
 *
 * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc4648.txt&quot;&gt;RFC 4648&lt;/a&gt;
 * @since 1.5
 */
public class Base32 extends BaseNCodec {

    /**
     * Builds {@link Base32} instances.
     *
     * @since 1.17.0
     */
    public static class Builder extends AbstractBuilder&lt;Base32, Builder&gt; {

        /**
         * Constructs a new instance.
         */
        public Builder() {
<span class="fc" id="L70">            super(ENCODE_TABLE);</span>
<span class="fc" id="L71">        }</span>

        @Override
        public Base32 get() {
<span class="fc" id="L75">            return new Base32(getLineLength(), getLineSeparator(), getEncodeTable(), getPadding(), getDecodingPolicy());</span>
        }

    }

    /**
     * BASE32 characters are 5 bits in length. They are formed by taking a block of five octets to form a 40-bit string, which is converted into eight BASE32
     * characters.
     */
    private static final int BITS_PER_ENCODED_BYTE = 5;

    private static final int BYTES_PER_ENCODED_BLOCK = 8;
    private static final int BYTES_PER_UNENCODED_BLOCK = 5;
    /**
     * This array is a lookup table that translates Unicode characters drawn from the &quot;Base32 Alphabet&quot; (as specified in Table 3 of RFC 4648) into their 5-bit
     * positive integer equivalents. Characters that are not in the Base32 alphabet but fall within the bounds of the array are translated to -1.
     */
    // @formatter:off
<span class="fc" id="L93">    private static final byte[] DECODE_TABLE = {</span>
         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a P-Z
                                                        -1, -1, -1, -1, -1, // 5b-5f
            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 60-6f a-o
            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 70-7a p-z
    };
    // @formatter:on

    /**
     * This array is a lookup table that translates 5-bit positive integer index values into their &quot;Base32 Alphabet&quot; equivalents as specified in Table 3 of RFC
     * 4648.
     */
    // @formatter:off
<span class="fc" id="L112">    private static final byte[] ENCODE_TABLE = {</span>
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '2', '3', '4', '5', '6', '7',
    };
    // @formatter:on

    /**
     * This array is a lookup table that translates Unicode characters drawn from the &quot;Base32 Hex Alphabet&quot; (as specified in Table 4 of RFC 4648) into their
     * 5-bit positive integer equivalents. Characters that are not in the Base32 Hex alphabet but fall within the bounds of the array are translated to -1.
     */
    // @formatter:off
<span class="fc" id="L124">    private static final byte[] HEX_DECODE_TABLE = {</span>
         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f
             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O
            25, 26, 27, 28, 29, 30, 31,                                     // 50-56 P-V
                                        -1, -1, -1, -1, -1, -1, -1, -1, -1, // 57-5f
            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 60-6f a-o
            25, 26, 27, 28, 29, 30, 31                                      // 70-76 p-v
    };
    // @formatter:on

    /**
     * This array is a lookup table that translates 5-bit positive integer index values into their &quot;Base32 Hex Alphabet&quot; equivalents as specified in Table 4 of
     * RFC 4648.
     */
    // @formatter:off
<span class="fc" id="L143">    private static final byte[] HEX_ENCODE_TABLE = {</span>
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
    };
    // @formatter:on

    /** Mask used to extract 5 bits, used when encoding Base32 bytes */
    private static final int MASK_5BITS = 0x1f;

    /** Mask used to extract 4 bits, used when decoding final trailing character. */
    private static final long MASK_4BITS = 0x0fL;

    /** Mask used to extract 3 bits, used when decoding final trailing character. */
    private static final long MASK_3BITS = 0x07L;

    /** Mask used to extract 2 bits, used when decoding final trailing character. */
    private static final long MASK_2BITS = 0x03L;

    /** Mask used to extract 1 bits, used when decoding final trailing character. */
    private static final long MASK_1BITS = 0x01L;

    /**
     * Creates a new Builder.
     *
     * @return a new Builder.
     * @since 1.17.0
     */
    public static Builder builder() {
<span class="fc" id="L172">        return new Builder();</span>
    }

    // The static final fields above are used for the original static byte[] methods on Base32.
    // The private member fields below are used with the new streaming approach, which requires
    // some state be preserved between calls of encode() and decode().

    /**
     * Decode table to use.
     */
    private final byte[] decodeTable;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing. {@code encodeSize = {@link
     * #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;}
     */
    private final int encodeSize;

    /**
     * Encode table to use.
     */
    private final byte[] encodeTable;

    /**
     * Line separator for encoding. Not used when decoding. Only used if lineLength &amp;gt; 0.
     */
    private final byte[] lineSeparator;

    /**
     * Constructs a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking).
     * &lt;/p&gt;
     */
    public Base32() {
<span class="fc" id="L207">        this(false);</span>
<span class="fc" id="L208">    }</span>

    /**
     * Constructs a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking).
     * &lt;/p&gt;
     *
     * @param useHex if {@code true} then use Base32 Hex alphabet
     */
    public Base32(final boolean useHex) {
<span class="fc" id="L219">        this(0, null, useHex, PAD_DEFAULT);</span>
<span class="fc" id="L220">    }</span>

    /**
     * Constructs a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking).
     * &lt;/p&gt;
     *
     * @param useHex  if {@code true} then use Base32 Hex alphabet
     * @param padding byte used as padding byte.
     */
    public Base32(final boolean useHex, final byte padding) {
<span class="fc" id="L232">        this(0, null, useHex, padding);</span>
<span class="fc" id="L233">    }</span>

    /**
     * Constructs a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is 0 (no chunking).
     * &lt;/p&gt;
     *
     * @param pad byte used as padding byte.
     */
    public Base32(final byte pad) {
<span class="fc" id="L244">        this(false, pad);</span>
<span class="fc" id="L245">    }</span>

    /**
     * Constructs a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length is given in the constructor, the line separator is CRLF.
     * &lt;/p&gt;
     *
     * @param lineLength Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &amp;lt;= 0, then
     *                   the output will not be divided into lines (chunks). Ignored when decoding.
     */
    public Base32(final int lineLength) {
<span class="fc" id="L257">        this(lineLength, CHUNK_SEPARATOR);</span>
<span class="fc" id="L258">    }</span>

    /**
     * Constructs a Base32 codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &amp;lt;= 0,
     *                      then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters.
     */
    public Base32(final int lineLength, final byte[] lineSeparator) {
<span class="fc" id="L275">        this(lineLength, lineSeparator, false, PAD_DEFAULT);</span>
<span class="fc" id="L276">    }</span>

    /**
     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &amp;lt;= 0,
     *                      then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
     * @param useHex        if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &amp;gt; 0 and lineSeparator is null.
     */
    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {
<span class="fc" id="L294">        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);</span>
<span class="fc" id="L295">    }</span>

    /**
     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &amp;lt;= 0,
     *                      then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
     * @param useHex        if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
     * @param padding       padding byte.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &amp;gt; 0 and lineSeparator is null.
     */
    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding) {
<span class="fc" id="L314">        this(lineLength, lineSeparator, useHex, padding, DECODING_POLICY_DEFAULT);</span>
<span class="fc" id="L315">    }</span>

    /**
     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &amp;lt;= 0,
     *                       then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.
     * @param useHex         if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet
     * @param padding        padding byte.
     * @param decodingPolicy The decoding policy.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &amp;gt; 0 and lineSeparator is null.
     * @since 1.15
     */
    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding, final CodecPolicy decodingPolicy) {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        this(lineLength, lineSeparator, useHex ? HEX_ENCODE_TABLE : ENCODE_TABLE, padding, decodingPolicy);</span>
<span class="fc" id="L337">    }</span>

    /**
     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.
     * &lt;p&gt;
     * When encoding the line length and line separator are given in the constructor.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.
     * &lt;/p&gt;
     *
     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &amp;lt;= 0,
     *                       then the output will not be divided into lines (chunks). Ignored when decoding.
     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.
     * @param encodeTable    A Base32 alphabet.
     * @param padding        padding byte.
     * @param decodingPolicy The decoding policy.
     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &amp;gt; 0 and lineSeparator is null.
     */
    private Base32(final int lineLength, final byte[] lineSeparator, final byte[] encodeTable, final byte padding, final CodecPolicy decodingPolicy) {
<span class="fc" id="L357">        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, toLength(lineSeparator), padding, decodingPolicy);</span>
<span class="fc" id="L358">        Objects.requireNonNull(encodeTable, &quot;encodeTable&quot;);</span>
<span class="fc" id="L359">        this.encodeTable = encodeTable;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        this.decodeTable = encodeTable == HEX_ENCODE_TABLE ? HEX_DECODE_TABLE : DECODE_TABLE;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (lineLength &gt; 0) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (lineSeparator == null) {</span>
<span class="fc" id="L363">                throw new IllegalArgumentException(&quot;lineLength &quot; + lineLength + &quot; &gt; 0, but lineSeparator is null&quot;);</span>
            }
<span class="fc" id="L365">            final byte[] lineSeparatorCopy = lineSeparator.clone();</span>
            // Must be done after initializing the tables
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (containsAlphabetOrPad(lineSeparatorCopy)) {</span>
<span class="fc" id="L368">                final String sep = StringUtils.newStringUtf8(lineSeparatorCopy);</span>
<span class="fc" id="L369">                throw new IllegalArgumentException(&quot;lineSeparator must not contain Base32 characters: [&quot; + sep + &quot;]&quot;);</span>
            }
<span class="fc" id="L371">            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparatorCopy.length;</span>
<span class="fc" id="L372">            this.lineSeparator = lineSeparatorCopy;</span>
<span class="fc" id="L373">        } else {</span>
<span class="fc" id="L374">            this.encodeSize = BYTES_PER_ENCODED_BLOCK;</span>
<span class="fc" id="L375">            this.lineSeparator = null;</span>
        }
<span class="fc bfc" id="L377" title="All 4 branches covered.">        if (isInAlphabet(padding) || Character.isWhitespace(padding)) {</span>
<span class="fc" id="L378">            throw new IllegalArgumentException(&quot;pad must not be in alphabet or whitespace&quot;);</span>
        }
<span class="fc" id="L380">    }</span>

    /**
     * &lt;p&gt;
     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once with the data to decode, and once with
     * inAvail set to &quot;-1&quot; to alert decoder that EOF has been reached. The &quot;-1&quot; call is not necessary when decoding, but it doesn't hurt, either.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are silently ignored, but has implications
     * for other bytes, too. This method subscribes to the garbage-in, garbage-out philosophy: it will not check the provided data for validity.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Output is written to {@link org.apache.commons.codec.binary.BaseNCodec.Context#buffer Context#buffer} as 8-bit octets, using
     * {@link org.apache.commons.codec.binary.BaseNCodec.Context#pos Context#pos} as the buffer position
     * &lt;/p&gt;
     *
     * @param input   byte[] array of ASCII data to Base32 decode.
     * @param inPos   Position to start reading data from.
     * @param inAvail Amount of bytes available from input for decoding.
     * @param context the context to be used
     */
    @Override
    void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
        // package protected for access from I/O streams
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (context.eof) {</span>
<span class="fc" id="L405">            return;</span>
        }
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (inAvail &lt; 0) {</span>
<span class="fc" id="L408">            context.eof = true;</span>
        }
<span class="fc" id="L410">        final int decodeSize = this.encodeSize - 1;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (int i = 0; i &lt; inAvail; i++) {</span>
<span class="fc" id="L412">            final byte b = input[inPos++];</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if (b == pad) {</span>
                // We're done.
<span class="fc" id="L415">                context.eof = true;</span>
<span class="fc" id="L416">                break;</span>
            }
<span class="fc" id="L418">            final byte[] buffer = ensureBufferSize(decodeSize, context);</span>
<span class="pc bpc" id="L419" title="2 of 4 branches missed.">            if (b &gt;= 0 &amp;&amp; b &lt; this.decodeTable.length) {</span>
<span class="fc" id="L420">                final int result = this.decodeTable[b];</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                if (result &gt;= 0) {</span>
<span class="fc" id="L422">                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;</span>
                    // collect decoded bytes
<span class="fc" id="L424">                    context.lbitWorkArea = (context.lbitWorkArea &lt;&lt; BITS_PER_ENCODED_BYTE) + result;</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                    if (context.modulus == 0) { // we can output the 5 bytes</span>
<span class="fc" id="L426">                        buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 32 &amp; MASK_8BITS);</span>
<span class="fc" id="L427">                        buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 24 &amp; MASK_8BITS);</span>
<span class="fc" id="L428">                        buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 16 &amp; MASK_8BITS);</span>
<span class="fc" id="L429">                        buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</span>
<span class="fc" id="L430">                        buffer[context.pos++] = (byte) (context.lbitWorkArea &amp; MASK_8BITS);</span>
                    }
                }
            }
        }
        // Two forms of EOF as far as Base32 decoder is concerned: actual
        // EOF (-1) and first time '=' character is encountered in stream.
        // This approach makes the '=' padding characters completely optional.
<span class="fc bfc" id="L438" title="All 4 branches covered.">        if (context.eof &amp;&amp; context.modulus &gt; 0) { // if modulus == 0, nothing to do</span>
<span class="fc" id="L439">            final byte[] buffer = ensureBufferSize(decodeSize, context);</span>
            // We ignore partial bytes, i.e. only multiples of 8 count.
            // Any combination not part of a valid encoding is either partially decoded
            // or will raise an exception. Possible trailing characters are 2, 4, 5, 7.
            // It is not possible to encode with 1, 3, 6 trailing characters.
            // For backwards compatibility 3 &amp; 6 chars are decoded anyway rather than discarded.
            // See the encode(byte[]) method EOF section.
<span class="pc bpc" id="L446" title="1 of 8 branches missed.">            switch (context.modulus) {</span>
//              case 0 : // impossible, as excluded above
            case 1: // 5 bits - either ignore entirely, or raise an exception
<span class="fc" id="L449">                validateTrailingCharacters();</span>
            case 2: // 10 bits, drop 2 and output one byte
<span class="fc" id="L451">                validateCharacter(MASK_2BITS, context);</span>
<span class="fc" id="L452">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 2 &amp; MASK_8BITS);</span>
<span class="fc" id="L453">                break;</span>
            case 3: // 15 bits, drop 7 and output 1 byte, or raise an exception
<span class="fc" id="L455">                validateTrailingCharacters();</span>
                // Not possible from a valid encoding but decode anyway
<span class="fc" id="L457">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 7 &amp; MASK_8BITS);</span>
<span class="fc" id="L458">                break;</span>
            case 4: // 20 bits = 2*8 + 4
<span class="fc" id="L460">                validateCharacter(MASK_4BITS, context);</span>
<span class="fc" id="L461">                context.lbitWorkArea = context.lbitWorkArea &gt;&gt; 4; // drop 4 bits</span>
<span class="fc" id="L462">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</span>
<span class="fc" id="L463">                buffer[context.pos++] = (byte) (context.lbitWorkArea &amp; MASK_8BITS);</span>
<span class="fc" id="L464">                break;</span>
            case 5: // 25 bits = 3*8 + 1
<span class="fc" id="L466">                validateCharacter(MASK_1BITS, context);</span>
<span class="fc" id="L467">                context.lbitWorkArea = context.lbitWorkArea &gt;&gt; 1;</span>
<span class="fc" id="L468">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 16 &amp; MASK_8BITS);</span>
<span class="fc" id="L469">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</span>
<span class="fc" id="L470">                buffer[context.pos++] = (byte) (context.lbitWorkArea &amp; MASK_8BITS);</span>
<span class="fc" id="L471">                break;</span>
            case 6: // 30 bits = 3*8 + 6, or raise an exception
<span class="fc" id="L473">                validateTrailingCharacters();</span>
                // Not possible from a valid encoding but decode anyway
<span class="fc" id="L475">                context.lbitWorkArea = context.lbitWorkArea &gt;&gt; 6;</span>
<span class="fc" id="L476">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 16 &amp; MASK_8BITS);</span>
<span class="fc" id="L477">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</span>
<span class="fc" id="L478">                buffer[context.pos++] = (byte) (context.lbitWorkArea &amp; MASK_8BITS);</span>
<span class="fc" id="L479">                break;</span>
            case 7: // 35 bits = 4*8 +3
<span class="fc" id="L481">                validateCharacter(MASK_3BITS, context);</span>
<span class="fc" id="L482">                context.lbitWorkArea = context.lbitWorkArea &gt;&gt; 3;</span>
<span class="fc" id="L483">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 24 &amp; MASK_8BITS);</span>
<span class="fc" id="L484">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 16 &amp; MASK_8BITS);</span>
<span class="fc" id="L485">                buffer[context.pos++] = (byte) (context.lbitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</span>
<span class="fc" id="L486">                buffer[context.pos++] = (byte) (context.lbitWorkArea &amp; MASK_8BITS);</span>
<span class="fc" id="L487">                break;</span>
            default:
                // modulus can be 0-7, and we excluded 0,1 already
<span class="nc" id="L490">                throw new IllegalStateException(&quot;Impossible modulus &quot; + context.modulus);</span>
            }
        }
<span class="fc" id="L493">    }</span>

    /**
     * &lt;p&gt;
     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with
     * inAvail set to &quot;-1&quot; to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 5).
     * &lt;/p&gt;
     *
     * @param input   byte[] array of binary data to Base32 encode.
     * @param inPos   Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     * @param context the context to be used
     */
    @Override
    void encode(final byte[] input, int inPos, final int inAvail, final Context context) {
        // package protected for access from I/O streams
<span class="fc bfc" id="L509" title="All 2 branches covered.">        if (context.eof) {</span>
<span class="fc" id="L510">            return;</span>
        }
        // inAvail &lt; 0 is how we're informed of EOF in the underlying data we're
        // encoding.
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (inAvail &lt; 0) {</span>
<span class="fc" id="L515">            context.eof = true;</span>
<span class="fc bfc" id="L516" title="All 4 branches covered.">            if (0 == context.modulus &amp;&amp; lineLength == 0) {</span>
<span class="fc" id="L517">                return; // no leftovers to process and not using chunking</span>
            }
<span class="fc" id="L519">            final byte[] buffer = ensureBufferSize(encodeSize, context);</span>
<span class="fc" id="L520">            final int savedPos = context.pos;</span>
<span class="pc bpc" id="L521" title="1 of 6 branches missed.">            switch (context.modulus) { // % 5</span>
            case 0:
<span class="fc" id="L523">                break;</span>
            case 1: // Only 1 octet; take top 5 bits then remainder
<span class="fc" id="L525">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 3) &amp; MASK_5BITS]; // 8-1*5 = 3</span>
<span class="fc" id="L526">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &lt;&lt; 2) &amp; MASK_5BITS]; // 5-3=2</span>
<span class="fc" id="L527">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L528">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L529">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L530">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L531">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L532">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L533">                break;</span>
            case 2: // 2 octets = 16 bits to use
<span class="fc" id="L535">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 11) &amp; MASK_5BITS]; // 16-1*5 = 11</span>
<span class="fc" id="L536">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 6) &amp; MASK_5BITS]; // 16-2*5 = 6</span>
<span class="fc" id="L537">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 1) &amp; MASK_5BITS]; // 16-3*5 = 1</span>
<span class="fc" id="L538">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &lt;&lt; 4) &amp; MASK_5BITS]; // 5-1 = 4</span>
<span class="fc" id="L539">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L540">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L541">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L542">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L543">                break;</span>
            case 3: // 3 octets = 24 bits to use
<span class="fc" id="L545">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 19) &amp; MASK_5BITS]; // 24-1*5 = 19</span>
<span class="fc" id="L546">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 14) &amp; MASK_5BITS]; // 24-2*5 = 14</span>
<span class="fc" id="L547">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 9) &amp; MASK_5BITS]; // 24-3*5 = 9</span>
<span class="fc" id="L548">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 4) &amp; MASK_5BITS]; // 24-4*5 = 4</span>
<span class="fc" id="L549">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &lt;&lt; 1) &amp; MASK_5BITS]; // 5-4 = 1</span>
<span class="fc" id="L550">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L551">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L552">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L553">                break;</span>
            case 4: // 4 octets = 32 bits to use
<span class="fc" id="L555">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 27) &amp; MASK_5BITS]; // 32-1*5 = 27</span>
<span class="fc" id="L556">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 22) &amp; MASK_5BITS]; // 32-2*5 = 22</span>
<span class="fc" id="L557">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 17) &amp; MASK_5BITS]; // 32-3*5 = 17</span>
<span class="fc" id="L558">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 12) &amp; MASK_5BITS]; // 32-4*5 = 12</span>
<span class="fc" id="L559">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 7) &amp; MASK_5BITS]; // 32-5*5 = 7</span>
<span class="fc" id="L560">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 2) &amp; MASK_5BITS]; // 32-6*5 = 2</span>
<span class="fc" id="L561">                buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &lt;&lt; 3) &amp; MASK_5BITS]; // 5-2 = 3</span>
<span class="fc" id="L562">                buffer[context.pos++] = pad;</span>
<span class="fc" id="L563">                break;</span>
            default:
<span class="nc" id="L565">                throw new IllegalStateException(&quot;Impossible modulus &quot; + context.modulus);</span>
            }
<span class="fc" id="L567">            context.currentLinePos += context.pos - savedPos; // keep track of current line position</span>
            // if currentPos == 0 we are at the start of a line, so don't add CRLF
<span class="fc bfc" id="L569" title="All 4 branches covered.">            if (lineLength &gt; 0 &amp;&amp; context.currentLinePos &gt; 0) { // add chunk separator if required</span>
<span class="fc" id="L570">                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);</span>
<span class="fc" id="L571">                context.pos += lineSeparator.length;</span>
            }
<span class="fc" id="L573">        } else {</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            for (int i = 0; i &lt; inAvail; i++) {</span>
<span class="fc" id="L575">                final byte[] buffer = ensureBufferSize(encodeSize, context);</span>
<span class="fc" id="L576">                context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;</span>
<span class="fc" id="L577">                int b = input[inPos++];</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (b &lt; 0) {</span>
<span class="fc" id="L579">                    b += 256;</span>
                }
<span class="fc" id="L581">                context.lbitWorkArea = (context.lbitWorkArea &lt;&lt; 8) + b; // BITS_PER_BYTE</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                if (0 == context.modulus) { // we have enough bytes to create our output</span>
<span class="fc" id="L583">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 35) &amp; MASK_5BITS];</span>
<span class="fc" id="L584">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 30) &amp; MASK_5BITS];</span>
<span class="fc" id="L585">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 25) &amp; MASK_5BITS];</span>
<span class="fc" id="L586">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 20) &amp; MASK_5BITS];</span>
<span class="fc" id="L587">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 15) &amp; MASK_5BITS];</span>
<span class="fc" id="L588">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 10) &amp; MASK_5BITS];</span>
<span class="fc" id="L589">                    buffer[context.pos++] = encodeTable[(int) (context.lbitWorkArea &gt;&gt; 5) &amp; MASK_5BITS];</span>
<span class="fc" id="L590">                    buffer[context.pos++] = encodeTable[(int) context.lbitWorkArea &amp; MASK_5BITS];</span>
<span class="fc" id="L591">                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;</span>
<span class="fc bfc" id="L592" title="All 4 branches covered.">                    if (lineLength &gt; 0 &amp;&amp; lineLength &lt;= context.currentLinePos) {</span>
<span class="fc" id="L593">                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);</span>
<span class="fc" id="L594">                        context.pos += lineSeparator.length;</span>
<span class="fc" id="L595">                        context.currentLinePos = 0;</span>
                    }
                }
            }
        }
<span class="fc" id="L600">    }</span>

    /**
     * Gets the line separator (for testing only).
     *
     * @return the line separator.
     */
    byte[] getLineSeparator() {
<span class="fc" id="L608">        return lineSeparator;</span>
    }

    /**
     * Returns whether or not the {@code octet} is in the Base32 alphabet.
     *
     * @param octet The value to test
     * @return {@code true} if the value is defined in the Base32 alphabet {@code false} otherwise.
     */
    @Override
    public boolean isInAlphabet(final byte octet) {
<span class="fc bfc" id="L619" title="All 6 branches covered.">        return octet &gt;= 0 &amp;&amp; octet &lt; decodeTable.length &amp;&amp; decodeTable[octet] != -1;</span>
    }

    /**
     * Validates whether decoding the final trailing character is possible in the context of the set of possible base 32 values.
     * &lt;p&gt;
     * The character is valid if the lower bits within the provided mask are zero. This is used to test the final trailing base-32 digit is zero in the bits
     * that will be discarded.
     * &lt;/p&gt;
     *
     * @param emptyBitsMask The mask of the lower bits that should be empty
     * @param context       the context to be used
     *
     * @throws IllegalArgumentException if the bits being checked contain any non-zero value
     */
    private void validateCharacter(final long emptyBitsMask, final Context context) {
        // Use the long bit work area
<span class="fc bfc" id="L636" title="All 4 branches covered.">        if (isStrictDecoding() &amp;&amp; (context.lbitWorkArea &amp; emptyBitsMask) != 0) {</span>
<span class="fc" id="L637">            throw new IllegalArgumentException(&quot;Strict decoding: Last encoded character (before the paddings if any) is a valid &quot; +</span>
                    &quot;base 32 alphabet but not a possible encoding. Expected the discarded bits from the character to be zero.&quot;);
        }
<span class="fc" id="L640">    }</span>

    /**
     * Validates whether decoding allows final trailing characters that cannot be created during encoding.
     *
     * @throws IllegalArgumentException if strict decoding is enabled
     */
    private void validateTrailingCharacters() {
<span class="fc bfc" id="L648" title="All 2 branches covered.">        if (isStrictDecoding()) {</span>
<span class="fc" id="L649">            throw new IllegalArgumentException(&quot;Strict decoding: Last encoded character(s) (before the paddings if any) are valid &quot; +</span>
                    &quot;base 32 alphabet but not a possible encoding. Decoding requires either 2, 4, 5, or 7 trailing 5-bit characters to create bytes.&quot;);
        }
<span class="fc" id="L652">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>