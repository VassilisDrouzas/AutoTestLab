<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasicDataSource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons DBCP</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.dbcp2</a> &gt; <span class="el_source">BasicDataSource.java</span></div><h1>BasicDataSource.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.dbcp2;

import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.time.Duration;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.management.MBeanRegistration;
import javax.management.MBeanServer;
import javax.management.MalformedObjectNameException;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectName;
import javax.management.StandardMBean;
import javax.sql.DataSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.impl.AbandonedConfig;
import org.apache.commons.pool2.impl.BaseObjectPoolConfig;
import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

/**
 * Basic implementation of {@code javax.sql.DataSource} that is configured via JavaBeans properties.
 *
 * &lt;p&gt;
 * This is not the only way to combine the &lt;em&gt;commons-dbcp2&lt;/em&gt; and &lt;em&gt;commons-pool2&lt;/em&gt; packages, but provides a
 * one-stop solution for basic requirements.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
<span class="fc" id="L69">public class BasicDataSource implements DataSource, BasicDataSourceMXBean, MBeanRegistration, AutoCloseable {</span>

<span class="fc" id="L71">    private static final Log log = LogFactory.getLog(BasicDataSource.class);</span>

    static {
        // Attempt to prevent deadlocks - see DBCP - 272
<span class="fc" id="L75">        DriverManager.getDrivers();</span>
        try {
            // Load classes now to prevent AccessControlExceptions later
            // A number of classes are loaded when getConnection() is called
            // but the following classes are not loaded and therefore require
            // explicit loading.
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if (Utils.isSecurityEnabled()) {</span>
<span class="nc" id="L82">                final ClassLoader loader = BasicDataSource.class.getClassLoader();</span>
<span class="nc" id="L83">                final String dbcpPackageName = BasicDataSource.class.getPackage().getName();</span>
<span class="nc" id="L84">                loader.loadClass(dbcpPackageName + &quot;.DelegatingCallableStatement&quot;);</span>
<span class="nc" id="L85">                loader.loadClass(dbcpPackageName + &quot;.DelegatingDatabaseMetaData&quot;);</span>
<span class="nc" id="L86">                loader.loadClass(dbcpPackageName + &quot;.DelegatingPreparedStatement&quot;);</span>
<span class="nc" id="L87">                loader.loadClass(dbcpPackageName + &quot;.DelegatingResultSet&quot;);</span>
<span class="nc" id="L88">                loader.loadClass(dbcpPackageName + &quot;.PoolableCallableStatement&quot;);</span>
<span class="nc" id="L89">                loader.loadClass(dbcpPackageName + &quot;.PoolablePreparedStatement&quot;);</span>
<span class="nc" id="L90">                loader.loadClass(dbcpPackageName + &quot;.PoolingConnection$StatementType&quot;);</span>
<span class="nc" id="L91">                loader.loadClass(dbcpPackageName + &quot;.PStmtKey&quot;);</span>

<span class="nc" id="L93">                final String poolPackageName = PooledObject.class.getPackage().getName();</span>
<span class="nc" id="L94">                loader.loadClass(poolPackageName + &quot;.impl.LinkedBlockingDeque$Node&quot;);</span>
<span class="nc" id="L95">                loader.loadClass(poolPackageName + &quot;.impl.GenericKeyedObjectPool$ObjectDeque&quot;);</span>
            }
<span class="nc" id="L97">        } catch (final ClassNotFoundException cnfe) {</span>
<span class="nc" id="L98">            throw new IllegalStateException(&quot;Unable to pre-load classes&quot;, cnfe);</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">    }</span>

    /**
     * Validates the given factory.
     *
     * @param connectionFactory the factory
     * @throws SQLException Thrown by one of the factory methods while managing a temporary pooled object.
     */
    @SuppressWarnings(&quot;resource&quot;)
    protected static void validateConnectionFactory(final PoolableConnectionFactory connectionFactory) throws SQLException {
<span class="fc" id="L110">        PoolableConnection conn = null;</span>
<span class="fc" id="L111">        PooledObject&lt;PoolableConnection&gt; p = null;</span>
        try {
<span class="fc" id="L113">            p = connectionFactory.makeObject();</span>
<span class="fc" id="L114">            conn = p.getObject();</span>
<span class="fc" id="L115">            connectionFactory.activateObject(p);</span>
<span class="fc" id="L116">            connectionFactory.validateConnection(conn);</span>
<span class="fc" id="L117">            connectionFactory.passivateObject(p);</span>
        } finally {
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (p != null) {</span>
<span class="fc" id="L120">                connectionFactory.destroyObject(p);</span>
            }
        }
<span class="fc" id="L123">    }</span>

    /**
     * The default auto-commit state of connections created by this pool.
     */
    private volatile Boolean defaultAutoCommit;

    /**
     * The default read-only state of connections created by this pool.
     */
    private transient Boolean defaultReadOnly;

    /**
     * The default TransactionIsolation state of connections created by this pool.
     */
<span class="fc" id="L138">    private volatile int defaultTransactionIsolation = PoolableConnectionFactory.UNKNOWN_TRANSACTION_ISOLATION;</span>

    private Duration defaultQueryTimeoutDuration;

    /**
     * The default &quot;catalog&quot; of connections created by this pool.
     */
    private volatile String defaultCatalog;

    /**
     * The default &quot;schema&quot; of connections created by this pool.
     */
    private volatile String defaultSchema;

    /**
     * The property that controls if the pooled connections cache some state rather than query the database for current
     * state to improve performance.
     */
<span class="fc" id="L156">    private boolean cacheState = true;</span>

    /**
     * The instance of the JDBC Driver to use.
     */
    private Driver driver;

    /**
     * The fully qualified Java class name of the JDBC driver to be used.
     */
    private String driverClassName;

    /**
     * The class loader instance to use to load the JDBC driver. If not specified, {@link Class#forName(String)} is used
     * to load the JDBC driver. If specified, {@link Class#forName(String, boolean, ClassLoader)} is used.
     */
    private ClassLoader driverClassLoader;

    /**
     * True means that borrowObject returns the most recently used (&quot;last in&quot;) connection in the pool (if there are idle
     * connections available). False means that the pool behaves as a FIFO queue - connections are taken from the idle
     * instance pool in the order that they are returned to the pool.
     */
<span class="fc" id="L179">    private boolean lifo = BaseObjectPoolConfig.DEFAULT_LIFO;</span>

    /**
     * The maximum number of active connections that can be allocated from this pool at the same time, or negative for
     * no limit.
     */
<span class="fc" id="L185">    private int maxTotal = GenericObjectPoolConfig.DEFAULT_MAX_TOTAL;</span>

    /**
     * The maximum number of connections that can remain idle in the pool, without extra ones being destroyed, or
     * negative for no limit. If maxIdle is set too low on heavily loaded systems it is possible you will see
     * connections being closed and almost immediately new connections being opened. This is a result of the active
     * threads momentarily closing connections faster than they are opening them, causing the number of idle connections
     * to rise above maxIdle. The best value for maxIdle for heavily loaded system will vary but the default is a good
     * starting point.
     */
<span class="fc" id="L195">    private int maxIdle = GenericObjectPoolConfig.DEFAULT_MAX_IDLE;</span>

    /**
     * The minimum number of active connections that can remain idle in the pool, without extra ones being created when
     * the evictor runs, or 0 to create none. The pool attempts to ensure that minIdle connections are available when
     * the idle object evictor runs. The value of this property has no effect unless
     * {@link #durationBetweenEvictionRuns} has a positive value.
     */
<span class="fc" id="L203">    private int minIdle = GenericObjectPoolConfig.DEFAULT_MIN_IDLE;</span>

    /**
     * The initial number of connections that are created when the pool is started.
     */
    private int initialSize;

    /**
     * The maximum Duration that the pool will wait (when there are no available connections) for a
     * connection to be returned before throwing an exception, or &lt;= 0 to wait indefinitely.
     */
<span class="fc" id="L214">    private Duration maxWaitDuration = BaseObjectPoolConfig.DEFAULT_MAX_WAIT;</span>

    /**
     * Prepared statement pooling for this pool. When this property is set to {@code true} both PreparedStatements
     * and CallableStatements are pooled.
     */
    private boolean poolPreparedStatements;

    private boolean clearStatementPoolOnReturn;

    /**
     * &lt;p&gt;
     * The maximum number of open statements that can be allocated from the statement pool at the same time, or negative
     * for no limit. Since a connection usually only uses one or two statements at a time, this is mostly used to help
     * detect resource leaks.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Note: As of version 1.3, CallableStatements (those produced by {@link Connection#prepareCall}) are pooled along
     * with PreparedStatements (produced by {@link Connection#prepareStatement}) and
     * {@code maxOpenPreparedStatements} limits the total number of prepared or callable statements that may be in
     * use at a given time.
     * &lt;/p&gt;
     */
<span class="fc" id="L237">    private int maxOpenPreparedStatements = GenericKeyedObjectPoolConfig.DEFAULT_MAX_TOTAL;</span>

    /**
     * The indication of whether objects will be validated as soon as they have been created by the pool. If the object
     * fails to validate, the borrow operation that triggered the creation will fail.
     */
    private boolean testOnCreate;

    /**
     * The indication of whether objects will be validated before being borrowed from the pool. If the object fails to
     * validate, it will be dropped from the pool, and we will attempt to borrow another.
     */
<span class="fc" id="L249">    private boolean testOnBorrow = true;</span>

    /**
     * The indication of whether objects will be validated before being returned to the pool.
     */
    private boolean testOnReturn;

    /**
     * The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle
     * object evictor thread will be run.
     */
<span class="fc" id="L260">    private Duration durationBetweenEvictionRuns = BaseObjectPoolConfig.DEFAULT_DURATION_BETWEEN_EVICTION_RUNS;</span>

    /**
     * The number of objects to examine during each run of the idle object evictor thread (if any).
     */
<span class="fc" id="L265">    private int numTestsPerEvictionRun = BaseObjectPoolConfig.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;</span>

    /**
     * The minimum amount of time an object may sit idle in the pool before it is eligible for eviction by the idle
     * object evictor (if any).
     */
<span class="fc" id="L271">    private Duration minEvictableIdleDuration = BaseObjectPoolConfig.DEFAULT_MIN_EVICTABLE_IDLE_DURATION;</span>

    /**
     * The minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the idle
     * object evictor, with the extra condition that at least &quot;minIdle&quot; connections remain in the pool. Note that
     * {@code minEvictableIdleTimeMillis} takes precedence over this parameter. See
     * {@link #getSoftMinEvictableIdleDuration()}.
     */
<span class="fc" id="L279">    private Duration softMinEvictableIdleDuration = BaseObjectPoolConfig.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_DURATION;</span>

<span class="fc" id="L281">    private String evictionPolicyClassName = BaseObjectPoolConfig.DEFAULT_EVICTION_POLICY_CLASS_NAME;</span>

    /**
     * The indication of whether objects will be validated by the idle object evictor (if any). If an object fails to
     * validate, it will be dropped from the pool.
     */
    private boolean testWhileIdle;

    /**
     * The connection password to be passed to our JDBC driver to establish a connection.
     */
    private volatile String password;

    /**
     * The connection string to be passed to our JDBC driver to establish a connection.
     */
    private String connectionString;

    /**
     * The connection user name to be passed to our JDBC driver to establish a connection.
     */
    private String userName;

    /**
     * The SQL query that will be used to validate connections from this pool before returning them to the caller. If
     * specified, this query &lt;strong&gt;MUST&lt;/strong&gt; be an SQL SELECT statement that returns at least one row. If not
     * specified, {@link Connection#isValid(int)} will be used to validate connections.
     */
    private volatile String validationQuery;

    /**
     * Timeout in seconds before connection validation queries fail.
     */
<span class="fc" id="L314">    private volatile Duration validationQueryTimeoutDuration = Duration.ofSeconds(-1);</span>

    /**
     * The fully qualified Java class name of a {@link ConnectionFactory} implementation.
     */
    private String connectionFactoryClassName;

    /**
     * These SQL statements run once after a Connection is created.
     * &lt;p&gt;
     * This property can be used for example to run ALTER SESSION SET NLS_SORT=XCYECH in an Oracle Database only once
     * after connection creation.
     * &lt;/p&gt;
     */
    private volatile List&lt;String&gt; connectionInitSqls;

    /**
     * Controls access to the underlying connection.
     */
    private boolean accessToUnderlyingConnectionAllowed;

<span class="fc" id="L335">    private Duration maxConnDuration = Duration.ofMillis(-1);</span>

<span class="fc" id="L337">    private boolean logExpiredConnections = true;</span>

    private String jmxName;

<span class="fc" id="L341">    private boolean registerConnectionMBean = true;</span>

<span class="fc" id="L343">    private boolean autoCommitOnReturn = true;</span>

<span class="fc" id="L345">    private boolean rollbackOnReturn = true;</span>

    private volatile Set&lt;String&gt; disconnectionSqlCodes;

    private boolean fastFailValidation;

    /**
     * The object pool that internally manages our connections.
     */
    private volatile GenericObjectPool&lt;PoolableConnection&gt; connectionPool;

    /**
     * The connection properties that will be sent to our JDBC driver when establishing new connections.
     * &lt;strong&gt;NOTE&lt;/strong&gt; - The &quot;user&quot; and &quot;password&quot; properties will be passed explicitly, so they do not need to be
     * included here.
     */
<span class="fc" id="L361">    private Properties connectionProperties = new Properties();</span>

    /**
     * The data source we will use to manage connections. This object should be acquired &lt;strong&gt;ONLY&lt;/strong&gt; by calls
     * to the {@code createDataSource()} method.
     */
    private volatile DataSource dataSource;

    /**
     * The PrintWriter to which log messages should be directed.
     */
<span class="fc" id="L372">    private volatile PrintWriter logWriter = new PrintWriter(</span>
            new OutputStreamWriter(System.out, StandardCharsets.UTF_8));

    private AbandonedConfig abandonedConfig;

    private boolean closed;

    /**
     * Actual name under which this component has been registered.
     */
    private ObjectNameWrapper registeredJmxObjectName;

    /**
     * Adds a custom connection property to the set that will be passed to our JDBC driver. This &lt;strong&gt;MUST&lt;/strong&gt;
     * be called before the first connection is retrieved (along with all the other configuration property setters).
     * Calls to this method after the connection pool has been initialized have no effect.
     *
     * @param name  Name of the custom connection property
     * @param value Value of the custom connection property
     */
    public void addConnectionProperty(final String name, final String value) {
<span class="nc" id="L393">        connectionProperties.put(name, value);</span>
<span class="nc" id="L394">    }</span>

    /**
     * Closes and releases all idle connections that are currently stored in the connection pool associated with this
     * data source.
     * &lt;p&gt;
     * Connections that are checked out to clients when this method is invoked are not affected. When client
     * applications subsequently invoke {@link Connection#close()} to return these connections to the pool, the
     * underlying JDBC connections are closed.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Attempts to acquire connections using {@link #getConnection()} after this method has been invoked result in
     * SQLExceptions.  To reopen a datasource that has been closed using this method, use {@link #start()}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method is idempotent - i.e., closing an already closed BasicDataSource has no effect and does not generate
     * exceptions.
     * &lt;/p&gt;
     *
     * @throws SQLException if an error occurs closing idle connections
     */
    @Override
    public synchronized void close() throws SQLException {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (registeredJmxObjectName != null) {</span>
<span class="fc" id="L418">            registeredJmxObjectName.unregisterMBean();</span>
<span class="fc" id="L419">            registeredJmxObjectName = null;</span>
        }
<span class="fc" id="L421">        closed = true;</span>
<span class="fc" id="L422">        final GenericObjectPool&lt;?&gt; oldPool = connectionPool;</span>
<span class="fc" id="L423">        connectionPool = null;</span>
<span class="fc" id="L424">        dataSource = null;</span>
        try {
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (oldPool != null) {</span>
<span class="fc" id="L427">                oldPool.close();</span>
            }
<span class="nc" id="L429">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L430">            throw e;</span>
<span class="nc" id="L431">        } catch (final Exception e) {</span>
<span class="nc" id="L432">            throw new SQLException(Utils.getMessage(&quot;pool.close.fail&quot;), e);</span>
<span class="fc" id="L433">        }</span>
<span class="fc" id="L434">    }</span>

    /**
     * Closes the connection pool, silently swallowing any exception that occurs.
     */
    private void closeConnectionPool() {
<span class="fc" id="L440">        final GenericObjectPool&lt;?&gt; oldPool = connectionPool;</span>
<span class="fc" id="L441">        connectionPool = null;</span>
<span class="fc" id="L442">        Utils.closeQuietly(oldPool);</span>
<span class="fc" id="L443">    }</span>

    /**
     * Creates a JDBC connection factory for this data source. The JDBC driver is loaded using the following algorithm:
     * &lt;ol&gt;
     * &lt;li&gt;If a Driver instance has been specified via {@link #setDriver(Driver)} use it&lt;/li&gt;
     * &lt;li&gt;If no Driver instance was specified and {code driverClassName} is specified that class is loaded using the
     * {@link ClassLoader} of this class or, if {code driverClassLoader} is set, {code driverClassName} is loaded
     * with the specified {@link ClassLoader}.&lt;/li&gt;
     * &lt;li&gt;If {code driverClassName} is specified and the previous attempt fails, the class is loaded using the
     * context class loader of the current thread.&lt;/li&gt;
     * &lt;li&gt;If a driver still isn't loaded one is loaded via the {@link DriverManager} using the specified {code connectionString}.
     * &lt;/ol&gt;
     * &lt;p&gt;
     * This method exists so subclasses can replace the implementation class.
     * &lt;/p&gt;
     *
     * @return A new connection factory.
     *
     * @throws SQLException If the connection factory cannot be created
     */
    protected ConnectionFactory createConnectionFactory() throws SQLException {
        // Load the JDBC driver class
<span class="fc" id="L466">        return ConnectionFactoryFactory.createConnectionFactory(this, DriverFactory.createDriver(this));</span>
    }

    /**
     * Creates a connection pool for this datasource. This method only exists so subclasses can replace the
     * implementation class.
     * &lt;p&gt;
     * This implementation configures all pool properties other than timeBetweenEvictionRunsMillis. Setting that
     * property is deferred to {@link #startPoolMaintenance()}, since setting timeBetweenEvictionRunsMillis to a
     * positive value causes {@link GenericObjectPool}'s eviction timer to be started.
     * &lt;/p&gt;
     *
     * @param factory The factory to use to create new connections for this pool.
     */
    protected void createConnectionPool(final PoolableConnectionFactory factory) {
        // Create an object pool to contain our active connections
<span class="fc" id="L482">        final GenericObjectPoolConfig&lt;PoolableConnection&gt; config = new GenericObjectPoolConfig&lt;&gt;();</span>
<span class="fc" id="L483">        updateJmxName(config);</span>
        // Disable JMX on the underlying pool if the DS is not registered:
<span class="fc bfc" id="L485" title="All 2 branches covered.">        config.setJmxEnabled(registeredJmxObjectName != null);</span>
        // Set up usage tracking if enabled
<span class="pc bpc" id="L487" title="1 of 4 branches missed.">        if (getAbandonedUsageTracking() &amp;&amp; abandonedConfig != null) {</span>
<span class="fc" id="L488">            abandonedConfig.setUseUsageTracking(true);</span>
        }
<span class="fc" id="L490">        final GenericObjectPool&lt;PoolableConnection&gt; gop = createObjectPool(factory, config, abandonedConfig);</span>
<span class="fc" id="L491">        gop.setMaxTotal(maxTotal);</span>
<span class="fc" id="L492">        gop.setMaxIdle(maxIdle);</span>
<span class="fc" id="L493">        gop.setMinIdle(minIdle);</span>
<span class="fc" id="L494">        gop.setMaxWait(maxWaitDuration);</span>
<span class="fc" id="L495">        gop.setTestOnCreate(testOnCreate);</span>
<span class="fc" id="L496">        gop.setTestOnBorrow(testOnBorrow);</span>
<span class="fc" id="L497">        gop.setTestOnReturn(testOnReturn);</span>
<span class="fc" id="L498">        gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);</span>
<span class="fc" id="L499">        gop.setMinEvictableIdleDuration(minEvictableIdleDuration);</span>
<span class="fc" id="L500">        gop.setSoftMinEvictableIdleDuration(softMinEvictableIdleDuration);</span>
<span class="fc" id="L501">        gop.setTestWhileIdle(testWhileIdle);</span>
<span class="fc" id="L502">        gop.setLifo(lifo);</span>
<span class="fc" id="L503">        gop.setSwallowedExceptionListener(new SwallowedExceptionLogger(log, logExpiredConnections));</span>
<span class="fc" id="L504">        gop.setEvictionPolicyClassName(evictionPolicyClassName);</span>
<span class="fc" id="L505">        factory.setPool(gop);</span>
<span class="fc" id="L506">        connectionPool = gop;</span>
<span class="fc" id="L507">    }</span>

    /**
     * Creates (if necessary) and return the internal data source we are using to manage our connections.
     *
     * @return The current internal DataSource or a newly created instance if it has not yet been created.
     * @throws SQLException if the object pool cannot be created.
     */
    protected synchronized DataSource createDataSource() throws SQLException {
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (closed) {</span>
<span class="fc" id="L517">            throw new SQLException(&quot;Data source is closed&quot;);</span>
        }

        // Return the pool if we have already created it
        // This is double-checked locking. This is safe since dataSource is
        // volatile and the code is targeted at Java 5 onwards.
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (dataSource != null) {</span>
<span class="fc" id="L524">            return dataSource;</span>
        }
<span class="fc" id="L526">        synchronized (this) {</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if (dataSource != null) {</span>
<span class="nc" id="L528">                return dataSource;</span>
            }
<span class="fc" id="L530">            jmxRegister();</span>

            // create factory which returns raw physical connections
<span class="fc" id="L533">            final ConnectionFactory driverConnectionFactory = createConnectionFactory();</span>

            // Set up the poolable connection factory
            final PoolableConnectionFactory poolableConnectionFactory;
            try {
<span class="fc" id="L538">                poolableConnectionFactory = createPoolableConnectionFactory(driverConnectionFactory);</span>
<span class="fc" id="L539">                poolableConnectionFactory.setPoolStatements(poolPreparedStatements);</span>
<span class="fc" id="L540">                poolableConnectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);</span>
                // create a pool for our connections
<span class="fc" id="L542">                createConnectionPool(poolableConnectionFactory);</span>
<span class="fc" id="L543">                final DataSource newDataSource = createDataSourceInstance();</span>
<span class="fc" id="L544">                newDataSource.setLogWriter(logWriter);</span>
<span class="fc" id="L545">                connectionPool.addObjects(initialSize);</span>
                // If timeBetweenEvictionRunsMillis &gt; 0, start the pool's evictor
                // task
<span class="fc" id="L548">                startPoolMaintenance();</span>
<span class="fc" id="L549">                dataSource = newDataSource;</span>
<span class="fc" id="L550">            } catch (final SQLException | RuntimeException se) {</span>
<span class="fc" id="L551">                closeConnectionPool();</span>
<span class="fc" id="L552">                throw se;</span>
<span class="nc" id="L553">            } catch (final Exception ex) {</span>
<span class="nc" id="L554">                closeConnectionPool();</span>
<span class="nc" id="L555">                throw new SQLException(&quot;Error creating connection factory&quot;, ex);</span>
<span class="fc" id="L556">            }</span>

<span class="fc" id="L558">            return dataSource;</span>
        }
    }

    /**
     * Creates the actual data source instance. This method only exists so that subclasses can replace the
     * implementation class.
     *
     * @throws SQLException if unable to create a datasource instance
     *
     * @return A new DataSource instance
     */
    protected DataSource createDataSourceInstance() throws SQLException {
<span class="fc" id="L571">        final PoolingDataSource&lt;PoolableConnection&gt; pds = new PoolingDataSource&lt;&gt;(connectionPool);</span>
<span class="fc" id="L572">        pds.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());</span>
<span class="fc" id="L573">        return pds;</span>
    }

    /**
     * Creates an object pool used to provide pooling support for {@link Connection JDBC connections}.
     *
     * @param factory         the object factory
     * @param poolConfig      the object pool configuration
     * @param abandonedConfig the abandoned objects configuration
     * @return a non-null instance
     */
    protected GenericObjectPool&lt;PoolableConnection&gt; createObjectPool(final PoolableConnectionFactory factory,
            final GenericObjectPoolConfig&lt;PoolableConnection&gt; poolConfig, final AbandonedConfig abandonedConfig) {
        final GenericObjectPool&lt;PoolableConnection&gt; gop;
<span class="pc bpc" id="L587" title="1 of 4 branches missed.">        if (abandonedConfig != null &amp;&amp; (abandonedConfig.getRemoveAbandonedOnBorrow()</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                || abandonedConfig.getRemoveAbandonedOnMaintenance())) {</span>
<span class="fc" id="L589">            gop = new GenericObjectPool&lt;&gt;(factory, poolConfig, abandonedConfig);</span>
        } else {
<span class="fc" id="L591">            gop = new GenericObjectPool&lt;&gt;(factory, poolConfig);</span>
        }
<span class="fc" id="L593">        return gop;</span>
    }

    /**
     * Creates the PoolableConnectionFactory and attaches it to the connection pool. This method only exists so
     * subclasses can replace the default implementation.
     *
     * @param driverConnectionFactory JDBC connection factory
     * @throws SQLException if an error occurs creating the PoolableConnectionFactory
     *
     * @return A new PoolableConnectionFactory configured with the current configuration of this BasicDataSource
     */
    protected PoolableConnectionFactory createPoolableConnectionFactory(final ConnectionFactory driverConnectionFactory)
            throws SQLException {
<span class="fc" id="L607">        PoolableConnectionFactory connectionFactory = null;</span>
        try {
<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (registerConnectionMBean) {</span>
<span class="fc" id="L610">                connectionFactory = new PoolableConnectionFactory(driverConnectionFactory, ObjectNameWrapper.unwrap(registeredJmxObjectName));</span>
            } else {
<span class="fc" id="L612">                connectionFactory = new PoolableConnectionFactory(driverConnectionFactory, null);</span>
            }
<span class="fc" id="L614">            connectionFactory.setValidationQuery(validationQuery);</span>
<span class="fc" id="L615">            connectionFactory.setValidationQueryTimeout(validationQueryTimeoutDuration);</span>
<span class="fc" id="L616">            connectionFactory.setConnectionInitSql(connectionInitSqls);</span>
<span class="fc" id="L617">            connectionFactory.setDefaultReadOnly(defaultReadOnly);</span>
<span class="fc" id="L618">            connectionFactory.setDefaultAutoCommit(defaultAutoCommit);</span>
<span class="fc" id="L619">            connectionFactory.setDefaultTransactionIsolation(defaultTransactionIsolation);</span>
<span class="fc" id="L620">            connectionFactory.setDefaultCatalog(defaultCatalog);</span>
<span class="fc" id="L621">            connectionFactory.setDefaultSchema(defaultSchema);</span>
<span class="fc" id="L622">            connectionFactory.setCacheState(cacheState);</span>
<span class="fc" id="L623">            connectionFactory.setPoolStatements(poolPreparedStatements);</span>
<span class="fc" id="L624">            connectionFactory.setClearStatementPoolOnReturn(clearStatementPoolOnReturn);</span>
<span class="fc" id="L625">            connectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);</span>
<span class="fc" id="L626">            connectionFactory.setMaxConn(maxConnDuration);</span>
<span class="fc" id="L627">            connectionFactory.setRollbackOnReturn(getRollbackOnReturn());</span>
<span class="fc" id="L628">            connectionFactory.setAutoCommitOnReturn(getAutoCommitOnReturn());</span>
<span class="fc" id="L629">            connectionFactory.setDefaultQueryTimeout(getDefaultQueryTimeoutDuration());</span>
<span class="fc" id="L630">            connectionFactory.setFastFailValidation(fastFailValidation);</span>
<span class="fc" id="L631">            connectionFactory.setDisconnectionSqlCodes(disconnectionSqlCodes);</span>
<span class="fc" id="L632">            validateConnectionFactory(connectionFactory);</span>
<span class="nc" id="L633">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L634">            throw e;</span>
<span class="fc" id="L635">        } catch (final Exception e) {</span>
<span class="fc" id="L636">            throw new SQLException(&quot;Cannot create PoolableConnectionFactory (&quot; + e.getMessage() + &quot;)&quot;, e);</span>
<span class="fc" id="L637">        }</span>
<span class="fc" id="L638">        return connectionFactory;</span>
    }

    /**
     * Manually evicts idle connections
     *
     * @throws Exception when there is a problem evicting idle objects.
     */
    public void evict() throws Exception {
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if (connectionPool != null) {</span>
<span class="fc" id="L648">            connectionPool.evict();</span>
        }
<span class="fc" id="L650">    }</span>

    /**
     * Gets the print writer used by this configuration to log information on abandoned objects.
     *
     * @return The print writer used by this configuration to log information on abandoned objects.
     */
    public PrintWriter getAbandonedLogWriter() {
<span class="nc bnc" id="L658" title="All 2 branches missed.">        return abandonedConfig == null ? null : abandonedConfig.getLogWriter();</span>
    }

    /**
     * If the connection pool implements {@link org.apache.commons.pool2.UsageTracking UsageTracking}, should the
     * connection pool record a stack trace every time a method is called on a pooled connection and retain the most
     * recent stack trace to aid debugging of abandoned connections?
     *
     * @return {@code true} if usage tracking is enabled
     */
    @Override
    public boolean getAbandonedUsageTracking() {
<span class="fc bfc" id="L670" title="All 4 branches covered.">        return abandonedConfig != null &amp;&amp; abandonedConfig.getUseUsageTracking();</span>
    }

    /**
     * Gets the value of the flag that controls whether or not connections being returned to the pool will be checked
     * and configured with {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)} if the auto commit
     * setting is {@code false} when the connection is returned. It is {@code true} by default.
     *
     * @return Whether or not connections being returned to the pool will be checked and configured with auto-commit.
     */
    public boolean getAutoCommitOnReturn() {
<span class="fc" id="L681">        return autoCommitOnReturn;</span>
    }

    /**
     * Gets the state caching flag.
     *
     * @return the state caching flag
     */
    @Override
    public boolean getCacheState() {
<span class="fc" id="L691">        return cacheState;</span>
    }

    /**
     * Creates (if necessary) and return a connection to the database.
     *
     * @throws SQLException if a database access error occurs
     * @return a database connection
     */
    @Override
    public Connection getConnection() throws SQLException {
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">        if (Utils.isSecurityEnabled()) {</span>
<span class="nc" id="L703">            final PrivilegedExceptionAction&lt;Connection&gt; action = () -&gt; createDataSource().getConnection();</span>
            try {
<span class="nc" id="L705">                return AccessController.doPrivileged(action);</span>
<span class="nc" id="L706">            } catch (final PrivilegedActionException e) {</span>
<span class="nc" id="L707">                final Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                if (cause instanceof SQLException) {</span>
<span class="nc" id="L709">                    throw (SQLException) cause;</span>
                }
<span class="nc" id="L711">                throw new SQLException(e);</span>
            }
        }
<span class="fc" id="L714">        return createDataSource().getConnection();</span>
    }

    /**
     * &lt;strong&gt;BasicDataSource does NOT support this method.&lt;/strong&gt;
     *
     * @param user Database user on whose behalf the Connection is being made
     * @param pass The database user's password
     *
     * @throws UnsupportedOperationException always thrown.
     * @throws SQLException                  if a database access error occurs
     * @return nothing - always throws UnsupportedOperationException
     */
    @Override
    public Connection getConnection(final String user, final String pass) throws SQLException {
        // This method isn't supported by the PoolingDataSource returned by the
        // createDataSource
<span class="nc" id="L731">        throw new UnsupportedOperationException(&quot;Not supported by BasicDataSource&quot;);</span>
    }

    /**
     * Gets the ConnectionFactoryClassName that has been configured for use by this pool.
     * &lt;p&gt;
     * Note: This getter only returns the last value set by a call to {@link #setConnectionFactoryClassName(String)}.
     * &lt;/p&gt;
     *
     * @return the ConnectionFactoryClassName that has been configured for use by this pool.
     * @since 2.7.0
     */
    public String getConnectionFactoryClassName() {
<span class="fc" id="L744">        return this.connectionFactoryClassName;</span>
    }

    /**
     * Gets the list of SQL statements executed when a physical connection is first created. Returns an empty list if
     * there are no initialization statements configured.
     *
     * @return initialization SQL statements
     */
    public List&lt;String&gt; getConnectionInitSqls() {
<span class="fc" id="L754">        final List&lt;String&gt; result = connectionInitSqls;</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">        return result == null ? Collections.emptyList() : result;</span>
    }

    /**
     * Provides the same data as {@link #getConnectionInitSqls()} but in an array so it is accessible via JMX.
     */
    @Override
    public String[] getConnectionInitSqlsAsArray() {
<span class="nc" id="L763">        return getConnectionInitSqls().toArray(Utils.EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets the underlying connection pool.
     *
     * @return the underlying connection pool.
     * @since 2.10.0
     */
    public GenericObjectPool&lt;PoolableConnection&gt; getConnectionPool() {
<span class="fc" id="L773">        return connectionPool;</span>
    }

    Properties getConnectionProperties() {
<span class="fc" id="L777">        return connectionProperties;</span>
    }

    /**
     * Gets the default auto-commit property.
     *
     * @return true if default auto-commit is enabled
     */
    @Override
    public Boolean getDefaultAutoCommit() {
<span class="fc" id="L787">        return defaultAutoCommit;</span>
    }

    /**
     * Gets the default catalog.
     *
     * @return the default catalog
     */
    @Override
    public String getDefaultCatalog() {
<span class="fc" id="L797">        return this.defaultCatalog;</span>
    }

    /**
     * Gets the default query timeout that will be used for {@link java.sql.Statement Statement}s created from this
     * connection. {@code null} means that the driver default will be used.
     *
     * @return The default query timeout in seconds.
     * @deprecated Use {@link #getDefaultQueryTimeoutDuration()}.
     */
    @Deprecated
    public Integer getDefaultQueryTimeout() {
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        return defaultQueryTimeoutDuration == null ? null : (int) defaultQueryTimeoutDuration.getSeconds();</span>
    }

    /**
     * Gets the default query timeout that will be used for {@link java.sql.Statement Statement}s created from this
     * connection. {@code null} means that the driver default will be used.
     *
     * @return The default query timeout Duration.
     * @since 2.10.0
     */
    public Duration getDefaultQueryTimeoutDuration() {
<span class="fc" id="L820">        return defaultQueryTimeoutDuration;</span>
    }

    /**
     * Gets the default readOnly property.
     *
     * @return true if connections are readOnly by default
     */
    @Override
    public Boolean getDefaultReadOnly() {
<span class="fc" id="L830">        return defaultReadOnly;</span>
    }

    /**
     * Gets the default schema.
     *
     * @return the default schema.
     * @since 2.5.0
     */
    @Override
    public String getDefaultSchema() {
<span class="fc" id="L841">        return this.defaultSchema;</span>
    }

    /**
     * Gets the default transaction isolation state of returned connections.
     *
     * @return the default value for transaction isolation state
     * @see Connection#getTransactionIsolation
     */
    @Override
    public int getDefaultTransactionIsolation() {
<span class="fc" id="L852">        return this.defaultTransactionIsolation;</span>
    }

    /**
     * Gets the set of SQL_STATE codes considered to signal fatal conditions.
     *
     * @return fatal disconnection state codes
     * @see #setDisconnectionSqlCodes(Collection)
     * @since 2.1
     */
    public Set&lt;String&gt; getDisconnectionSqlCodes() {
<span class="fc" id="L863">        final Set&lt;String&gt; result = disconnectionSqlCodes;</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        return result == null ? Collections.emptySet() : result;</span>
    }

    /**
     * Provides the same data as {@link #getDisconnectionSqlCodes} but in an array so it is accessible via JMX.
     *
     * @since 2.1
     */
    @Override
    public String[] getDisconnectionSqlCodesAsArray() {
<span class="nc" id="L874">        return getDisconnectionSqlCodes().toArray(Utils.EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets the JDBC Driver that has been configured for use by this pool.
     * &lt;p&gt;
     * Note: This getter only returns the last value set by a call to {@link #setDriver(Driver)}. It does not return any
     * driver instance that may have been created from the value set via {@link #setDriverClassName(String)}.
     * &lt;/p&gt;
     *
     * @return the JDBC Driver that has been configured for use by this pool
     */
    public synchronized Driver getDriver() {
<span class="fc" id="L887">        return driver;</span>
    }

    /**
     * Gets the class loader specified for loading the JDBC driver. Returns {@code null} if no class loader has
     * been explicitly specified.
     * &lt;p&gt;
     * Note: This getter only returns the last value set by a call to {@link #setDriverClassLoader(ClassLoader)}. It
     * does not return the class loader of any driver that may have been set via {@link #setDriver(Driver)}.
     * &lt;/p&gt;
     *
     * @return The class loader specified for loading the JDBC driver.
     */
    public synchronized ClassLoader getDriverClassLoader() {
<span class="fc" id="L901">        return this.driverClassLoader;</span>
    }

    /**
     * Gets the JDBC driver class name.
     * &lt;p&gt;
     * Note: This getter only returns the last value set by a call to {@link #setDriverClassName(String)}. It does not
     * return the class name of any driver that may have been set via {@link #setDriver(Driver)}.
     * &lt;/p&gt;
     *
     * @return the JDBC driver class name
     */
    @Override
    public synchronized String getDriverClassName() {
<span class="fc" id="L915">        return this.driverClassName;</span>
    }

    /**
     * Gets the value of the {code durationBetweenEvictionRuns} property.
     *
     * @return the time (in milliseconds) between evictor runs
     * @see #setDurationBetweenEvictionRuns(Duration)
     * @since 2.10.0
     */
    public synchronized Duration getDurationBetweenEvictionRuns() {
<span class="fc" id="L926">        return this.durationBetweenEvictionRuns;</span>
    }

    /**
     * Gets the value of the flag that controls whether or not connections being returned to the pool will be checked
     * and configured with {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)} if the auto commit
     * setting is {@code false} when the connection is returned. It is {@code true} by default.
     *
     * @return Whether or not connections being returned to the pool will be checked and configured with auto-commit.
     * @deprecated Use {@link #getAutoCommitOnReturn()}.
     */
    @Deprecated
    public boolean getEnableAutoCommitOnReturn() {
<span class="nc" id="L939">        return autoCommitOnReturn;</span>
    }

    /**
     * Gets the EvictionPolicy implementation in use with this connection pool.
     *
     * @return The EvictionPolicy implementation in use with this connection pool.
     */
    public synchronized String getEvictionPolicyClassName() {
<span class="nc" id="L948">        return evictionPolicyClassName;</span>
    }

    /**
     * True means that validation will fail immediately for connections that have previously thrown SQLExceptions with
     * SQL_STATE indicating fatal disconnection errors.
     *
     * @return true if connections created by this datasource will fast fail validation.
     * @see #setDisconnectionSqlCodes(Collection)
     * @since 2.1
     */
    @Override
    public boolean getFastFailValidation() {
<span class="fc" id="L961">        return fastFailValidation;</span>
    }

    /**
     * Gets the initial size of the connection pool.
     *
     * @return the number of connections created when the pool is initialized
     */
    @Override
    public synchronized int getInitialSize() {
<span class="fc" id="L971">        return this.initialSize;</span>
    }

    /**
     * Gets the JMX name that has been requested for this DataSource. If the requested name is not valid, an
     * alternative may be chosen.
     *
     * @return The JMX name that has been requested for this DataSource.
     */
    public String getJmxName() {
<span class="fc" id="L981">        return jmxName;</span>
    }

    /**
     * Gets the LIFO property.
     *
     * @return true if connection pool behaves as a LIFO queue.
     */
    @Override
    public synchronized boolean getLifo() {
<span class="fc" id="L991">        return this.lifo;</span>
    }

    /**
     * Flag to log stack traces for application code which abandoned a Statement or Connection.
     * &lt;p&gt;
     * Defaults to false.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Logging of abandoned Statements and Connections adds overhead for every Connection open or new Statement because
     * a stack trace has to be generated.
     * &lt;/p&gt;
     */
    @Override
    public boolean getLogAbandoned() {
<span class="pc bpc" id="L1006" title="2 of 4 branches missed.">        return abandonedConfig != null &amp;&amp; abandonedConfig.getLogAbandoned();</span>
    }

    /**
     * When {@link #getMaxConnDuration()} is set to limit connection lifetime, this property determines whether or
     * not log messages are generated when the pool closes connections due to maximum lifetime exceeded.
     *
     * @since 2.1
     */
    @Override
    public boolean getLogExpiredConnections() {
<span class="nc" id="L1017">        return logExpiredConnections;</span>
    }

    /**
     * &lt;strong&gt;BasicDataSource does NOT support this method.&lt;/strong&gt;
     *
     * &lt;p&gt;
     * Gets the login timeout (in seconds) for connecting to the database.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
     * &lt;/p&gt;
     *
     * @throws SQLException                  if a database access error occurs
     * @throws UnsupportedOperationException If the DataSource implementation does not support the login timeout
     *                                       feature.
     * @return login timeout in seconds
     */
    @Override
    public int getLoginTimeout() throws SQLException {
        // This method isn't supported by the PoolingDataSource returned by the createDataSource
<span class="nc" id="L1038">        throw new UnsupportedOperationException(&quot;Not supported by BasicDataSource&quot;);</span>
    }

    /**
     * Gets the log writer being used by this data source.
     * &lt;p&gt;
     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
     * &lt;/p&gt;
     *
     * @throws SQLException if a database access error occurs
     * @return log writer in use
     */
    @Override
    public PrintWriter getLogWriter() throws SQLException {
<span class="fc" id="L1052">        return createDataSource().getLogWriter();</span>
    }

    /**
     * Gets the maximum permitted duration of a connection. A value of zero or less indicates an
     * infinite lifetime.
     * @return the maximum permitted duration of a connection.
     * @since 2.10.0
     */
    public Duration getMaxConnDuration() {
<span class="fc" id="L1062">        return maxConnDuration;</span>
    }

    /**
     * Gets the maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
     * infinite lifetime.
     * @deprecated Use {@link #getMaxConnDuration()}.
     */
    @Override
    @Deprecated
    public long getMaxConnLifetimeMillis() {
<span class="fc" id="L1073">        return maxConnDuration.toMillis();</span>
    }

    /**
     * Gets the maximum number of connections that can remain idle in the pool. Excess idle connections are destroyed
     * on return to the pool.
     * &lt;p&gt;
     * A negative value indicates that there is no limit
     * &lt;/p&gt;
     *
     * @return the maximum number of idle connections
     */
    @Override
    public synchronized int getMaxIdle() {
<span class="fc" id="L1087">        return this.maxIdle;</span>
    }

    /**
     * Gets the value of the {@code maxOpenPreparedStatements} property.
     *
     * @return the maximum number of open statements
     */
    @Override
    public synchronized int getMaxOpenPreparedStatements() {
<span class="fc" id="L1097">        return this.maxOpenPreparedStatements;</span>
    }

    /**
     * Gets the maximum number of active connections that can be allocated at the same time.
     * &lt;p&gt;
     * A negative number means that there is no limit.
     * &lt;/p&gt;
     *
     * @return the maximum number of active connections
     */
    @Override
    public synchronized int getMaxTotal() {
<span class="fc" id="L1110">        return this.maxTotal;</span>
    }

    /**
     * Gets the maximum Duration that the pool will wait for a connection to be returned before throwing an exception. A
     * value less than or equal to zero means the pool is set to wait indefinitely.
     *
     * @return the maxWaitDuration property value.
     * @since 2.10.0
     */
    public synchronized Duration getMaxWaitDuration() {
<span class="fc" id="L1121">        return this.maxWaitDuration;</span>
    }

    /**
     * Gets the maximum number of milliseconds that the pool will wait for a connection to be returned before
     * throwing an exception. A value less than or equal to zero means the pool is set to wait indefinitely.
     *
     * @return the maxWaitMillis property value.
     * @deprecated Use {@link #getMaxWaitDuration()}.
     */
    @Deprecated
    @Override
    public synchronized long getMaxWaitMillis() {
<span class="fc" id="L1134">        return this.maxWaitDuration.toMillis();</span>
    }

    /**
     * Gets the {code minEvictableIdleDuration} property.
     *
     * @return the value of the {code minEvictableIdleDuration} property
     * @see #setMinEvictableIdle(Duration)
     * @since 2.10.0
     */
    public synchronized Duration getMinEvictableIdleDuration() {
<span class="fc" id="L1145">        return this.minEvictableIdleDuration;</span>
    }

    /**
     * Gets the {code minEvictableIdleDuration} property.
     *
     * @return the value of the {code minEvictableIdleDuration} property
     * @see #setMinEvictableIdle(Duration)
     * @deprecated Use {@link #getMinEvictableIdleDuration()}.
     */
    @Deprecated
    @Override
    public synchronized long getMinEvictableIdleTimeMillis() {
<span class="fc" id="L1158">        return this.minEvictableIdleDuration.toMillis();</span>
    }

    /**
     * Gets the minimum number of idle connections in the pool. The pool attempts to ensure that minIdle connections
     * are available when the idle object evictor runs. The value of this property has no effect unless
     * {code durationBetweenEvictionRuns} has a positive value.
     *
     * @return the minimum number of idle connections
     * @see GenericObjectPool#getMinIdle()
     */
    @Override
    public synchronized int getMinIdle() {
<span class="fc" id="L1171">        return this.minIdle;</span>
    }

    /**
     * [Read Only] The current number of active connections that have been allocated from this data source.
     *
     * @return the current number of active connections
     */
    @Override
    public int getNumActive() {
        // Copy reference to avoid NPE if close happens after null check
<span class="fc" id="L1182">        final GenericObjectPool&lt;PoolableConnection&gt; pool = connectionPool;</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">        return pool == null ? 0 : pool.getNumActive();</span>
    }

    /**
     * [Read Only] The current number of idle connections that are waiting to be allocated from this data source.
     *
     * @return the current number of idle connections
     */
    @Override
    public int getNumIdle() {
        // Copy reference to avoid NPE if close happens after null check
<span class="fc" id="L1194">        final GenericObjectPool&lt;PoolableConnection&gt; pool = connectionPool;</span>
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        return pool == null ? 0 : pool.getNumIdle();</span>
    }

    /**
     * Gets the value of the {code numTestsPerEvictionRun} property.
     *
     * @return the number of objects to examine during idle object evictor runs
     * @see #setNumTestsPerEvictionRun(int)
     */
    @Override
    public synchronized int getNumTestsPerEvictionRun() {
<span class="fc" id="L1206">        return this.numTestsPerEvictionRun;</span>
    }

    @Override
    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
<span class="nc" id="L1211">        throw new SQLFeatureNotSupportedException();</span>
    }

    /**
     * Gets the password passed to the JDBC driver to establish connections.
     *
     * @return the connection password
     * @deprecated Exposing passwords via JMX is an Information Exposure issue.
     */
    @Deprecated
    @Override
    public String getPassword() {
<span class="fc" id="L1223">        return this.password;</span>
    }

    /**
     * Gets the registered JMX ObjectName.
     *
     * @return the registered JMX ObjectName.
     */
    protected ObjectName getRegisteredJmxName() {
<span class="fc" id="L1232">        return ObjectNameWrapper.unwrap(registeredJmxObjectName);</span>
    }

    /**
     * Flag to remove abandoned connections if they exceed the removeAbandonedTimeout when borrowObject is invoked.
     * &lt;p&gt;
     * The default value is false.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If set to true a connection is considered abandoned and eligible for removal if it has not been used for more
     * than {@link #getRemoveAbandonedTimeoutDuration() removeAbandonedTimeout} seconds.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Abandoned connections are identified and removed when {@link #getConnection()} is invoked and all of the
     * following conditions hold:
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link #getRemoveAbandonedOnBorrow()}&lt;/li&gt;
     * &lt;li&gt;{@link #getNumActive()} &amp;gt; {@link #getMaxTotal()} - 3&lt;/li&gt;
     * &lt;li&gt;{@link #getNumIdle()} &amp;lt; 2&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @see #getRemoveAbandonedTimeoutDuration()
     */
    @Override
    public boolean getRemoveAbandonedOnBorrow() {
<span class="pc bpc" id="L1258" title="2 of 4 branches missed.">        return abandonedConfig != null &amp;&amp; abandonedConfig.getRemoveAbandonedOnBorrow();</span>
    }

    /**
     * Flag to remove abandoned connections if they exceed the removeAbandonedTimeout during pool maintenance.
     * &lt;p&gt;
     * The default value is false.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If set to true a connection is considered abandoned and eligible for removal if it has not been used for more
     * than {@link #getRemoveAbandonedTimeoutDuration() removeAbandonedTimeout} seconds.
     * &lt;/p&gt;
     *
     * @see #getRemoveAbandonedTimeoutDuration()
     */
    @Override
    public boolean getRemoveAbandonedOnMaintenance() {
<span class="pc bpc" id="L1275" title="2 of 4 branches missed.">        return abandonedConfig != null &amp;&amp; abandonedConfig.getRemoveAbandonedOnMaintenance();</span>
    }

    /**
     * Gets the timeout in seconds before an abandoned connection can be removed.
     * &lt;p&gt;
     * Creating a Statement, PreparedStatement or CallableStatement or using one of these to execute a query (using one
     * of the execute methods) resets the lastUsed property of the parent connection.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Abandoned connection cleanup happens when:
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link #getRemoveAbandonedOnBorrow()} or {@link #getRemoveAbandonedOnMaintenance()} = true&lt;/li&gt;
     * &lt;li&gt;{@link #getNumIdle() numIdle} &amp;lt; 2&lt;/li&gt;
     * &lt;li&gt;{@link #getNumActive() numActive} &amp;gt; {@link #getMaxTotal() maxTotal} - 3&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default value is 300 seconds.
     * &lt;/p&gt;
     * @deprecated Use {@link #getRemoveAbandonedTimeoutDuration()}.
     */
    @Deprecated
    @Override
    public int getRemoveAbandonedTimeout() {
<span class="fc" id="L1300">        return (int) getRemoveAbandonedTimeoutDuration().getSeconds();</span>
    }

    /**
     * Gets the timeout before an abandoned connection can be removed.
     * &lt;p&gt;
     * Creating a Statement, PreparedStatement or CallableStatement or using one of these to execute a query (using one
     * of the execute methods) resets the lastUsed property of the parent connection.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Abandoned connection cleanup happens when:
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link #getRemoveAbandonedOnBorrow()} or {@link #getRemoveAbandonedOnMaintenance()} = true&lt;/li&gt;
     * &lt;li&gt;{@link #getNumIdle() numIdle} &amp;lt; 2&lt;/li&gt;
     * &lt;li&gt;{@link #getNumActive() numActive} &amp;gt; {@link #getMaxTotal() maxTotal} - 3&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default value is 300 seconds.
     * &lt;/p&gt;
     * @return Timeout before an abandoned connection can be removed.
     * @since 2.10.0
     */
    public Duration getRemoveAbandonedTimeoutDuration() {
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">        return abandonedConfig == null ? Duration.ofSeconds(300) : abandonedConfig.getRemoveAbandonedTimeoutDuration();</span>
    }

    /**
     * Gets the current value of the flag that controls whether a connection will be rolled back when it is returned to
     * the pool if auto commit is not enabled and the connection is not read only.
     *
     * @return whether a connection will be rolled back when it is returned to the pool.
     */
    public boolean getRollbackOnReturn() {
<span class="fc" id="L1334">        return rollbackOnReturn;</span>
    }

    /**
     * Gets the minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by
     * the idle object evictor, with the extra condition that at least &quot;minIdle&quot; connections remain in the pool.
     * &lt;p&gt;
     * When {@link #getMinEvictableIdleTimeMillis() minEvictableIdleTimeMillis} is set to a positive value,
     * minEvictableIdleTimeMillis is examined first by the idle connection evictor - i.e. when idle connections are
     * visited by the evictor, idle time is first compared against {@code minEvictableIdleTimeMillis} (without
     * considering the number of idle connections in the pool) and then against {@code softMinEvictableIdleTimeMillis},
     * including the {@code minIdle}, constraint.
     * &lt;/p&gt;
     *
     * @return minimum amount of time a connection may sit idle in the pool before it is eligible for eviction, assuming
     *         there are minIdle idle connections in the pool
     * @since 2.10.0
     */
    public synchronized Duration getSoftMinEvictableIdleDuration() {
<span class="fc" id="L1353">        return softMinEvictableIdleDuration;</span>
    }

    /**
     * Gets the minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by
     * the idle object evictor, with the extra condition that at least &quot;minIdle&quot; connections remain in the pool.
     * &lt;p&gt;
     * When {@link #getMinEvictableIdleTimeMillis() minEvictableIdleTimeMillis} is set to a positive value,
     * minEvictableIdleTimeMillis is examined first by the idle connection evictor - i.e. when idle connections are
     * visited by the evictor, idle time is first compared against {@code minEvictableIdleTimeMillis} (without
     * considering the number of idle connections in the pool) and then against {@code softMinEvictableIdleTimeMillis},
     * including the {@code minIdle}, constraint.
     * &lt;/p&gt;
     *
     * @return minimum amount of time a connection may sit idle in the pool before it is eligible for eviction, assuming
     *         there are minIdle idle connections in the pool
     * @deprecated Use {@link #getSoftMinEvictableIdleDuration()}.
     */
    @Deprecated
    @Override
    public synchronized long getSoftMinEvictableIdleTimeMillis() {
<span class="fc" id="L1374">        return softMinEvictableIdleDuration.toMillis();</span>
    }

    /**
     * Gets the {code testOnBorrow} property.
     *
     * @return true if objects are validated before being borrowed from the pool
     *
     * @see #setTestOnBorrow(boolean)
     */
    @Override
    public synchronized boolean getTestOnBorrow() {
<span class="fc" id="L1386">        return this.testOnBorrow;</span>
    }

    /**
     * Gets the {code testOnCreate} property.
     *
     * @return true if objects are validated immediately after they are created by the pool
     * @see #setTestOnCreate(boolean)
     */
    @Override
    public synchronized boolean getTestOnCreate() {
<span class="nc" id="L1397">        return this.testOnCreate;</span>
    }

    /**
     * Gets the value of the {code testOnReturn} property.
     *
     * @return true if objects are validated before being returned to the pool
     * @see #setTestOnReturn(boolean)
     */
    public synchronized boolean getTestOnReturn() {
<span class="fc" id="L1407">        return this.testOnReturn;</span>
    }

    /**
     * Gets the value of the {code testWhileIdle} property.
     *
     * @return true if objects examined by the idle object evictor are validated
     * @see #setTestWhileIdle(boolean)
     */
    @Override
    public synchronized boolean getTestWhileIdle() {
<span class="fc" id="L1418">        return this.testWhileIdle;</span>
    }

    /**
     * Gets the value of the {code durationBetweenEvictionRuns} property.
     *
     * @return the time (in milliseconds) between evictor runs
     * @see #setDurationBetweenEvictionRuns(Duration)
     * @deprecated Use {@link #getDurationBetweenEvictionRuns()}.
     */
    @Deprecated
    @Override
    public synchronized long getTimeBetweenEvictionRunsMillis() {
<span class="fc" id="L1431">        return this.durationBetweenEvictionRuns.toMillis();</span>
    }

    /**
     * Gets the JDBC connection {code connectionString} property.
     *
     * @return the {code connectionString} passed to the JDBC driver to establish connections
     */
    @Override
    public synchronized String getUrl() {
<span class="fc" id="L1441">        return this.connectionString;</span>
    }

    /**
     * Gets the JDBC connection {code userName} property.
     *
     * @return the {code userName} passed to the JDBC driver to establish connections
     * @deprecated
     */
    @Deprecated
    @Override
    public String getUsername() {
<span class="fc" id="L1453">        return this.userName;</span>
    }

    /**
     * Gets the validation query used to validate connections before returning them.
     *
     * @return the SQL validation query
     * @see #setValidationQuery(String)
     */
    @Override
    public String getValidationQuery() {
<span class="fc" id="L1464">        return this.validationQuery;</span>
    }

    /**
     * Gets the validation query timeout.
     *
     * @return the timeout in seconds before connection validation queries fail.
     * @deprecated Use {@link #getValidationQueryTimeoutDuration()}.
     */
    @Deprecated
    @Override
    public int getValidationQueryTimeout() {
<span class="fc" id="L1476">        return (int) validationQueryTimeoutDuration.getSeconds();</span>
    }

    /**
     * Gets the validation query timeout.
     *
     * @return the timeout in seconds before connection validation queries fail.
     */
    public Duration getValidationQueryTimeoutDuration() {
<span class="fc" id="L1485">        return validationQueryTimeoutDuration;</span>
    }

    /**
     * Manually invalidates a connection, effectively requesting the pool to try to close it, remove it from the pool
     * and reclaim pool capacity.
     *
     * @param connection The Connection to invalidate.
     *
     * @throws IllegalStateException if invalidating the connection failed.
     * @since 2.1
     */
    @SuppressWarnings(&quot;resource&quot;)
    public void invalidateConnection(final Connection connection) throws IllegalStateException {
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">        if (connection == null) {</span>
<span class="nc" id="L1500">            return;</span>
        }
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">        if (connectionPool == null) {</span>
<span class="nc" id="L1503">            throw new IllegalStateException(&quot;Cannot invalidate connection: ConnectionPool is null.&quot;);</span>
        }

        final PoolableConnection poolableConnection;
        try {
<span class="fc" id="L1508">            poolableConnection = connection.unwrap(PoolableConnection.class);</span>
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">            if (poolableConnection == null) {</span>
<span class="nc" id="L1510">                throw new IllegalStateException(</span>
                        &quot;Cannot invalidate connection: Connection is not a poolable connection.&quot;);
            }
<span class="nc" id="L1513">        } catch (final SQLException e) {</span>
<span class="nc" id="L1514">            throw new IllegalStateException(&quot;Cannot invalidate connection: Unwrapping poolable connection failed.&quot;, e);</span>
<span class="fc" id="L1515">        }</span>

        try {
<span class="fc" id="L1518">            connectionPool.invalidateObject(poolableConnection);</span>
<span class="nc" id="L1519">        } catch (final Exception e) {</span>
<span class="nc" id="L1520">            throw new IllegalStateException(&quot;Invalidating connection threw unexpected exception&quot;, e);</span>
<span class="fc" id="L1521">        }</span>
<span class="fc" id="L1522">    }</span>

    /**
     * Gets the value of the accessToUnderlyingConnectionAllowed property.
     *
     * @return true if access to the underlying connection is allowed, false otherwise.
     */
    @Override
    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
<span class="fc" id="L1531">        return this.accessToUnderlyingConnectionAllowed;</span>
    }

    /**
     * Returns true if the statement pool is cleared when the connection is returned to its pool.
     *
     * @return true if the statement pool is cleared at connection return
     * @since 2.8.0
     */
    @Override
    public boolean isClearStatementPoolOnReturn() {
<span class="fc" id="L1542">        return clearStatementPoolOnReturn;</span>
    }

    /**
     * If true, this data source is closed and no more connections can be retrieved from this data source.
     *
     * @return true, if the data source is closed; false otherwise
     */
    @Override
    public synchronized boolean isClosed() {
<span class="nc" id="L1552">        return closed;</span>
    }

    /**
     * Delegates in a null-safe manner to {@link String#isEmpty()}.
     *
     * @param value the string to test, may be null.
     * @return boolean false if value is null, otherwise {@link String#isEmpty()}.
     */
    private boolean isEmpty(final String value) {
<span class="fc bfc" id="L1562" title="All 4 branches covered.">        return value == null || value.trim().isEmpty();</span>
    }

    /**
     * Returns true if we are pooling statements.
     *
     * @return true if prepared and callable statements are pooled
     */
    @Override
    public synchronized boolean isPoolPreparedStatements() {
<span class="fc" id="L1572">        return this.poolPreparedStatements;</span>
    }

    @Override
    public boolean isWrapperFor(final Class&lt;?&gt; iface) throws SQLException {
<span class="fc bfc" id="L1577" title="All 4 branches covered.">        return iface != null &amp;&amp; iface.isInstance(this);</span>
    }

    private void jmxRegister() {
        // Return immediately if this DataSource has already been registered
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">        if (registeredJmxObjectName != null) {</span>
<span class="nc" id="L1583">            return;</span>
        }
        // Return immediately if no JMX name has been specified
<span class="fc" id="L1586">        final String requestedName = getJmxName();</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">        if (requestedName == null) {</span>
<span class="fc" id="L1588">            return;</span>
        }
<span class="fc" id="L1590">        registeredJmxObjectName = registerJmxObjectName(requestedName, null);</span>
        try {
<span class="fc" id="L1592">            final StandardMBean standardMBean = new StandardMBean(this, DataSourceMXBean.class);</span>
<span class="fc" id="L1593">            registeredJmxObjectName.registerMBean(standardMBean);</span>
<span class="nc" id="L1594">        } catch (final NotCompliantMBeanException e) {</span>
<span class="nc" id="L1595">            log.warn(&quot;The requested JMX name [&quot; + requestedName + &quot;] was not valid and will be ignored.&quot;);</span>
<span class="fc" id="L1596">        }</span>
<span class="fc" id="L1597">    }</span>

    /**
     * Logs the given message.
     *
     * @param message the message to log.
     */
    protected void log(final String message) {
<span class="pc bpc" id="L1605" title="1 of 2 branches missed.">        if (logWriter != null) {</span>
<span class="fc" id="L1606">            logWriter.println(message);</span>
        }
<span class="fc" id="L1608">    }</span>

    /**
     * Logs the given throwable.
     * @param message TODO
     * @param throwable the throwable.
     *
     * @since 2.7.0
     */
    protected void log(final String message, final Throwable throwable) {
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        if (logWriter != null) {</span>
<span class="nc" id="L1619">            logWriter.println(message);</span>
<span class="nc" id="L1620">            throwable.printStackTrace(logWriter);</span>
        }
<span class="nc" id="L1622">    }</span>

    @Override
    public void postDeregister() {
        // NO-OP
<span class="nc" id="L1627">    }</span>

    @Override
    public void postRegister(final Boolean registrationDone) {
        // NO-OP
<span class="nc" id="L1632">    }</span>

    @Override
    public void preDeregister() throws Exception {
        // NO-OP
<span class="nc" id="L1637">    }</span>

    @Override
    public ObjectName preRegister(final MBeanServer server, final ObjectName objectName) {
<span class="nc" id="L1641">        registeredJmxObjectName = registerJmxObjectName(getJmxName(), objectName);</span>
<span class="nc" id="L1642">        return ObjectNameWrapper.unwrap(registeredJmxObjectName);</span>
    }

    private ObjectNameWrapper registerJmxObjectName(final String requestedName, final ObjectName objectName) {
<span class="fc" id="L1646">        ObjectNameWrapper objectNameWrapper = null;</span>
<span class="pc bpc" id="L1647" title="1 of 2 branches missed.">        if (requestedName != null) {</span>
            try {
<span class="fc" id="L1649">                objectNameWrapper = ObjectNameWrapper.wrap(requestedName);</span>
<span class="nc" id="L1650">            } catch (final MalformedObjectNameException e) {</span>
<span class="nc" id="L1651">                log.warn(&quot;The requested JMX name '&quot; + requestedName + &quot;' was not valid and will be ignored.&quot;);</span>
<span class="fc" id="L1652">            }</span>
        }
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">        if (objectNameWrapper == null) {</span>
<span class="nc" id="L1655">            objectNameWrapper = ObjectNameWrapper.wrap(objectName);</span>
        }
<span class="fc" id="L1657">        return objectNameWrapper;</span>
    }

    /**
     * Removes a custom connection property.
     *
     * @param name Name of the custom connection property to remove
     * @see #addConnectionProperty(String, String)
     */
    public void removeConnectionProperty(final String name) {
<span class="nc" id="L1667">        connectionProperties.remove(name);</span>
<span class="nc" id="L1668">    }</span>

    /**
     * Restarts the datasource.
     * &lt;p&gt;
     * This method calls {@link #close()} and {@link #start()} in sequence within synchronized scope so any
     * connection requests that come in while the datasource is shutting down will be served by the new pool.
     * &lt;p&gt;
     * Idle connections that are stored in the connection pool when this method is invoked are closed, but
     * connections that are checked out to clients when this method is invoked are not affected. When client
     * applications subsequently invoke {@link Connection#close()} to return these connections to the pool, the
     * underlying JDBC connections are closed. These connections do not count in {@link #getMaxTotal()} or
     * {@link #getNumActive()} after invoking this method. For example, if there are 3 connections checked out by
     * clients when {@link #restart()} is invoked, after this method is called, {@link #getNumActive()} will
     * return 0 and up to {@link #getMaxTotal()} + 3 connections may be open until the connections sourced from
     * the original pool are returned.
     * &lt;p&gt;
     * The new connection pool created by this method is initialized with currently set configuration properties.
     *
     * @throws SQLException if an error occurs initializing the datasource
     */
    @Override
    public synchronized void restart() throws SQLException {
<span class="fc" id="L1691">        close();</span>
<span class="fc" id="L1692">        start();</span>
<span class="fc" id="L1693">    }</span>

    private &lt;T&gt; void setAbandoned(final BiConsumer&lt;AbandonedConfig, T&gt; consumer, final T object) {
<span class="fc bfc" id="L1696" title="All 2 branches covered.">        if (abandonedConfig == null) {</span>
<span class="fc" id="L1697">            abandonedConfig = new AbandonedConfig();</span>
        }
<span class="fc" id="L1699">        consumer.accept(abandonedConfig, object);</span>
<span class="fc" id="L1700">        final GenericObjectPool&lt;?&gt; gop = this.connectionPool;</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">        if (gop != null) {</span>
<span class="fc" id="L1702">            gop.setAbandonedConfig(abandonedConfig);</span>
        }
<span class="fc" id="L1704">    }</span>

    /**
     * Sets the print writer to be used by this configuration to log information on abandoned objects.
     *
     * @param logWriter The new log writer
     */
    public void setAbandonedLogWriter(final PrintWriter logWriter) {
<span class="fc" id="L1712">        setAbandoned(AbandonedConfig::setLogWriter, logWriter);</span>
<span class="fc" id="L1713">    }</span>

    /**
     * If the connection pool implements {@link org.apache.commons.pool2.UsageTracking UsageTracking}, configure whether
     * the connection pool should record a stack trace every time a method is called on a pooled connection and retain
     * the most recent stack trace to aid debugging of abandoned connections.
     *
     * @param usageTracking A value of {@code true} will enable the recording of a stack trace on every use of a
     *                      pooled connection
     */
    public void setAbandonedUsageTracking(final boolean usageTracking) {
<span class="fc" id="L1724">        setAbandoned(AbandonedConfig::setUseUsageTracking, usageTracking);</span>
<span class="fc" id="L1725">    }</span>

    /**
     * Sets the value of the accessToUnderlyingConnectionAllowed property. It controls if the PoolGuard allows access to
     * the underlying connection. (Default: false)
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param allow Access to the underlying connection is granted when true.
     */
    public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
<span class="fc" id="L1739">        this.accessToUnderlyingConnectionAllowed = allow;</span>
<span class="fc" id="L1740">    }</span>

    /**
     * Sets the value of the flag that controls whether or not connections being returned to the pool will be checked
     * and configured with {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)} if the auto commit
     * setting is {@code false} when the connection is returned. It is {@code true} by default.
     *
     * @param autoCommitOnReturn Whether or not connections being returned to the pool will be checked and configured
     *                           with auto-commit.
     * @since 2.6.0
     */
    public void setAutoCommitOnReturn(final boolean autoCommitOnReturn) {
<span class="nc" id="L1752">        this.autoCommitOnReturn = autoCommitOnReturn;</span>
<span class="nc" id="L1753">    }</span>

    /**
     * Sets the state caching flag.
     *
     * @param cacheState The new value for the state caching flag
     */
    public void setCacheState(final boolean cacheState) {
<span class="nc" id="L1761">        this.cacheState = cacheState;</span>
<span class="nc" id="L1762">    }</span>

    /**
     * Sets whether the pool of statements (which was enabled with {@link #setPoolPreparedStatements(boolean)}) should
     * be cleared when the connection is returned to its pool. Default is false.
     *
     * @param clearStatementPoolOnReturn clear or not
     * @since 2.8.0
     */
    public void setClearStatementPoolOnReturn(final boolean clearStatementPoolOnReturn) {
<span class="fc" id="L1772">        this.clearStatementPoolOnReturn = clearStatementPoolOnReturn;</span>
<span class="fc" id="L1773">    }</span>

    /**
     * Sets the ConnectionFactory class name.
     *
     * @param connectionFactoryClassName A class name.
     * @since 2.7.0
     */
    public void setConnectionFactoryClassName(final String connectionFactoryClassName) {
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">        this.connectionFactoryClassName = isEmpty(connectionFactoryClassName) ? null : connectionFactoryClassName;</span>
<span class="fc" id="L1783">    }</span>

    /**
     * Sets the collection of SQL statements to be executed when a physical connection is first created.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param connectionInitSqls Collection of SQL statements to execute on connection creation
     */
    public void setConnectionInitSqls(final Collection&lt;String&gt; connectionInitSqls) {
<span class="fc bfc" id="L1796" title="All 2 branches covered.">        final List&lt;String&gt; collect = Utils.isEmpty(connectionInitSqls) ? null</span>
<span class="fc bfc" id="L1797" title="All 2 branches covered.">                : connectionInitSqls.stream().filter(s -&gt; !isEmpty(s)).collect(Collectors.toList());</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">        this.connectionInitSqls = Utils.isEmpty(collect) ? null : collect;</span>
<span class="fc" id="L1799">    }</span>

    /**
     * Sets the list of SQL statements to be executed when a physical connection is first created.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param connectionInitSqls List of SQL statements to execute on connection creation
     * @since 2.12.0
     */
    public void setConnectionInitSqls(final List&lt;String&gt; connectionInitSqls) {
<span class="fc" id="L1813">        setConnectionInitSqls((Collection&lt;String&gt;) connectionInitSqls);</span>
<span class="fc" id="L1814">    }</span>

    private &lt;T&gt; void setConnectionPool(final BiConsumer&lt;GenericObjectPool&lt;PoolableConnection&gt;, T&gt; consumer, final T object) {
<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">        if (connectionPool != null) {</span>
<span class="nc" id="L1818">            consumer.accept(connectionPool, object);</span>
        }
<span class="fc" id="L1820">    }</span>

    /**
     * Sets the connection properties passed to driver.connect(...).
     * &lt;p&gt;
     * Format of the string must be [propertyName=property;]*
     * &lt;/p&gt;
     * &lt;p&gt;
     * NOTE - The &quot;user&quot; and &quot;password&quot; properties will be added explicitly, so they do not need to be included here.
     * &lt;/p&gt;
     *
     * @param connectionProperties the connection properties used to create new connections
     */
    public void setConnectionProperties(final String connectionProperties) {
<span class="fc" id="L1834">        Objects.requireNonNull(connectionProperties, &quot;connectionProperties&quot;);</span>
<span class="fc" id="L1835">        final String[] entries = connectionProperties.split(&quot;;&quot;);</span>
<span class="fc" id="L1836">        final Properties properties = new Properties();</span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        Stream.of(entries).filter(e -&gt; !e.isEmpty()).forEach(entry -&gt; {</span>
<span class="fc" id="L1838">            final int index = entry.indexOf('=');</span>
<span class="fc bfc" id="L1839" title="All 2 branches covered.">            if (index &gt; 0) {</span>
<span class="fc" id="L1840">                final String name = entry.substring(0, index);</span>
<span class="fc" id="L1841">                final String value = entry.substring(index + 1);</span>
<span class="fc" id="L1842">                properties.setProperty(name, value);</span>
<span class="fc" id="L1843">            } else {</span>
                // no value is empty string which is how
                // java.util.Properties works
<span class="fc" id="L1846">                properties.setProperty(entry, &quot;&quot;);</span>
            }
<span class="fc" id="L1848">        });</span>
<span class="fc" id="L1849">        this.connectionProperties = properties;</span>
<span class="fc" id="L1850">    }</span>

    /**
     * Sets default auto-commit state of connections returned by this datasource.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param defaultAutoCommit default auto-commit value
     */
    public void setDefaultAutoCommit(final Boolean defaultAutoCommit) {
<span class="fc" id="L1863">        this.defaultAutoCommit = defaultAutoCommit;</span>
<span class="fc" id="L1864">    }</span>

    /**
     * Sets the default catalog.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param defaultCatalog the default catalog
     */
    public void setDefaultCatalog(final String defaultCatalog) {
<span class="pc bpc" id="L1877" title="1 of 2 branches missed.">        this.defaultCatalog = isEmpty(defaultCatalog) ? null : defaultCatalog;</span>
<span class="fc" id="L1878">    }</span>

    /**
     * Sets the default query timeout that will be used for {@link java.sql.Statement Statement}s created from this
     * connection. {@code null} means that the driver default will be used.
     *
     * @param defaultQueryTimeoutDuration The default query timeout Duration.
     * @since 2.10.0
     */
    public void setDefaultQueryTimeout(final Duration defaultQueryTimeoutDuration) {
<span class="nc" id="L1888">        this.defaultQueryTimeoutDuration = defaultQueryTimeoutDuration;</span>
<span class="nc" id="L1889">    }</span>

    /**
     * Sets the default query timeout that will be used for {@link java.sql.Statement Statement}s created from this
     * connection. {@code null} means that the driver default will be used.
     *
     * @param defaultQueryTimeoutSeconds The default query timeout in seconds.
     * @deprecated Use {@link #setDefaultQueryTimeout(Duration)}.
     */
    @Deprecated
    public void setDefaultQueryTimeout(final Integer defaultQueryTimeoutSeconds) {
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">        this.defaultQueryTimeoutDuration = defaultQueryTimeoutSeconds == null ? null : Duration.ofSeconds(defaultQueryTimeoutSeconds);</span>
<span class="fc" id="L1901">    }</span>

    /**
     * Sets defaultReadonly property.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param defaultReadOnly default read-only value
     */
    public void setDefaultReadOnly(final Boolean defaultReadOnly) {
<span class="fc" id="L1914">        this.defaultReadOnly = defaultReadOnly;</span>
<span class="fc" id="L1915">    }</span>

    /**
     * Sets the default schema.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param defaultSchema the default catalog
     * @since 2.5.0
     */
    public void setDefaultSchema(final String defaultSchema) {
<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">        this.defaultSchema = isEmpty(defaultSchema) ? null : defaultSchema;</span>
<span class="fc" id="L1930">    }</span>

    /**
     * Sets the default transaction isolation state for returned connections.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param defaultTransactionIsolation the default transaction isolation state
     * @see Connection#getTransactionIsolation
     */
    public void setDefaultTransactionIsolation(final int defaultTransactionIsolation) {
<span class="fc" id="L1944">        this.defaultTransactionIsolation = defaultTransactionIsolation;</span>
<span class="fc" id="L1945">    }</span>

    /**
     * Sets the SQL_STATE codes considered to signal fatal conditions.
     * &lt;p&gt;
     * Overrides the defaults in {@link Utils#getDisconnectionSqlCodes()} (plus anything starting with
     * {@link Utils#DISCONNECTION_SQL_CODE_PREFIX}). If this property is non-null and {@link #getFastFailValidation()}
     * is {@code true}, whenever connections created by this datasource generate exceptions with SQL_STATE codes in this
     * list, they will be marked as &quot;fatally disconnected&quot; and subsequent validations will fail fast (no attempt at
     * isValid or validation query).
     * &lt;/p&gt;
     * &lt;p&gt;
     * If {@link #getFastFailValidation()} is {@code false} setting this property has no effect.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: {@code getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter}.
     * &lt;/p&gt;
     *
     * @param disconnectionSqlCodes SQL_STATE codes considered to signal fatal conditions
     * @since 2.1
     */
    public void setDisconnectionSqlCodes(final Collection&lt;String&gt; disconnectionSqlCodes) {
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">        final Set&lt;String&gt; collect = Utils.isEmpty(disconnectionSqlCodes) ? null</span>
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">                : disconnectionSqlCodes.stream().filter(s -&gt; !isEmpty(s)).collect(Collectors.toSet());</span>
<span class="pc bpc" id="L1971" title="1 of 2 branches missed.">        this.disconnectionSqlCodes = Utils.isEmpty(collect) ? null : collect;</span>
<span class="fc" id="L1972">    }</span>

    /**
     * Sets the JDBC Driver instance to use for this pool.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param driver The JDBC Driver instance to use for this pool.
     */
    public synchronized void setDriver(final Driver driver) {
<span class="nc" id="L1985">        this.driver = driver;</span>
<span class="nc" id="L1986">    }</span>

    /**
     * Sets the class loader to be used to load the JDBC driver.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param driverClassLoader the class loader with which to load the JDBC driver
     */
    public synchronized void setDriverClassLoader(final ClassLoader driverClassLoader) {
<span class="fc" id="L1999">        this.driverClassLoader = driverClassLoader;</span>
<span class="fc" id="L2000">    }</span>

    /**
     * Sets the JDBC driver class name.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param driverClassName the class name of the JDBC driver
     */
    public synchronized void setDriverClassName(final String driverClassName) {
<span class="fc bfc" id="L2013" title="All 2 branches covered.">        this.driverClassName = isEmpty(driverClassName) ? null : driverClassName;</span>
<span class="fc" id="L2014">    }</span>

    /**
     * Sets the {code durationBetweenEvictionRuns} property.
     *
     * @param timeBetweenEvictionRunsMillis the new time between evictor runs
     * @see #setDurationBetweenEvictionRuns(Duration)
     * @since 2.10.0
     */
    public synchronized void setDurationBetweenEvictionRuns(final Duration timeBetweenEvictionRunsMillis) {
<span class="fc" id="L2024">        this.durationBetweenEvictionRuns = timeBetweenEvictionRunsMillis;</span>
<span class="fc" id="L2025">        setConnectionPool(GenericObjectPool::setDurationBetweenEvictionRuns, timeBetweenEvictionRunsMillis);</span>
<span class="fc" id="L2026">    }</span>

    /**
     * Sets the value of the flag that controls whether or not connections being returned to the pool will be checked
     * and configured with {@link Connection#setAutoCommit(boolean) Connection.setAutoCommit(true)} if the auto commit
     * setting is {@code false} when the connection is returned. It is {@code true} by default.
     *
     * @param autoCommitOnReturn Whether or not connections being returned to the pool will be checked and configured
     *                           with auto-commit.
     * @deprecated Use {@link #setAutoCommitOnReturn(boolean)}.
     */
    @Deprecated
    public void setEnableAutoCommitOnReturn(final boolean autoCommitOnReturn) {
<span class="nc" id="L2039">        this.autoCommitOnReturn = autoCommitOnReturn;</span>
<span class="nc" id="L2040">    }</span>

    /**
     * Sets the EvictionPolicy implementation to use with this connection pool.
     *
     * @param evictionPolicyClassName The fully qualified class name of the EvictionPolicy implementation
     */
    public synchronized void setEvictionPolicyClassName(final String evictionPolicyClassName) {
<span class="nc" id="L2048">        setConnectionPool(GenericObjectPool::setEvictionPolicyClassName, evictionPolicyClassName);</span>
<span class="nc" id="L2049">        this.evictionPolicyClassName = evictionPolicyClassName;</span>
<span class="nc" id="L2050">    }</span>

    /**
     * @see #getFastFailValidation()
     * @param fastFailValidation true means connections created by this factory will fast fail validation
     * @since 2.1
     */
    public void setFastFailValidation(final boolean fastFailValidation) {
<span class="fc" id="L2058">        this.fastFailValidation = fastFailValidation;</span>
<span class="fc" id="L2059">    }</span>

    /**
     * Sets the initial size of the connection pool.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param initialSize the number of connections created when the pool is initialized
     */
    public synchronized void setInitialSize(final int initialSize) {
<span class="fc" id="L2072">        this.initialSize = initialSize;</span>
<span class="fc" id="L2073">    }</span>

    /**
     * Sets the JMX name that has been requested for this DataSource. If the requested name is not valid, an alternative
     * may be chosen. This DataSource will attempt to register itself using this name. If another component registers
     * this DataSource with JMX and this name is valid this name will be used in preference to any specified by the
     * other component.
     *
     * @param jmxName The JMX name that has been requested for this DataSource
     */
    public void setJmxName(final String jmxName) {
<span class="fc" id="L2084">        this.jmxName = jmxName;</span>
<span class="fc" id="L2085">    }</span>

    /**
     * Sets the LIFO property. True means the pool behaves as a LIFO queue; false means FIFO.
     *
     * @param lifo the new value for the LIFO property
     */
    public synchronized void setLifo(final boolean lifo) {
<span class="fc" id="L2093">        this.lifo = lifo;</span>
<span class="fc" id="L2094">        setConnectionPool(GenericObjectPool::setLifo, lifo);</span>
<span class="fc" id="L2095">    }</span>

    /**
     * @param logAbandoned new logAbandoned property value
     */
    public void setLogAbandoned(final boolean logAbandoned) {
<span class="fc" id="L2101">        setAbandoned(AbandonedConfig::setLogAbandoned, logAbandoned);</span>
<span class="fc" id="L2102">    }</span>

    /**
     * When {@link #getMaxConnDuration()} is set to limit connection lifetime, this property determines whether or
     * not log messages are generated when the pool closes connections due to maximum lifetime exceeded. Set this
     * property to false to suppress log messages when connections expire.
     *
     * @param logExpiredConnections Whether or not log messages are generated when the pool closes connections due to
     *                              maximum lifetime exceeded.
     */
    public void setLogExpiredConnections(final boolean logExpiredConnections) {
<span class="fc" id="L2113">        this.logExpiredConnections = logExpiredConnections;</span>
<span class="fc" id="L2114">    }</span>

    /**
     * &lt;strong&gt;BasicDataSource does NOT support this method. &lt;/strong&gt;
     *
     * &lt;p&gt;
     * Sets the login timeout (in seconds) for connecting to the database.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
     * &lt;/p&gt;
     *
     * @param loginTimeout The new login timeout, or zero for no timeout
     * @throws UnsupportedOperationException If the DataSource implementation does not support the login timeout
     *                                       feature.
     * @throws SQLException                  if a database access error occurs
     */
    @Override
    public void setLoginTimeout(final int loginTimeout) throws SQLException {
        // This method isn't supported by the PoolingDataSource returned by the
        // createDataSource
<span class="nc" id="L2135">        throw new UnsupportedOperationException(&quot;Not supported by BasicDataSource&quot;);</span>
    }

    /**
     * Sets the log writer being used by this data source.
     * &lt;p&gt;
     * Calls {@link #createDataSource()}, so has the side effect of initializing the connection pool.
     * &lt;/p&gt;
     *
     * @param logWriter The new log writer
     * @throws SQLException if a database access error occurs
     */
    @Override
    public void setLogWriter(final PrintWriter logWriter) throws SQLException {
<span class="nc" id="L2149">        createDataSource().setLogWriter(logWriter);</span>
<span class="nc" id="L2150">        this.logWriter = logWriter;</span>
<span class="nc" id="L2151">    }</span>

    /**
     * Sets the maximum permitted lifetime of a connection. A value of zero or less indicates an
     * infinite lifetime.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param maxConnDuration The maximum permitted lifetime of a connection.
     * @since 2.10.0
     */
    public void setMaxConn(final Duration maxConnDuration) {
<span class="fc" id="L2166">        this.maxConnDuration = maxConnDuration;</span>
<span class="fc" id="L2167">    }</span>

    /**
     * Sets the maximum permitted lifetime of a connection in milliseconds. A value of zero or less indicates an
     * infinite lifetime.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param maxConnLifetimeMillis The maximum permitted lifetime of a connection in milliseconds.
     * @deprecated Use {@link #setMaxConn(Duration)}.
     */
    @Deprecated
    public void setMaxConnLifetimeMillis(final long maxConnLifetimeMillis) {
<span class="fc" id="L2183">        this.maxConnDuration = Duration.ofMillis(maxConnLifetimeMillis);</span>
<span class="fc" id="L2184">    }</span>

    /**
     * Sets the maximum number of connections that can remain idle in the pool. Excess idle connections are destroyed on
     * return to the pool.
     *
     * @see #getMaxIdle()
     * @param maxIdle the new value for maxIdle
     */
    public synchronized void setMaxIdle(final int maxIdle) {
<span class="fc" id="L2194">        this.maxIdle = maxIdle;</span>
<span class="fc" id="L2195">        setConnectionPool(GenericObjectPool::setMaxIdle, maxIdle);</span>
<span class="fc" id="L2196">    }</span>

    /**
     * Sets the value of the {@code maxOpenPreparedStatements} property.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param maxOpenStatements the new maximum number of prepared statements
     */
    public synchronized void setMaxOpenPreparedStatements(final int maxOpenStatements) {
<span class="fc" id="L2209">        this.maxOpenPreparedStatements = maxOpenStatements;</span>
<span class="fc" id="L2210">    }</span>

    /**
     * Sets the maximum total number of idle and borrows connections that can be active at the same time. Use a negative
     * value for no limit.
     *
     * @param maxTotal the new value for maxTotal
     * @see #getMaxTotal()
     */
    public synchronized void setMaxTotal(final int maxTotal) {
<span class="fc" id="L2220">        this.maxTotal = maxTotal;</span>
<span class="fc" id="L2221">        setConnectionPool(GenericObjectPool::setMaxTotal, maxTotal);</span>
<span class="fc" id="L2222">    }</span>

    /**
     * Sets the MaxWaitMillis property. Use -1 to make the pool wait indefinitely.
     *
     * @param maxWaitDuration the new value for MaxWaitMillis
     * @see #getMaxWaitDuration()
     * @since 2.10.0
     */
    public synchronized void setMaxWait(final Duration maxWaitDuration) {
<span class="fc" id="L2232">        this.maxWaitDuration = maxWaitDuration;</span>
<span class="fc" id="L2233">        setConnectionPool(GenericObjectPool::setMaxWait, maxWaitDuration);</span>
<span class="fc" id="L2234">    }</span>

    /**
     * Sets the MaxWaitMillis property. Use -1 to make the pool wait indefinitely.
     *
     * @param maxWaitMillis the new value for MaxWaitMillis
     * @see #getMaxWaitDuration()
     * @deprecated {@link #setMaxWait(Duration)}.
     */
    @Deprecated
    public synchronized void setMaxWaitMillis(final long maxWaitMillis) {
<span class="fc" id="L2245">        setMaxWait(Duration.ofMillis(maxWaitMillis));</span>
<span class="fc" id="L2246">    }</span>

    /**
     * Sets the {code minEvictableIdleDuration} property.
     *
     * @param minEvictableIdleDuration the minimum amount of time an object may sit idle in the pool
     * @see #setMinEvictableIdle(Duration)
     * @since 2.10.0
     */
    public synchronized void setMinEvictableIdle(final Duration minEvictableIdleDuration) {
<span class="fc" id="L2256">        this.minEvictableIdleDuration = minEvictableIdleDuration;</span>
<span class="fc" id="L2257">        setConnectionPool(GenericObjectPool::setMinEvictableIdleDuration, minEvictableIdleDuration);</span>
<span class="fc" id="L2258">    }</span>

    /**
     * Sets the {code minEvictableIdleDuration} property.
     *
     * @param minEvictableIdleTimeMillis the minimum amount of time an object may sit idle in the pool
     * @see #setMinEvictableIdle(Duration)
     * @deprecated Use {@link #setMinEvictableIdle(Duration)}.
     */
    @Deprecated
    public synchronized void setMinEvictableIdleTimeMillis(final long minEvictableIdleTimeMillis) {
<span class="fc" id="L2269">        setMinEvictableIdle(Duration.ofMillis(minEvictableIdleTimeMillis));</span>
<span class="fc" id="L2270">    }</span>

    /**
     * Sets the minimum number of idle connections in the pool. The pool attempts to ensure that minIdle connections are
     * available when the idle object evictor runs. The value of this property has no effect unless
     * {code durationBetweenEvictionRuns} has a positive value.
     *
     * @param minIdle the new value for minIdle
     * @see GenericObjectPool#setMinIdle(int)
     */
    public synchronized void setMinIdle(final int minIdle) {
<span class="fc" id="L2281">        this.minIdle = minIdle;</span>
<span class="fc" id="L2282">        setConnectionPool(GenericObjectPool::setMinIdle, minIdle);</span>
<span class="fc" id="L2283">    }</span>

    /**
     * Sets the value of the {code numTestsPerEvictionRun} property.
     *
     * @param numTestsPerEvictionRun the new {code numTestsPerEvictionRun} value
     * @see #setNumTestsPerEvictionRun(int)
     */
    public synchronized void setNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
<span class="fc" id="L2292">        this.numTestsPerEvictionRun = numTestsPerEvictionRun;</span>
<span class="fc" id="L2293">        setConnectionPool(GenericObjectPool::setNumTestsPerEvictionRun, numTestsPerEvictionRun);</span>
<span class="fc" id="L2294">    }</span>

    /**
     * Sets the {code password}.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param password new value for the password
     */
    public void setPassword(final String password) {
<span class="fc" id="L2307">        this.password = password;</span>
<span class="fc" id="L2308">    }</span>

    /**
     * Sets whether to pool statements or not.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param poolingStatements pooling on or off
     */
    public synchronized void setPoolPreparedStatements(final boolean poolingStatements) {
<span class="fc" id="L2321">        this.poolPreparedStatements = poolingStatements;</span>
<span class="fc" id="L2322">    }</span>

    /**
     * Sets if connection level JMX tracking is requested for this DataSource. If true, each connection will be
     * registered for tracking with JMX.
     *
     * @param registerConnectionMBean connection tracking requested for this DataSource.
     */
    public void setRegisterConnectionMBean(final boolean registerConnectionMBean) {
<span class="fc" id="L2331">        this.registerConnectionMBean = registerConnectionMBean;</span>
<span class="fc" id="L2332">    }</span>

    /**
     * @param removeAbandonedOnBorrow true means abandoned connections may be removed when connections are borrowed from
     *                                the pool.
     * @see #getRemoveAbandonedOnBorrow()
     */
    public void setRemoveAbandonedOnBorrow(final boolean removeAbandonedOnBorrow) {
<span class="fc" id="L2340">        setAbandoned(AbandonedConfig::setRemoveAbandonedOnBorrow, removeAbandonedOnBorrow);</span>
<span class="fc" id="L2341">    }</span>

    /**
     * @param removeAbandonedOnMaintenance true means abandoned connections may be removed on pool maintenance.
     * @see #getRemoveAbandonedOnMaintenance()
     */
    public void setRemoveAbandonedOnMaintenance(final boolean removeAbandonedOnMaintenance) {
<span class="fc" id="L2348">        setAbandoned(AbandonedConfig::setRemoveAbandonedOnMaintenance, removeAbandonedOnMaintenance);</span>
<span class="fc" id="L2349">    }</span>

    /**
     * Sets the timeout before an abandoned connection can be removed.
     * &lt;p&gt;
     * Setting this property has no effect if {@link #getRemoveAbandonedOnBorrow()} and
     * {code getRemoveAbandonedOnMaintenance()} are false.
     * &lt;/p&gt;
     *
     * @param removeAbandonedTimeout new abandoned timeout
     * @see #getRemoveAbandonedTimeoutDuration()
     * @see #getRemoveAbandonedOnBorrow()
     * @see #getRemoveAbandonedOnMaintenance()
     * @since 2.10.0
     */
    public void setRemoveAbandonedTimeout(final Duration removeAbandonedTimeout) {
<span class="fc" id="L2365">        setAbandoned(AbandonedConfig::setRemoveAbandonedTimeout, removeAbandonedTimeout);</span>
<span class="fc" id="L2366">    }</span>

    /**
     * Sets the timeout in seconds before an abandoned connection can be removed.
     * &lt;p&gt;
     * Setting this property has no effect if {@link #getRemoveAbandonedOnBorrow()} and
     * {@link #getRemoveAbandonedOnMaintenance()} are false.
     * &lt;/p&gt;
     *
     * @param removeAbandonedTimeout new abandoned timeout in seconds
     * @see #getRemoveAbandonedTimeoutDuration()
     * @see #getRemoveAbandonedOnBorrow()
     * @see #getRemoveAbandonedOnMaintenance()
     * @deprecated Use {@link #setRemoveAbandonedTimeout(Duration)}.
     */
    @Deprecated
    public void setRemoveAbandonedTimeout(final int removeAbandonedTimeout) {
<span class="fc" id="L2383">        setAbandoned(AbandonedConfig::setRemoveAbandonedTimeout, Duration.ofSeconds(removeAbandonedTimeout));</span>
<span class="fc" id="L2384">    }</span>

    /**
     * Sets the flag that controls if a connection will be rolled back when it is returned to the pool if auto commit is
     * not enabled and the connection is not read only.
     *
     * @param rollbackOnReturn whether a connection will be rolled back when it is returned to the pool.
     */
    public void setRollbackOnReturn(final boolean rollbackOnReturn) {
<span class="nc" id="L2393">        this.rollbackOnReturn = rollbackOnReturn;</span>
<span class="nc" id="L2394">    }</span>

    /**
     * Sets the minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the
     * idle object evictor, with the extra condition that at least &quot;minIdle&quot; connections remain in the pool.
     *
     * @param softMinEvictableIdleTimeMillis minimum amount of time a connection may sit idle in the pool before it is
     *                                       eligible for eviction, assuming there are minIdle idle connections in the
     *                                       pool.
     * @see #getSoftMinEvictableIdleTimeMillis
     * @since 2.10.0
     */
    public synchronized void setSoftMinEvictableIdle(final Duration softMinEvictableIdleTimeMillis) {
<span class="fc" id="L2407">        this.softMinEvictableIdleDuration = softMinEvictableIdleTimeMillis;</span>
<span class="fc" id="L2408">        setConnectionPool(GenericObjectPool::setSoftMinEvictableIdleDuration, softMinEvictableIdleTimeMillis);</span>
<span class="fc" id="L2409">    }</span>

    /**
     * Sets the minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the
     * idle object evictor, with the extra condition that at least &quot;minIdle&quot; connections remain in the pool.
     *
     * @param softMinEvictableIdleTimeMillis minimum amount of time a connection may sit idle in the pool before it is
     *                                       eligible for eviction, assuming there are minIdle idle connections in the
     *                                       pool.
     * @see #getSoftMinEvictableIdleTimeMillis
     * @deprecated Use {@link #setSoftMinEvictableIdle(Duration)}.
     */
    @Deprecated
    public synchronized void setSoftMinEvictableIdleTimeMillis(final long softMinEvictableIdleTimeMillis) {
<span class="fc" id="L2423">        setSoftMinEvictableIdle(Duration.ofMillis(softMinEvictableIdleTimeMillis));</span>
<span class="fc" id="L2424">    }</span>

    /**
     * Sets the {code testOnBorrow} property. This property determines whether or not the pool will validate objects
     * before they are borrowed from the pool.
     *
     * @param testOnBorrow new value for testOnBorrow property
     */
    public synchronized void setTestOnBorrow(final boolean testOnBorrow) {
<span class="fc" id="L2433">        this.testOnBorrow = testOnBorrow;</span>
<span class="fc" id="L2434">        setConnectionPool(GenericObjectPool::setTestOnBorrow, testOnBorrow);</span>
<span class="fc" id="L2435">    }</span>

    /**
     * Sets the {code testOnCreate} property. This property determines whether or not the pool will validate objects
     * immediately after they are created by the pool
     *
     * @param testOnCreate new value for testOnCreate property
     */
    public synchronized void setTestOnCreate(final boolean testOnCreate) {
<span class="nc" id="L2444">        this.testOnCreate = testOnCreate;</span>
<span class="nc" id="L2445">        setConnectionPool(GenericObjectPool::setTestOnCreate, testOnCreate);</span>
<span class="nc" id="L2446">    }</span>

    /**
     * Sets the {@code testOnReturn} property. This property determines whether or not the pool will validate
     * objects before they are returned to the pool.
     *
     * @param testOnReturn new value for testOnReturn property
     */
    public synchronized void setTestOnReturn(final boolean testOnReturn) {
<span class="fc" id="L2455">        this.testOnReturn = testOnReturn;</span>
<span class="fc" id="L2456">        setConnectionPool(GenericObjectPool::setTestOnReturn, testOnReturn);</span>
<span class="fc" id="L2457">    }</span>

    /**
     * Sets the {@code testWhileIdle} property. This property determines whether or not the idle object evictor
     * will validate connections.
     *
     * @param testWhileIdle new value for testWhileIdle property
     */
    public synchronized void setTestWhileIdle(final boolean testWhileIdle) {
<span class="fc" id="L2466">        this.testWhileIdle = testWhileIdle;</span>
<span class="fc" id="L2467">        setConnectionPool(GenericObjectPool::setTestWhileIdle, testWhileIdle);</span>
<span class="fc" id="L2468">    }</span>

    /**
     * Sets the {code durationBetweenEvictionRuns} property.
     *
     * @param timeBetweenEvictionRunsMillis the new time between evictor runs
     * @see #setDurationBetweenEvictionRuns(Duration)
     * @deprecated Use {@link #setDurationBetweenEvictionRuns(Duration)}.
     */
    @Deprecated
    public synchronized void setTimeBetweenEvictionRunsMillis(final long timeBetweenEvictionRunsMillis) {
<span class="fc" id="L2479">        setDurationBetweenEvictionRuns(Duration.ofMillis(timeBetweenEvictionRunsMillis));</span>
<span class="fc" id="L2480">    }</span>

    /**
     * Sets the {code connection string}.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param connectionString the new value for the JDBC connection connectionString
     */
    public synchronized void setUrl(final String connectionString) {
<span class="fc" id="L2493">        this.connectionString = connectionString;</span>
<span class="fc" id="L2494">    }</span>

    /**
     * Sets the {code userName}.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param userName the new value for the JDBC connection user name
     */
    public void setUsername(final String userName) {
<span class="fc" id="L2507">        this.userName = userName;</span>
<span class="fc" id="L2508">    }</span>

    /**
     * Sets the {code validationQuery}.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param validationQuery the new value for the validation query
     */
    public void setValidationQuery(final String validationQuery) {
<span class="fc bfc" id="L2521" title="All 2 branches covered.">        this.validationQuery = isEmpty(validationQuery) ? null : validationQuery;</span>
<span class="fc" id="L2522">    }</span>

    /**
     * Sets the validation query timeout, the amount of time, in seconds, that connection validation will wait for a
     * response from the database when executing a validation query. Use a value less than or equal to 0 for no timeout.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param validationQueryTimeoutDuration new validation query timeout value in seconds
     * @since 2.10.0
     */
    public void setValidationQueryTimeout(final Duration validationQueryTimeoutDuration) {
<span class="fc" id="L2537">        this.validationQueryTimeoutDuration = validationQueryTimeoutDuration;</span>
<span class="fc" id="L2538">    }</span>

    /**
     * Sets the validation query timeout, the amount of time, in seconds, that connection validation will wait for a
     * response from the database when executing a validation query. Use a value less than or equal to 0 for no timeout.
     * &lt;p&gt;
     * Note: this method currently has no effect once the pool has been initialized. The pool is initialized the first
     * time one of the following methods is invoked: &lt;code&gt;getConnection, setLogwriter,
     * setLoginTimeout, getLoginTimeout, getLogWriter.&lt;/code&gt;
     * &lt;/p&gt;
     *
     * @param validationQueryTimeoutSeconds new validation query timeout value in seconds
     * @deprecated Use {@link #setValidationQueryTimeout(Duration)}.
     */
    @Deprecated
    public void setValidationQueryTimeout(final int validationQueryTimeoutSeconds) {
<span class="fc" id="L2554">        this.validationQueryTimeoutDuration = Duration.ofSeconds(validationQueryTimeoutSeconds);</span>
<span class="fc" id="L2555">    }</span>

    /**
     * Starts the datasource.
     * &lt;p&gt;
     * It is not necessary to call this method before using a newly created BasicDataSource instance, but
     * calling it in that context causes the datasource to be immediately initialized (instead of waiting for
     * the first {@link #getConnection()} request). Its primary use is to restart and reinitialize a
     * datasource that has been closed.
     * &lt;p&gt;
     * When this method is called after {@link #close()}, connections checked out by clients
     * before the datasource was stopped do not count in {@link #getMaxTotal()} or {@link #getNumActive()}.
     * For example, if there are 3 connections checked out by clients when {@link #close()} is invoked and they are
     * not returned before {@link #start()} is invoked, after this method is called, {@link #getNumActive()} will
     * return 0.  These connections will be physically closed when they are returned, but they will not count against
     * the maximum allowed in the newly started datasource.
     *
     * @throws SQLException if an error occurs initializing the datasource
     */
    @Override
    public synchronized void start() throws SQLException {
<span class="fc" id="L2576">        closed = false;</span>
<span class="fc" id="L2577">        createDataSource();</span>
<span class="fc" id="L2578">    }</span>

    /**
     * Starts the connection pool maintenance task, if configured.
     */
    protected void startPoolMaintenance() {
<span class="pc bpc" id="L2584" title="1 of 4 branches missed.">        if (connectionPool != null &amp;&amp; durationBetweenEvictionRuns.compareTo(Duration.ZERO) &gt; 0) {</span>
<span class="fc" id="L2585">            connectionPool.setDurationBetweenEvictionRuns(durationBetweenEvictionRuns);</span>
        }
<span class="fc" id="L2587">    }</span>

    @Override
    public &lt;T&gt; T unwrap(final Class&lt;T&gt; iface) throws SQLException {
<span class="fc bfc" id="L2591" title="All 2 branches covered.">        if (isWrapperFor(iface)) {</span>
<span class="fc" id="L2592">            return iface.cast(this);</span>
        }
<span class="fc" id="L2594">        throw new SQLException(this + &quot; is not a wrapper for &quot; + iface);</span>
    }

    private void updateJmxName(final GenericObjectPoolConfig&lt;?&gt; config) {
<span class="fc bfc" id="L2598" title="All 2 branches covered.">        if (registeredJmxObjectName == null) {</span>
<span class="fc" id="L2599">            return;</span>
        }
<span class="fc" id="L2601">        final StringBuilder base = new StringBuilder(registeredJmxObjectName.toString());</span>
<span class="fc" id="L2602">        base.append(Constants.JMX_CONNECTION_POOL_BASE_EXT);</span>
<span class="fc" id="L2603">        config.setJmxNameBase(base.toString());</span>
<span class="fc" id="L2604">        config.setJmxNamePrefix(Constants.JMX_CONNECTION_POOL_PREFIX);</span>
<span class="fc" id="L2605">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>