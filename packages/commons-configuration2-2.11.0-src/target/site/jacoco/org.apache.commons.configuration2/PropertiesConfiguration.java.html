<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PropertiesConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">PropertiesConfiguration.java</span></div><h1>PropertiesConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.configuration2;

import java.io.FileNotFoundException;
import java.io.FilterWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.Reader;
import java.io.Writer;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.configuration2.convert.ListDelimiterHandler;
import org.apache.commons.configuration2.convert.ValueTransformer;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;
import org.apache.commons.configuration2.io.FileHandler;
import org.apache.commons.configuration2.io.FileLocator;
import org.apache.commons.configuration2.io.FileLocatorAware;
import org.apache.commons.configuration2.io.FileLocatorUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.commons.text.translate.AggregateTranslator;
import org.apache.commons.text.translate.CharSequenceTranslator;
import org.apache.commons.text.translate.EntityArrays;
import org.apache.commons.text.translate.LookupTranslator;
import org.apache.commons.text.translate.UnicodeEscaper;

/**
 * This is the &quot;classic&quot; Properties loader which loads the values from a single or multiple files (which can be chained
 * with &quot;include =&quot;. All given path references are either absolute or relative to the file name supplied in the
 * constructor.
 * &lt;p&gt;
 * In this class, empty PropertyConfigurations can be built, properties added and later saved. include statements are
 * (obviously) not supported if you don't construct a PropertyConfiguration from a file.
 *
 * &lt;p&gt;
 * The properties file syntax is explained here, basically it follows the syntax of the stream parsed by
 * {@link java.util.Properties#load} and adds several useful extensions:
 *
 * &lt;ul&gt;
 * &lt;li&gt;Each property has the syntax {@code key &amp;lt;separator&amp;gt; value}. The separators accepted are {@code '='},
 * {@code ':'} and any white space character. Examples:
 *
 * &lt;pre&gt;
 *  key1 = value1
 *  key2 : value2
 *  key3   value3
 * &lt;/pre&gt;
 *
 * &lt;/li&gt;
 * &lt;li&gt;The &lt;i&gt;key&lt;/i&gt; may use any character, separators must be escaped:
 *
 * &lt;pre&gt;
 *  key\:foo = bar
 * &lt;/pre&gt;
 *
 * &lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;value&lt;/i&gt; may be separated on different lines if a backslash is placed at the end of the line that continues
 * below.&lt;/li&gt;
 * &lt;li&gt;The list delimiter facilities provided by {@link AbstractConfiguration} are supported, too. If an appropriate
 * {@link ListDelimiterHandler} is set (for instance a
 * {@link org.apache.commons.configuration2.convert.DefaultListDelimiterHandler D efaultListDelimiterHandler} object
 * configured with a comma as delimiter character), &lt;i&gt;value&lt;/i&gt; can contain &lt;em&gt;value delimiters&lt;/em&gt; and will then be
 * interpreted as a list of tokens. So the following property definition
 *
 * &lt;pre&gt;
 *  key = This property, has multiple, values
 * &lt;/pre&gt;
 *
 * will result in a property with three values. You can change the handling of delimiters using the
 * {@link AbstractConfiguration#setListDelimiterHandler(ListDelimiterHandler)} method. Per default, list splitting is
 * disabled.&lt;/li&gt;
 * &lt;li&gt;Commas in each token are escaped placing a backslash right before the comma.&lt;/li&gt;
 * &lt;li&gt;If a &lt;i&gt;key&lt;/i&gt; is used more than once, the values are appended like if they were on the same line separated with
 * commas. &lt;em&gt;Note&lt;/em&gt;: When the configuration file is written back to disk the associated
 * {@link PropertiesConfigurationLayout} object (see below) will try to preserve as much of the original format as
 * possible, i.e. properties with multiple values defined on a single line will also be written back on a single line,
 * and multiple occurrences of a single key will be written on multiple lines. If the {@code addProperty()} method was
 * called multiple times for adding multiple values to a property, these properties will per default be written on
 * multiple lines in the output file, too. Some options of the {@code PropertiesConfigurationLayout} class have
 * influence on that behavior.&lt;/li&gt;
 * &lt;li&gt;Blank lines and lines starting with character '#' or '!' are skipped.&lt;/li&gt;
 * &lt;li&gt;If a property is named &quot;include&quot; (or whatever is defined by setInclude() and getInclude() and the value of that
 * property is the full path to a file on disk, that file will be included into the configuration. You can also pull in
 * files relative to the parent configuration file. So if you have something like the following:
 *
 * include = additional.properties
 *
 * Then &quot;additional.properties&quot; is expected to be in the same directory as the parent configuration file.
 *
 * The properties in the included file are added to the parent configuration, they do not replace existing properties
 * with the same key.
 *
 * &lt;/li&gt;
 * &lt;li&gt;You can define custom error handling for the special key {@code &quot;include&quot;} by using
 * {@link #setIncludeListener(ConfigurationConsumer)}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Here is an example of a valid extended properties file:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 *      # lines starting with # are comments
 *
 *      # This is the simplest property
 *      key = value
 *
 *      # A long property may be separated on multiple lines
 *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
 *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 *
 *      # This is a property with many tokens
 *      tokens_on_a_line = first token, second token
 *
 *      # This sequence generates exactly the same result
 *      tokens_on_multiple_lines = first token
 *      tokens_on_multiple_lines = second token
 *
 *      # commas may be escaped in tokens
 *      commas.escaped = Hi\, what'up?
 *
 *      # properties can reference other properties
 *      base.prop = /base
 *      first.prop = ${base.prop}/first
 *      second.prop = ${first.prop}/second
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * A {@code PropertiesConfiguration} object is associated with an instance of the {@link PropertiesConfigurationLayout}
 * class, which is responsible for storing the layout of the parsed properties file (i.e. empty lines, comments, and
 * such things). The {@code getLayout()} method can be used to obtain this layout object. With {@code setLayout()} a new
 * layout object can be set. This should be done before a properties file was loaded.
 * &lt;p&gt;
 * Like other {@code Configuration} implementations, this class uses a {@code Synchronizer} object to control concurrent
 * access. By choosing a suitable implementation of the {@code Synchronizer} interface, an instance can be made
 * thread-safe or not. Note that access to most of the properties typically set through a builder is not protected by
 * the {@code Synchronizer}. The intended usage is that these properties are set once at construction time through the
 * builder and after that remain constant. If you wish to change such properties during life time of an instance, you
 * have to use the {@code lock()} and {@code unlock()} methods manually to ensure that other threads see your changes.
 * &lt;p&gt;
 * As this class extends {@link AbstractConfiguration}, all basic features like variable interpolation, list handling,
 * or data type conversions are available as well. This is described in the chapter
 * &lt;a href=&quot;https://commons.apache.org/proper/commons-configuration/userguide/howto_basicfeatures.html&quot;&gt; Basic features
 * and AbstractConfiguration&lt;/a&gt; of the user's guide. There is also a separate chapter dealing with
 * &lt;a href=&quot;commons.apache.org/proper/commons-configuration/userguide/howto_properties.html&quot;&gt; Properties files&lt;/a&gt; in
 * special.
 *
 * @see java.util.Properties#load
 */
public class PropertiesConfiguration extends BaseConfiguration implements FileBasedConfiguration, FileLocatorAware {

    /**
     * &lt;p&gt;
     * A default implementation of the {@code IOFactory} interface.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This class implements the {@code createXXXX()} methods defined by the {@code IOFactory} interface in a way that the
     * default objects (i.e. {@code PropertiesReader} and {@code PropertiesWriter} are returned. Customizing either the
     * reader or the writer (or both) can be done by extending this class and overriding the corresponding
     * {@code createXXXX()} method.
     * &lt;/p&gt;
     *
     * @since 1.7
     */
<span class="fc" id="L194">    public static class DefaultIOFactory implements IOFactory {</span>
        /**
         * The singleton instance.
         */
<span class="fc" id="L198">        static final DefaultIOFactory INSTANCE = new DefaultIOFactory();</span>

        @Override
        public PropertiesReader createPropertiesReader(final Reader in) {
<span class="fc" id="L202">            return new PropertiesReader(in);</span>
        }

        @Override
        public PropertiesWriter createPropertiesWriter(final Writer out, final ListDelimiterHandler handler) {
<span class="fc" id="L207">            return new PropertiesWriter(out, handler);</span>
        }
    }

    /**
     * &lt;p&gt;
     * Definition of an interface that allows customization of read and write operations.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For reading and writing properties files the inner classes {@code PropertiesReader} and {@code PropertiesWriter} are
     * used. This interface defines factory methods for creating both a {@code PropertiesReader} and a
     * {@code PropertiesWriter}. An object implementing this interface can be passed to the {@code setIOFactory()} method of
     * {@code PropertiesConfiguration}. Every time the configuration is read or written the {@code IOFactory} is asked to
     * create the appropriate reader or writer object. This provides an opportunity to inject custom reader or writer
     * implementations.
     * &lt;/p&gt;
     *
     * @since 1.7
     */
    public interface IOFactory {
        /**
         * Creates a {@code PropertiesReader} for reading a properties file. This method is called whenever the
         * {@code PropertiesConfiguration} is loaded. The reader returned by this method is then used for parsing the properties
         * file.
         *
         * @param in the underlying reader (of the properties file)
         * @return the {@code PropertiesReader} for loading the configuration
         */
        PropertiesReader createPropertiesReader(Reader in);

        /**
         * Creates a {@code PropertiesWriter} for writing a properties file. This method is called before the
         * {@code PropertiesConfiguration} is saved. The writer returned by this method is then used for writing the properties
         * file.
         *
         * @param out the underlying writer (to the properties file)
         * @param handler the list delimiter delimiter for list parsing
         * @return the {@code PropertiesWriter} for saving the configuration
         */
        PropertiesWriter createPropertiesWriter(Writer out, ListDelimiterHandler handler);
    }

    /**
     * An alternative {@link IOFactory} that tries to mimic the behavior of {@link java.util.Properties} (Jup) more closely.
     * The goal is to allow both of them be used interchangeably when reading and writing properties files without losing or
     * changing information.
     * &lt;p&gt;
     * It also has the option to &lt;em&gt;not&lt;/em&gt; use Unicode escapes. When using UTF-8 encoding (which is e.g. the new default
     * for resource bundle properties files since Java 9), Unicode escapes are no longer required and avoiding them makes
     * properties files more readable with regular text editors.
     * &lt;p&gt;
     * Some of the ways this implementation differs from {@link DefaultIOFactory}:
     * &lt;ul&gt;
     * &lt;li&gt;Trailing whitespace will not be trimmed from each line.&lt;/li&gt;
     * &lt;li&gt;Unknown escape sequences will have their backslash removed.&lt;/li&gt;
     * &lt;li&gt;{@code \b} is not a recognized escape sequence.&lt;/li&gt;
     * &lt;li&gt;Leading spaces in property values are preserved by escaping them.&lt;/li&gt;
     * &lt;li&gt;All natural lines (i.e. in the file) of a logical property line will have their leading whitespace trimmed.&lt;/li&gt;
     * &lt;li&gt;Natural lines that look like comment lines within a logical line are not treated as such; they're part of the
     * property value.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @since 2.4
     */
    public static class JupIOFactory implements IOFactory {

        /**
         * Whether characters less than {@code \u0020} and characters greater than {@code \u007E} in property keys or values
         * should be escaped using Unicode escape sequences. Not necessary when e.g. writing as UTF-8.
         */
        private final boolean escapeUnicode;

        /**
         * Constructs a new {@link JupIOFactory} with Unicode escaping.
         */
        public JupIOFactory() {
<span class="fc" id="L283">            this(true);</span>
<span class="fc" id="L284">        }</span>

        /**
         * Constructs a new {@link JupIOFactory} with optional Unicode escaping. Whether Unicode escaping is required depends on
         * the encoding used to save the properties file. E.g. for ISO-8859-1 this must be turned on, for UTF-8 it's not
         * necessary. Unfortunately this factory can't determine the encoding on its own.
         *
         * @param escapeUnicode whether Unicode characters should be escaped
         */
<span class="fc" id="L293">        public JupIOFactory(final boolean escapeUnicode) {</span>
<span class="fc" id="L294">            this.escapeUnicode = escapeUnicode;</span>
<span class="fc" id="L295">        }</span>

        @Override
        public PropertiesReader createPropertiesReader(final Reader in) {
<span class="fc" id="L299">            return new JupPropertiesReader(in);</span>
        }

        @Override
        public PropertiesWriter createPropertiesWriter(final Writer out, final ListDelimiterHandler handler) {
<span class="fc" id="L304">            return new JupPropertiesWriter(out, handler, escapeUnicode);</span>
        }

    }

    /**
     * A {@link PropertiesReader} that tries to mimic the behavior of {@link java.util.Properties}.
     *
     * @since 2.4
     */
    public static class JupPropertiesReader extends PropertiesReader {

        /**
         * Constructs a new instance.
         *
         * @param reader A Reader.
         */
        public JupPropertiesReader(final Reader reader) {
<span class="fc" id="L322">            super(reader);</span>
<span class="fc" id="L323">        }</span>

        @Override
        protected void parseProperty(final String line) {
<span class="fc" id="L327">            final String[] property = doParseProperty(line, false);</span>
<span class="fc" id="L328">            initPropertyName(property[0]);</span>
<span class="fc" id="L329">            initPropertyValue(property[1]);</span>
<span class="fc" id="L330">            initPropertySeparator(property[2]);</span>
<span class="fc" id="L331">        }</span>

        @Override
        public String readProperty() throws IOException {
<span class="fc" id="L335">            getCommentLines().clear();</span>
<span class="fc" id="L336">            final StringBuilder buffer = new StringBuilder();</span>

            while (true) {
<span class="fc" id="L339">                String line = readLine();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                if (line == null) {</span>
                    // EOF
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">                    if (buffer.length() &gt; 0) {</span>
<span class="nc" id="L343">                        break;</span>
                    }
<span class="fc" id="L345">                    return null;</span>
                }

                // while a property line continues there are no comments (even if the line from
                // the file looks like one)
<span class="fc bfc" id="L350" title="All 4 branches covered.">                if (isCommentLine(line) &amp;&amp; buffer.length() == 0) {</span>
<span class="fc" id="L351">                    getCommentLines().add(line);</span>
<span class="fc" id="L352">                    continue;</span>
                }

                // while property line continues left trim all following lines read from the
                // file
<span class="fc bfc" id="L357" title="All 2 branches covered.">                if (buffer.length() &gt; 0) {</span>
                    // index of the first non-whitespace character
                    int i;
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                    for (i = 0; i &lt; line.length(); i++) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                        if (!Character.isWhitespace(line.charAt(i))) {</span>
<span class="fc" id="L362">                            break;</span>
                        }
                    }

<span class="fc" id="L366">                    line = line.substring(i);</span>
                }

<span class="fc bfc" id="L369" title="All 2 branches covered.">                if (!checkCombineLines(line)) {</span>
<span class="fc" id="L370">                    buffer.append(line);</span>
<span class="fc" id="L371">                    break;</span>
                }
<span class="fc" id="L373">                line = line.substring(0, line.length() - 1);</span>
<span class="fc" id="L374">                buffer.append(line);</span>
<span class="fc" id="L375">            }</span>
<span class="fc" id="L376">            return buffer.toString();</span>
        }

        @Override
        protected String unescapePropertyValue(final String value) {
<span class="fc" id="L381">            return unescapeJava(value, true);</span>
        }

    }

    /**
     * A {@link PropertiesWriter} that tries to mimic the behavior of {@link java.util.Properties}.
     *
     * @since 2.4
     */
    public static class JupPropertiesWriter extends PropertiesWriter {

        /**
         * The starting ASCII printable character.
         */
        private static final int PRINTABLE_INDEX_END = 0x7e;

        /**
         * The ending ASCII printable character.
         */
        private static final int PRINTABLE_INDEX_START = 0x20;

        /**
         * A UnicodeEscaper for characters outside the ASCII printable range.
         */
<span class="fc" id="L406">        private static final UnicodeEscaper ESCAPER = UnicodeEscaper.outsideOf(PRINTABLE_INDEX_START, PRINTABLE_INDEX_END);</span>

        /**
         * Characters that need to be escaped when wring a properties file.
         */
        private static final Map&lt;CharSequence, CharSequence&gt; JUP_CHARS_ESCAPE;
        static {
<span class="fc" id="L413">            final Map&lt;CharSequence, CharSequence&gt; initialMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L414">            initialMap.put(&quot;\\&quot;, &quot;\\\\&quot;);</span>
<span class="fc" id="L415">            initialMap.put(&quot;\n&quot;, &quot;\\n&quot;);</span>
<span class="fc" id="L416">            initialMap.put(&quot;\t&quot;, &quot;\\t&quot;);</span>
<span class="fc" id="L417">            initialMap.put(&quot;\f&quot;, &quot;\\f&quot;);</span>
<span class="fc" id="L418">            initialMap.put(&quot;\r&quot;, &quot;\\r&quot;);</span>
<span class="fc" id="L419">            JUP_CHARS_ESCAPE = Collections.unmodifiableMap(initialMap);</span>
<span class="fc" id="L420">        }</span>

        /**
         * Creates a new instance of {@code JupPropertiesWriter}.
         *
         * @param writer a Writer object providing the underlying stream
         * @param delHandler the delimiter handler for dealing with properties with multiple values
         * @param escapeUnicode whether Unicode characters should be escaped using Unicode escapes
         */
        public JupPropertiesWriter(final Writer writer, final ListDelimiterHandler delHandler, final boolean escapeUnicode) {
<span class="fc" id="L430">            super(writer, delHandler, value -&gt; {</span>
<span class="fc" id="L431">                String valueString = String.valueOf(value);</span>

                final CharSequenceTranslator translator;
<span class="fc bfc" id="L434" title="All 2 branches covered.">                if (escapeUnicode) {</span>
<span class="fc" id="L435">                    translator = new AggregateTranslator(new LookupTranslator(JUP_CHARS_ESCAPE), ESCAPER);</span>
                } else {
<span class="fc" id="L437">                    translator = new AggregateTranslator(new LookupTranslator(JUP_CHARS_ESCAPE));</span>
                }

<span class="fc" id="L440">                valueString = translator.translate(valueString);</span>

                // escape the first leading space to preserve it (and all after it)
<span class="fc bfc" id="L443" title="All 2 branches covered.">                if (valueString.startsWith(&quot; &quot;)) {</span>
<span class="fc" id="L444">                    valueString = &quot;\\&quot; + valueString;</span>
                }

<span class="fc" id="L447">                return valueString;</span>
            });
<span class="fc" id="L449">        }</span>

    }

    /**
     * This class is used to read properties lines. These lines do not terminate with new-line chars but rather when there
     * is no backslash sign a the end of the line. This is used to concatenate multiple lines for readability.
     */
    public static class PropertiesReader extends LineNumberReader {

        /** The regular expression to parse the key and the value of a property. */
<span class="fc" id="L460">        private static final Pattern PROPERTY_PATTERN = Pattern</span>
<span class="fc" id="L461">            .compile(&quot;(([\\S&amp;&amp;[^\\\\&quot; + new String(SEPARATORS) + &quot;]]|\\\\.)*+)(\\s*(\\s+|[&quot; + new String(SEPARATORS) + &quot;])\\s*)?(.*)&quot;);</span>

        /** Constant for the index of the group for the key. */
        private static final int IDX_KEY = 1;

        /** Constant for the index of the group for the value. */
        private static final int IDX_VALUE = 5;

        /** Constant for the index of the group for the separator. */
        private static final int IDX_SEPARATOR = 3;

        /**
         * Checks if the passed in line should be combined with the following. This is true, if the line ends with an odd number
         * of backslashes.
         *
         * @param line the line
         * @return a flag if the lines should be combined
         */
        static boolean checkCombineLines(final String line) {
<span class="fc bfc" id="L480" title="All 2 branches covered.">            return countTrailingBS(line) % 2 != 0;</span>
        }

        /**
         * Parse a property line and return the key, the value, and the separator in an array.
         *
         * @param line the line to parse
         * @param trimValue flag whether the value is to be trimmed
         * @return an array with the property's key, value, and separator
         */
        static String[] doParseProperty(final String line, final boolean trimValue) {
<span class="fc" id="L491">            final Matcher matcher = PROPERTY_PATTERN.matcher(line);</span>

<span class="fc" id="L493">            final String[] result = {&quot;&quot;, &quot;&quot;, &quot;&quot;};</span>

<span class="pc bpc" id="L495" title="1 of 2 branches missed.">            if (matcher.matches()) {</span>
<span class="fc" id="L496">                result[0] = matcher.group(IDX_KEY).trim();</span>

<span class="fc" id="L498">                String value = matcher.group(IDX_VALUE);</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                if (trimValue) {</span>
<span class="fc" id="L500">                    value = value.trim();</span>
                }
<span class="fc" id="L502">                result[1] = value;</span>

<span class="fc" id="L504">                result[2] = matcher.group(IDX_SEPARATOR);</span>
            }

<span class="fc" id="L507">            return result;</span>
        }

        /** Stores the comment lines for the currently processed property. */
        private final List&lt;String&gt; commentLines;

        /** Stores the name of the last read property. */
        private String propertyName;

        /** Stores the value of the last read property. */
        private String propertyValue;

        /** Stores the property separator of the last read property. */
<span class="fc" id="L520">        private String propertySeparator = DEFAULT_SEPARATOR;</span>

        /**
         * Constructs a new instance.
         *
         * @param reader A Reader.
         */
        public PropertiesReader(final Reader reader) {
<span class="fc" id="L528">            super(reader);</span>
<span class="fc" id="L529">            commentLines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L530">        }</span>

        /**
         * Gets the comment lines that have been read for the last property.
         *
         * @return the comment lines for the last property returned by {@code readProperty()}
         * @since 1.3
         */
        public List&lt;String&gt; getCommentLines() {
<span class="fc" id="L539">            return commentLines;</span>
        }

        /**
         * Gets the name of the last read property. This method can be called after {@link #nextProperty()} was invoked and
         * its return value was &lt;b&gt;true&lt;/b&gt;.
         *
         * @return the name of the last read property
         * @since 1.3
         */
        public String getPropertyName() {
<span class="fc" id="L550">            return propertyName;</span>
        }

        /**
         * Gets the separator that was used for the last read property. The separator can be stored so that it can later be
         * restored when saving the configuration.
         *
         * @return the separator for the last read property
         * @since 1.7
         */
        public String getPropertySeparator() {
<span class="fc" id="L561">            return propertySeparator;</span>
        }

        /**
         * Gets the value of the last read property. This method can be called after {@link #nextProperty()} was invoked and
         * its return value was &lt;b&gt;true&lt;/b&gt;.
         *
         * @return the value of the last read property
         * @since 1.3
         */
        public String getPropertyValue() {
<span class="fc" id="L572">            return propertyValue;</span>
        }

        /**
         * Sets the name of the current property. This method can be called by {@code parseProperty()} for storing the results
         * of the parse operation. It also ensures that the property key is correctly escaped.
         *
         * @param name the name of the current property
         * @since 1.7
         */
        protected void initPropertyName(final String name) {
<span class="fc" id="L583">            propertyName = unescapePropertyName(name);</span>
<span class="fc" id="L584">        }</span>

        /**
         * Sets the separator of the current property. This method can be called by {@code parseProperty()}. It allows the
         * associated layout object to keep track of the property separators. When saving the configuration the separators can
         * be restored.
         *
         * @param value the separator used for the current property
         * @since 1.7
         */
        protected void initPropertySeparator(final String value) {
<span class="fc" id="L595">            propertySeparator = value;</span>
<span class="fc" id="L596">        }</span>

        /**
         * Sets the value of the current property. This method can be called by {@code parseProperty()} for storing the results
         * of the parse operation. It also ensures that the property value is correctly escaped.
         *
         * @param value the value of the current property
         * @since 1.7
         */
        protected void initPropertyValue(final String value) {
<span class="fc" id="L606">            propertyValue = unescapePropertyValue(value);</span>
<span class="fc" id="L607">        }</span>

        /**
         * Parses the next property from the input stream and stores the found name and value in internal fields. These fields
         * can be obtained using the provided getter methods. The return value indicates whether EOF was reached (&lt;b&gt;false&lt;/b&gt;)
         * or whether further properties are available (&lt;b&gt;true&lt;/b&gt;).
         *
         * @return a flag if further properties are available
         * @throws IOException if an error occurs
         * @since 1.3
         */
        public boolean nextProperty() throws IOException {
<span class="fc" id="L619">            final String line = readProperty();</span>

<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (line == null) {</span>
<span class="fc" id="L622">                return false; // EOF</span>
            }

            // parse the line
<span class="fc" id="L626">            parseProperty(line);</span>
<span class="fc" id="L627">            return true;</span>
        }

        /**
         * Parses a line read from the properties file. This method is called for each non-comment line read from the source
         * file. Its task is to split the passed in line into the property key and its value. The results of the parse operation
         * can be stored by calling the {@code initPropertyXXX()} methods.
         *
         * @param line the line read from the properties file
         * @since 1.7
         */
        protected void parseProperty(final String line) {
<span class="fc" id="L639">            final String[] property = doParseProperty(line, true);</span>
<span class="fc" id="L640">            initPropertyName(property[0]);</span>
<span class="fc" id="L641">            initPropertyValue(property[1]);</span>
<span class="fc" id="L642">            initPropertySeparator(property[2]);</span>
<span class="fc" id="L643">        }</span>

        /**
         * Reads a property line. Returns null if Stream is at EOF. Concatenates lines ending with &quot;\&quot;. Skips lines beginning
         * with &quot;#&quot; or &quot;!&quot; and empty lines. The return value is a property definition ({@code &amp;lt;name&amp;gt;} =
         * {@code &amp;lt;value&amp;gt;})
         *
         * @return A string containing a property value or null
         *
         * @throws IOException in case of an I/O error
         */
        public String readProperty() throws IOException {
<span class="fc" id="L655">            commentLines.clear();</span>
<span class="fc" id="L656">            final StringBuilder buffer = new StringBuilder();</span>

            while (true) {
<span class="fc" id="L659">                String line = readLine();</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">                if (line == null) {</span>
                    // EOF
<span class="fc" id="L662">                    return null;</span>
                }

<span class="fc bfc" id="L665" title="All 2 branches covered.">                if (isCommentLine(line)) {</span>
<span class="fc" id="L666">                    commentLines.add(line);</span>
<span class="fc" id="L667">                    continue;</span>
                }

<span class="fc" id="L670">                line = line.trim();</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">                if (!checkCombineLines(line)) {</span>
<span class="fc" id="L673">                    buffer.append(line);</span>
<span class="fc" id="L674">                    break;</span>
                }
<span class="fc" id="L676">                line = line.substring(0, line.length() - 1);</span>
<span class="fc" id="L677">                buffer.append(line);</span>
<span class="fc" id="L678">            }</span>
<span class="fc" id="L679">            return buffer.toString();</span>
        }

        /**
         * Performs unescaping on the given property name.
         *
         * @param name the property name
         * @return the unescaped property name
         * @since 2.4
         */
        protected String unescapePropertyName(final String name) {
<span class="fc" id="L690">            return StringEscapeUtils.unescapeJava(name);</span>
        }

        /**
         * Performs unescaping on the given property value.
         *
         * @param value the property value
         * @return the unescaped property value
         * @since 2.4
         */
        protected String unescapePropertyValue(final String value) {
<span class="fc" id="L701">            return unescapeJava(value);</span>
        }
    } // class PropertiesReader

    /**
     * This class is used to write properties lines. The most important method is
     * {@code writeProperty(String, Object, boolean)}, which is called during a save operation for each property found in
     * the configuration.
     */
    public static class PropertiesWriter extends FilterWriter {

        /**
         * Properties escape map.
         */
        private static final Map&lt;CharSequence, CharSequence&gt; PROPERTIES_CHARS_ESCAPE;
        static {
<span class="fc" id="L717">            final Map&lt;CharSequence, CharSequence&gt; initialMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L718">            initialMap.put(&quot;\\&quot;, &quot;\\\\&quot;);</span>
<span class="fc" id="L719">            PROPERTIES_CHARS_ESCAPE = Collections.unmodifiableMap(initialMap);</span>
        }

        /**
         * A translator for escaping property values. This translator performs a subset of transformations done by the
         * ESCAPE_JAVA translator from Commons Lang 3.
         */
<span class="fc" id="L726">        private static final CharSequenceTranslator ESCAPE_PROPERTIES = new AggregateTranslator(new LookupTranslator(PROPERTIES_CHARS_ESCAPE),</span>
<span class="fc" id="L727">            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE), UnicodeEscaper.outsideOf(32, 0x7f));</span>

        /**
         * A {@code ValueTransformer} implementation used to escape property values. This implementation applies the
         * transformation defined by the {@link #ESCAPE_PROPERTIES} translator.
         */
<span class="fc" id="L733">        private static final ValueTransformer DEFAULT_TRANSFORMER = value -&gt; {</span>
<span class="fc" id="L734">            final String strVal = String.valueOf(value);</span>
<span class="fc" id="L735">            return ESCAPE_PROPERTIES.translate(strVal);</span>
        };

        /** The value transformer used for escaping property values. */
        private final ValueTransformer valueTransformer;

        /** The list delimiter handler. */
        private final ListDelimiterHandler delimiterHandler;

        /** The separator to be used for the current property. */
        private String currentSeparator;

        /** The global separator. If set, it overrides the current separator. */
        private String globalSeparator;

        /** The line separator. */
        private String lineSeparator;

        /**
         * Creates a new instance of {@code PropertiesWriter}.
         *
         * @param writer a Writer object providing the underlying stream
         * @param delHandler the delimiter handler for dealing with properties with multiple values
         */
        public PropertiesWriter(final Writer writer, final ListDelimiterHandler delHandler) {
<span class="fc" id="L760">            this(writer, delHandler, DEFAULT_TRANSFORMER);</span>
<span class="fc" id="L761">        }</span>

        /**
         * Creates a new instance of {@code PropertiesWriter}.
         *
         * @param writer a Writer object providing the underlying stream
         * @param delHandler the delimiter handler for dealing with properties with multiple values
         * @param valueTransformer the value transformer used to escape property values
         */
        public PropertiesWriter(final Writer writer, final ListDelimiterHandler delHandler, final ValueTransformer valueTransformer) {
<span class="fc" id="L771">            super(writer);</span>
<span class="fc" id="L772">            delimiterHandler = delHandler;</span>
<span class="fc" id="L773">            this.valueTransformer = valueTransformer;</span>
<span class="fc" id="L774">        }</span>

        /**
         * Escapes the key of a property before it gets written to file. This method is called on saving a configuration for
         * each property key. It ensures that separator characters contained in the key are escaped.
         *
         * @param key the key
         * @return the escaped key
         * @since 2.0
         */
        protected String escapeKey(final String key) {
<span class="fc" id="L785">            final StringBuilder newkey = new StringBuilder();</span>

<span class="fc bfc" id="L787" title="All 2 branches covered.">            for (int i = 0; i &lt; key.length(); i++) {</span>
<span class="fc" id="L788">                final char c = key.charAt(i);</span>

<span class="pc bpc" id="L790" title="1 of 6 branches missed.">                if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c) || c == '\\') {</span>
                    // escape the separator
<span class="fc" id="L792">                    newkey.append('\\');</span>
                }
<span class="fc" id="L794">                newkey.append(c);</span>
            }

<span class="fc" id="L797">            return newkey.toString();</span>
        }

        /**
         * Returns the separator to be used for the given property. This method is called by {@code writeProperty()}. The string
         * returned here is used as separator between the property key and its value. Per default the method checks whether a
         * global separator is set. If this is the case, it is returned. Otherwise the separator returned by
         * {@code getCurrentSeparator()} is used, which was set by the associated layout object. Derived classes may implement a
         * different strategy for defining the separator.
         *
         * @param key the property key
         * @param value the value
         * @return the separator to be used
         * @since 1.7
         */
        protected String fetchSeparator(final String key, final Object value) {
<span class="fc bfc" id="L813" title="All 2 branches covered.">            return getGlobalSeparator() != null ? getGlobalSeparator() : StringUtils.defaultString(getCurrentSeparator());</span>
        }

        /**
         * Gets the current property separator.
         *
         * @return the current property separator
         * @since 1.7
         */
        public String getCurrentSeparator() {
<span class="fc" id="L823">            return currentSeparator;</span>
        }

        /**
         * Gets the delimiter handler for properties with multiple values. This object is used to escape property values so
         * that they can be read in correctly the next time they are loaded.
         *
         * @return the delimiter handler for properties with multiple values
         * @since 2.0
         */
        public ListDelimiterHandler getDelimiterHandler() {
<span class="fc" id="L834">            return delimiterHandler;</span>
        }

        /**
         * Gets the global property separator.
         *
         * @return the global property separator
         * @since 1.7
         */
        public String getGlobalSeparator() {
<span class="fc" id="L844">            return globalSeparator;</span>
        }

        /**
         * Gets the line separator.
         *
         * @return the line separator
         * @since 1.7
         */
        public String getLineSeparator() {
<span class="fc bfc" id="L854" title="All 2 branches covered.">            return lineSeparator != null ? lineSeparator : LINE_SEPARATOR;</span>
        }

        /**
         * Sets the current property separator. This separator is used when writing the next property.
         *
         * @param currentSeparator the current property separator
         * @since 1.7
         */
        public void setCurrentSeparator(final String currentSeparator) {
<span class="fc" id="L864">            this.currentSeparator = currentSeparator;</span>
<span class="fc" id="L865">        }</span>

        /**
         * Sets the global property separator. This separator corresponds to the {@code globalSeparator} property of
         * {@link PropertiesConfigurationLayout}. It defines the separator to be used for all properties. If it is undefined,
         * the current separator is used.
         *
         * @param globalSeparator the global property separator
         * @since 1.7
         */
        public void setGlobalSeparator(final String globalSeparator) {
<span class="fc" id="L876">            this.globalSeparator = globalSeparator;</span>
<span class="fc" id="L877">        }</span>

        /**
         * Sets the line separator. Each line written by this writer is terminated with this separator. If not set, the
         * platform-specific line separator is used.
         *
         * @param lineSeparator the line separator to be used
         * @since 1.7
         */
        public void setLineSeparator(final String lineSeparator) {
<span class="fc" id="L887">            this.lineSeparator = lineSeparator;</span>
<span class="fc" id="L888">        }</span>

        /**
         * Write a comment.
         *
         * @param comment the comment to write
         * @throws IOException if an I/O error occurs.
         */
        public void writeComment(final String comment) throws IOException {
<span class="nc" id="L897">            writeln(&quot;# &quot; + comment);</span>
<span class="nc" id="L898">        }</span>

        /**
         * Helper method for writing a line with the platform specific line ending.
         *
         * @param s the content of the line (may be &lt;b&gt;null&lt;/b&gt;)
         * @throws IOException if an error occurs
         * @since 1.3
         */
        public void writeln(final String s) throws IOException {
<span class="fc bfc" id="L908" title="All 2 branches covered.">            if (s != null) {</span>
<span class="fc" id="L909">                write(s);</span>
            }
<span class="fc" id="L911">            write(getLineSeparator());</span>
<span class="fc" id="L912">        }</span>

        /**
         * Write a property.
         *
         * @param key The key of the property
         * @param values The array of values of the property
         *
         * @throws IOException if an I/O error occurs.
         */
        public void writeProperty(final String key, final List&lt;?&gt; values) throws IOException {
<span class="fc bfc" id="L923" title="All 2 branches covered.">            for (final Object value : values) {</span>
<span class="fc" id="L924">                writeProperty(key, value);</span>
<span class="fc" id="L925">            }</span>
<span class="fc" id="L926">        }</span>

        /**
         * Write a property.
         *
         * @param key the key of the property
         * @param value the value of the property
         *
         * @throws IOException if an I/O error occurs.
         */
        public void writeProperty(final String key, final Object value) throws IOException {
<span class="fc" id="L937">            writeProperty(key, value, false);</span>
<span class="fc" id="L938">        }</span>

        /**
         * Writes the given property and its value. If the value happens to be a list, the {@code forceSingleLine} flag is
         * evaluated. If it is set, all values are written on a single line using the list delimiter as separator.
         *
         * @param key the property key
         * @param value the property value
         * @param forceSingleLine the &amp;quot;force single line&amp;quot; flag
         * @throws IOException if an error occurs
         * @since 1.3
         */
        public void writeProperty(final String key, final Object value, final boolean forceSingleLine) throws IOException {
            String v;

<span class="fc bfc" id="L953" title="All 2 branches covered.">            if (value instanceof List) {</span>
<span class="fc" id="L954">                v = null;</span>
<span class="fc" id="L955">                final List&lt;?&gt; values = (List&lt;?&gt;) value;</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">                if (forceSingleLine) {</span>
                    try {
<span class="fc" id="L958">                        v = String.valueOf(getDelimiterHandler().escapeList(values, valueTransformer));</span>
<span class="fc" id="L959">                    } catch (final UnsupportedOperationException ignored) {</span>
                        // the handler may not support escaping lists,
                        // then the list is written in multiple lines
<span class="fc" id="L962">                    }</span>
                }
<span class="fc bfc" id="L964" title="All 2 branches covered.">                if (v == null) {</span>
<span class="fc" id="L965">                    writeProperty(key, values);</span>
<span class="fc" id="L966">                    return;</span>
                }
<span class="fc" id="L968">            } else {</span>
<span class="fc" id="L969">                v = String.valueOf(getDelimiterHandler().escape(value, valueTransformer));</span>
            }

<span class="fc" id="L972">            write(escapeKey(key));</span>
<span class="fc" id="L973">            write(fetchSeparator(key, value));</span>
<span class="fc" id="L974">            write(v);</span>

<span class="fc" id="L976">            writeln(null);</span>
<span class="fc" id="L977">        }</span>
    } // class PropertiesWriter

    /**
     * Defines default error handling for the special {@code &quot;include&quot;} key by throwing the given exception.
     *
     * @since 2.6
     */
<span class="fc" id="L985">    public static final ConfigurationConsumer&lt;ConfigurationException&gt; DEFAULT_INCLUDE_LISTENER = e -&gt; {</span>
<span class="fc" id="L986">        throw e;</span>
    };

    /**
     * Defines error handling as a noop for the special {@code &quot;include&quot;} key.
     *
     * @since 2.6
     */
<span class="fc" id="L994">    public static final ConfigurationConsumer&lt;ConfigurationException&gt; NOOP_INCLUDE_LISTENER = e -&gt; { /* noop */ };</span>

    /**
     * The default encoding (ISO-8859-1 as specified by https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html)
     */
<span class="fc" id="L999">    public static final String DEFAULT_ENCODING = StandardCharsets.ISO_8859_1.name();</span>

    /** Constant for the supported comment characters. */
    static final String COMMENT_CHARS = &quot;#!&quot;;

    /** Constant for the default properties separator. */
    static final String DEFAULT_SEPARATOR = &quot; = &quot;;

    /**
     * A string with special characters that need to be unescaped when reading a properties file.
     * {@link java.util.Properties} escapes these characters when writing out a properties file.
     */
    private static final String UNESCAPE_CHARACTERS = &quot;:#=!\\\'\&quot;&quot;;

    /**
     * This is the name of the property that can point to other properties file for including other properties files.
     */
<span class="fc" id="L1016">    private static String include = &quot;include&quot;;</span>

    /**
     * This is the name of the property that can point to other properties file for including other properties files.
     * &lt;p&gt;
     * If the file is absent, processing continues normally.
     * &lt;/p&gt;
     */
<span class="fc" id="L1024">    private static String includeOptional = &quot;includeoptional&quot;;</span>

    /** The list of possible key/value separators */
<span class="fc" id="L1027">    private static final char[] SEPARATORS = {'=', ':'};</span>

    /** The white space characters used as key/value separators. */
<span class="fc" id="L1030">    private static final char[] WHITE_SPACE = {' ', '\t', '\f'};</span>

    /** Constant for the platform specific line separator. */
<span class="fc" id="L1033">    private static final String LINE_SEPARATOR = System.lineSeparator();</span>

    /** Constant for the radix of hex numbers. */
    private static final int HEX_RADIX = 16;

    /** Constant for the length of a unicode literal. */
    private static final int UNICODE_LEN = 4;

    /**
     * Returns the number of trailing backslashes. This is sometimes needed for the correct handling of escape characters.
     *
     * @param line the string to investigate
     * @return the number of trailing backslashes
     */
    private static int countTrailingBS(final String line) {
<span class="fc" id="L1048">        int bsCount = 0;</span>
<span class="pc bpc" id="L1049" title="1 of 4 branches missed.">        for (int idx = line.length() - 1; idx &gt;= 0 &amp;&amp; line.charAt(idx) == '\\'; idx--) {</span>
<span class="fc" id="L1050">            bsCount++;</span>
        }

<span class="fc" id="L1053">        return bsCount;</span>
    }

    /**
     * Gets the property value for including other properties files. By default it is &quot;include&quot;.
     *
     * @return A String.
     */
    public static String getInclude() {
<span class="fc" id="L1062">        return include;</span>
    }

    /**
     * Gets the property value for including other properties files. By default it is &quot;includeoptional&quot;.
     * &lt;p&gt;
     * If the file is absent, processing continues normally.
     * &lt;/p&gt;
     *
     * @return A String.
     * @since 2.5
     */
    public static String getIncludeOptional() {
<span class="fc" id="L1075">        return includeOptional;</span>
    }

    /**
     * Tests whether a line is a comment, i.e. whether it starts with a comment character.
     *
     * @param line the line
     * @return a flag if this is a comment line
     * @since 1.3
     */
    static boolean isCommentLine(final String line) {
<span class="fc" id="L1086">        final String s = line.trim();</span>
        // blank lines are also treated as comment lines
<span class="fc bfc" id="L1088" title="All 4 branches covered.">        return s.isEmpty() || COMMENT_CHARS.indexOf(s.charAt(0)) &gt;= 0;</span>
    }

    /**
     * Checks whether the specified character needs to be unescaped. This method is called when during reading a property
     * file an escape character ('\') is detected. If the character following the escape character is recognized as a
     * special character which is escaped per default in a Java properties file, it has to be unescaped.
     *
     * @param ch the character in question
     * @return a flag whether this character has to be unescaped
     */
    private static boolean needsUnescape(final char ch) {
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        return UNESCAPE_CHARACTERS.indexOf(ch) &gt;= 0;</span>
    }

    /**
     * Sets the property value for including other properties files. By default it is &quot;include&quot;.
     *
     * @param inc A String.
     */
    public static void setInclude(final String inc) {
<span class="fc" id="L1109">        include = inc;</span>
<span class="fc" id="L1110">    }</span>

    /**
     * Sets the property value for including other properties files. By default it is &quot;include&quot;.
     * &lt;p&gt;
     * If the file is absent, processing continues normally.
     * &lt;/p&gt;
     *
     * @param inc A String.
     * @since 2.5
     */
    public static void setIncludeOptional(final String inc) {
<span class="nc" id="L1122">        includeOptional = inc;</span>
<span class="nc" id="L1123">    }</span>

    /**
     * &lt;p&gt;
     * Unescapes any Java literals found in the {@code String} to a {@code Writer}.
     * &lt;/p&gt;
     * This is a slightly modified version of the StringEscapeUtils.unescapeJava() function in commons-lang that doesn't
     * drop escaped separators (i.e '\,').
     *
     * @param str the {@code String} to unescape, may be null
     * @return the processed string
     * @throws IllegalArgumentException if the Writer is {@code null}
     */
    protected static String unescapeJava(final String str) {
<span class="fc" id="L1137">        return unescapeJava(str, false);</span>
    }

    /**
     * Unescapes Java literals found in the {@code String} to a {@code Writer}.
     * &lt;p&gt;
     * When the parameter {@code jupCompatible} is {@code false}, the classic behavior is used (see
     * {@link #unescapeJava(String)}). When it's {@code true} a slightly different behavior that's compatible with
     * {@link java.util.Properties} is used (see {@link JupIOFactory}).
     * &lt;/p&gt;
     *
     * @param str the {@code String} to unescape, may be null
     * @param jupCompatible whether unescaping is compatible with {@link java.util.Properties}; otherwise the classic
     *        behavior is used
     * @return the processed string
     * @throws IllegalArgumentException if the Writer is {@code null}
     */
    protected static String unescapeJava(final String str, final boolean jupCompatible) {
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1156">            return null;</span>
        }
<span class="fc" id="L1158">        final int sz = str.length();</span>
<span class="fc" id="L1159">        final StringBuilder out = new StringBuilder(sz);</span>
<span class="fc" id="L1160">        final StringBuilder unicode = new StringBuilder(UNICODE_LEN);</span>
<span class="fc" id="L1161">        boolean hadSlash = false;</span>
<span class="fc" id="L1162">        boolean inUnicode = false;</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc" id="L1164">            final char ch = str.charAt(i);</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">            if (inUnicode) {</span>
                // if in unicode, then we're reading unicode
                // values in somehow
<span class="fc" id="L1168">                unicode.append(ch);</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">                if (unicode.length() == UNICODE_LEN) {</span>
                    // unicode now contains the four hex digits
                    // which represents our unicode character
                    try {
<span class="fc" id="L1173">                        final int value = Integer.parseInt(unicode.toString(), HEX_RADIX);</span>
<span class="fc" id="L1174">                        out.append((char) value);</span>
<span class="fc" id="L1175">                        unicode.setLength(0);</span>
<span class="fc" id="L1176">                        inUnicode = false;</span>
<span class="fc" id="L1177">                        hadSlash = false;</span>
<span class="nc" id="L1178">                    } catch (final NumberFormatException nfe) {</span>
<span class="nc" id="L1179">                        throw new ConfigurationRuntimeException(&quot;Unable to parse unicode value: &quot; + unicode, nfe);</span>
<span class="fc" id="L1180">                    }</span>
                }
                continue;
            }

<span class="fc bfc" id="L1185" title="All 2 branches covered.">            if (hadSlash) {</span>
                // handle an escaped value
<span class="fc" id="L1187">                hadSlash = false;</span>

<span class="pc bpc" id="L1189" title="2 of 5 branches missed.">                switch (ch) {</span>
                case 'r':
<span class="nc" id="L1191">                    out.append('\r');</span>
<span class="nc" id="L1192">                    break;</span>
                case 'f':
<span class="nc" id="L1194">                    out.append('\f');</span>
<span class="nc" id="L1195">                    break;</span>
                case 't':
<span class="fc" id="L1197">                    out.append('\t');</span>
<span class="fc" id="L1198">                    break;</span>
                case 'n':
<span class="fc" id="L1200">                    out.append('\n');</span>
<span class="fc" id="L1201">                    break;</span>
                default:
<span class="pc bpc" id="L1203" title="1 of 4 branches missed.">                    if (!jupCompatible &amp;&amp; ch == 'b') {</span>
<span class="nc" id="L1204">                        out.append('\b');</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">                    } else if (ch == 'u') {</span>
                        // uh-oh, we're in unicode country....
<span class="fc" id="L1207">                        inUnicode = true;</span>
                    } else {
                        // JUP simply throws away the \ of unknown escape sequences
<span class="fc bfc" id="L1210" title="All 4 branches covered.">                        if (!needsUnescape(ch) &amp;&amp; !jupCompatible) {</span>
<span class="fc" id="L1211">                            out.append('\\');</span>
                        }
<span class="fc" id="L1213">                        out.append(ch);</span>
                    }
<span class="fc" id="L1215">                    break;</span>
                }

                continue;
            }
<span class="fc bfc" id="L1220" title="All 2 branches covered.">            if (ch == '\\') {</span>
<span class="fc" id="L1221">                hadSlash = true;</span>
<span class="fc" id="L1222">                continue;</span>
            }
<span class="fc" id="L1224">            out.append(ch);</span>
        }

<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">        if (hadSlash) {</span>
            // then we're in the weird case of a \ at the end of the
            // string, let's output it anyway.
<span class="nc" id="L1230">            out.append('\\');</span>
        }

<span class="fc" id="L1233">        return out.toString();</span>
    }

    /** Stores the layout object. */
    private PropertiesConfigurationLayout layout;

    /** The include listener for the special {@code &quot;include&quot;} key. */
    private ConfigurationConsumer&lt;ConfigurationException&gt; includeListener;

    /** The IOFactory for creating readers and writers. */
    private IOFactory ioFactory;

    /** The current {@code FileLocator}. */
    private FileLocator locator;

    /** Allow file inclusion or not */
<span class="fc" id="L1249">    private boolean includesAllowed = true;</span>

    /**
     * Creates an empty PropertyConfiguration object which can be used to synthesize a new Properties file by adding values
     * and then saving().
     */
<span class="fc" id="L1255">    public PropertiesConfiguration() {</span>
<span class="fc" id="L1256">        installLayout(createLayout());</span>
<span class="fc" id="L1257">    }</span>

    /**
     * Creates a copy of this object.
     *
     * @return the copy
     */
    @Override
    public Object clone() {
<span class="fc" id="L1266">        final PropertiesConfiguration copy = (PropertiesConfiguration) super.clone();</span>
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">        if (layout != null) {</span>
<span class="fc" id="L1268">            copy.setLayout(new PropertiesConfigurationLayout(layout));</span>
        }
<span class="fc" id="L1270">        return copy;</span>
    }

    /**
     * Creates a standard layout object. This configuration is initialized with such a standard layout.
     *
     * @return the newly created layout object
     */
    private PropertiesConfigurationLayout createLayout() {
<span class="fc" id="L1279">        return new PropertiesConfigurationLayout();</span>
    }

    /**
     * Gets the footer comment. This is a comment at the very end of the file.
     *
     * @return the footer comment
     * @since 2.0
     */
    public String getFooter() {
<span class="fc" id="L1289">        beginRead(false);</span>
        try {
<span class="fc" id="L1291">            return getLayout().getFooterComment();</span>
        } finally {
<span class="fc" id="L1293">            endRead();</span>
        }
    }

    /**
     * Gets the comment header.
     *
     * @return the comment header
     * @since 1.1
     */
    public String getHeader() {
<span class="fc" id="L1304">        beginRead(false);</span>
        try {
<span class="fc" id="L1306">            return getLayout().getHeaderComment();</span>
        } finally {
<span class="fc" id="L1308">            endRead();</span>
        }
    }

    /**
     * Gets the current include listener, never null.
     *
     * @return the current include listener, never null.
     * @since 2.6
     */
    public ConfigurationConsumer&lt;ConfigurationException&gt; getIncludeListener() {
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        return includeListener != null ? includeListener : DEFAULT_INCLUDE_LISTENER;</span>
    }

    /**
     * Gets the {@code IOFactory} to be used for creating readers and writers when loading or saving this configuration.
     *
     * @return the {@code IOFactory}
     * @since 1.7
     */
    public IOFactory getIOFactory() {
<span class="fc bfc" id="L1329" title="All 2 branches covered.">        return ioFactory != null ? ioFactory : DefaultIOFactory.INSTANCE;</span>
    }

    /**
     * Gets the associated layout object.
     *
     * @return the associated layout object
     * @since 1.3
     */
    public PropertiesConfigurationLayout getLayout() {
<span class="fc" id="L1339">        return layout;</span>
    }

    /**
     * Stores the current {@code FileLocator} for a following IO operation. The {@code FileLocator} is needed to resolve
     * include files with relative file names.
     *
     * @param locator the current {@code FileLocator}
     * @since 2.0
     */
    @Override
    public void initFileLocator(final FileLocator locator) {
<span class="fc" id="L1351">        this.locator = locator;</span>
<span class="fc" id="L1352">    }</span>

    /**
     * Installs a layout object. It has to be ensured that the layout is registered as change listener at this
     * configuration. If there is already a layout object installed, it has to be removed properly.
     *
     * @param layout the layout object to be installed
     */
    private void installLayout(final PropertiesConfigurationLayout layout) {
        // only one layout must exist
<span class="fc bfc" id="L1362" title="All 2 branches covered.">        if (this.layout != null) {</span>
<span class="fc" id="L1363">            removeEventListener(ConfigurationEvent.ANY, this.layout);</span>
        }

<span class="fc bfc" id="L1366" title="All 2 branches covered.">        if (layout == null) {</span>
<span class="fc" id="L1367">            this.layout = createLayout();</span>
        } else {
<span class="fc" id="L1369">            this.layout = layout;</span>
        }
<span class="fc" id="L1371">        addEventListener(ConfigurationEvent.ANY, this.layout);</span>
<span class="fc" id="L1372">    }</span>

    /**
     * Reports the status of file inclusion.
     *
     * @return True if include files are loaded.
     */
    public boolean isIncludesAllowed() {
<span class="fc" id="L1380">        return this.includesAllowed;</span>
    }

    /**
     * Helper method for loading an included properties file. This method is called by {@code load()} when an
     * {@code include} property is encountered. It tries to resolve relative file names based on the current base path. If
     * this fails, a resolution based on the location of this properties file is tried.
     *
     * @param fileName the name of the file to load
     * @param optional whether or not the {@code fileName} is optional
     * @param seenStack Stack of seen include URLs
     * @throws ConfigurationException if loading fails
     */
    private void loadIncludeFile(final String fileName, final boolean optional, final Deque&lt;URL&gt; seenStack) throws ConfigurationException {
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        if (locator == null) {</span>
<span class="fc" id="L1395">            throw new ConfigurationException(</span>
                &quot;Load operation not properly &quot; + &quot;initialized! Do not call read(InputStream) directly,&quot; + &quot; but use a FileHandler to load a configuration.&quot;);
        }

<span class="fc" id="L1399">        URL url = locateIncludeFile(locator.getBasePath(), fileName);</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        if (url == null) {</span>
<span class="fc" id="L1401">            final URL baseURL = locator.getSourceURL();</span>
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">            if (baseURL != null) {</span>
<span class="fc" id="L1403">                url = locateIncludeFile(baseURL.toString(), fileName);</span>
            }
        }

<span class="fc bfc" id="L1407" title="All 4 branches covered.">        if (optional &amp;&amp; url == null) {</span>
<span class="fc" id="L1408">            return;</span>
        }

<span class="fc bfc" id="L1411" title="All 2 branches covered.">        if (url == null) {</span>
<span class="fc" id="L1412">            getIncludeListener().accept(new ConfigurationException(&quot;Cannot resolve include file &quot; + fileName, new FileNotFoundException(fileName)));</span>
        } else {
<span class="fc" id="L1414">            final FileHandler fh = new FileHandler(this);</span>
<span class="fc" id="L1415">            fh.setFileLocator(locator);</span>
<span class="fc" id="L1416">            final FileLocator orgLocator = locator;</span>
            try {
                try {
                    // Check for cycles
<span class="fc bfc" id="L1420" title="All 2 branches covered.">                    if (seenStack.contains(url)) {</span>
<span class="fc" id="L1421">                        throw new ConfigurationException(String.format(&quot;Cycle detected loading %s, seen stack: %s&quot;, url, seenStack));</span>
                    }
<span class="fc" id="L1423">                    seenStack.add(url);</span>
                    try {
<span class="fc" id="L1425">                        fh.load(url);</span>
                    } finally {
<span class="fc" id="L1427">                        seenStack.pop();</span>
                    }
<span class="fc" id="L1429">                } catch (final ConfigurationException e) {</span>
<span class="fc" id="L1430">                    getIncludeListener().accept(e);</span>
<span class="fc" id="L1431">                }</span>
            } finally {
<span class="fc" id="L1433">                locator = orgLocator; // reset locator which is changed by load</span>
            }
        }
<span class="fc" id="L1436">    }</span>

    /**
     * Tries to obtain the URL of an include file using the specified (optional) base path and file name.
     *
     * @param basePath the base path
     * @param fileName the file name
     * @return the URL of the include file or &lt;b&gt;null&lt;/b&gt; if it cannot be resolved
     */
    private URL locateIncludeFile(final String basePath, final String fileName) {
<span class="fc" id="L1446">        final FileLocator includeLocator = FileLocatorUtils.fileLocator(locator).sourceURL(null).basePath(basePath).fileName(fileName).create();</span>
<span class="fc" id="L1447">        return FileLocatorUtils.locate(includeLocator);</span>
    }

    /**
     * This method is invoked by the associated {@link PropertiesConfigurationLayout} object for each property definition
     * detected in the parsed properties file. Its task is to check whether this is a special property definition (e.g. the
     * {@code include} property). If not, the property must be added to this configuration. The return value indicates
     * whether the property should be treated as a normal property. If it is &lt;b&gt;false&lt;/b&gt;, the layout object will ignore
     * this property.
     *
     * @param key the property key
     * @param value the property value
     * @param seenStack the stack of seen include URLs
     * @return a flag whether this is a normal property
     * @throws ConfigurationException if an error occurs
     * @since 1.3
     */
    boolean propertyLoaded(final String key, final String value, final Deque&lt;URL&gt; seenStack) throws ConfigurationException {
        final boolean result;

<span class="pc bpc" id="L1467" title="1 of 4 branches missed.">        if (StringUtils.isNotEmpty(getInclude()) &amp;&amp; key.equalsIgnoreCase(getInclude())) {</span>
<span class="fc bfc" id="L1468" title="All 2 branches covered.">            if (isIncludesAllowed()) {</span>
<span class="fc" id="L1469">                final Collection&lt;String&gt; files = getListDelimiterHandler().split(value, true);</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">                for (final String f : files) {</span>
<span class="fc" id="L1471">                    loadIncludeFile(interpolate(f), false, seenStack);</span>
<span class="fc" id="L1472">                }</span>
            }
<span class="fc" id="L1474">            result = false;</span>
<span class="pc bpc" id="L1475" title="1 of 4 branches missed.">        } else if (StringUtils.isNotEmpty(getIncludeOptional()) &amp;&amp; key.equalsIgnoreCase(getIncludeOptional())) {</span>
<span class="pc bpc" id="L1476" title="1 of 2 branches missed.">            if (isIncludesAllowed()) {</span>
<span class="fc" id="L1477">                final Collection&lt;String&gt; files = getListDelimiterHandler().split(value, true);</span>
<span class="fc bfc" id="L1478" title="All 2 branches covered.">                for (final String f : files) {</span>
<span class="fc" id="L1479">                    loadIncludeFile(interpolate(f), true, seenStack);</span>
<span class="fc" id="L1480">                }</span>
            }
<span class="fc" id="L1482">            result = false;</span>
        } else {
<span class="fc" id="L1484">            addPropertyInternal(key, value);</span>
<span class="fc" id="L1485">            result = true;</span>
        }

<span class="fc" id="L1488">        return result;</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to the associated layout object which does the actual loading. Note that
     * this method does not do any synchronization. This lies in the responsibility of the caller. (Typically, the caller is
     * a {@code FileHandler} object which takes care for proper synchronization.)
     *
     * @since 2.0
     */
    @Override
    public void read(final Reader in) throws ConfigurationException, IOException {
<span class="fc" id="L1500">        getLayout().load(this, in);</span>
<span class="fc" id="L1501">    }</span>

    /**
     * Sets the footer comment. If set, this comment is written after all properties at the end of the file.
     *
     * @param footer the footer comment
     * @since 2.0
     */
    public void setFooter(final String footer) {
<span class="fc" id="L1510">        beginWrite(false);</span>
        try {
<span class="fc" id="L1512">            getLayout().setFooterComment(footer);</span>
        } finally {
<span class="fc" id="L1514">            endWrite();</span>
        }
<span class="fc" id="L1516">    }</span>

    /**
     * Sets the comment header.
     *
     * @param header the header to use
     * @since 1.1
     */
    public void setHeader(final String header) {
<span class="fc" id="L1525">        beginWrite(false);</span>
        try {
<span class="fc" id="L1527">            getLayout().setHeaderComment(header);</span>
        } finally {
<span class="fc" id="L1529">            endWrite();</span>
        }
<span class="fc" id="L1531">    }</span>

    /**
     * Sets the current include listener, may not be null.
     *
     * @param includeListener the current include listener, may not be null.
     * @throws IllegalArgumentException if the {@code includeListener} is null.
     * @since 2.6
     */
    public void setIncludeListener(final ConfigurationConsumer&lt;ConfigurationException&gt; includeListener) {
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">        if (includeListener == null) {</span>
<span class="nc" id="L1542">            throw new IllegalArgumentException(&quot;includeListener must not be null.&quot;);</span>
        }
<span class="fc" id="L1544">        this.includeListener = includeListener;</span>
<span class="fc" id="L1545">    }</span>

    /**
     * Controls whether additional files can be loaded by the {@code include = &lt;xxx&gt;} statement or not. This is &lt;b&gt;true&lt;/b&gt;
     * per default.
     *
     * @param includesAllowed True if Includes are allowed.
     */
    public void setIncludesAllowed(final boolean includesAllowed) {
<span class="fc" id="L1554">        this.includesAllowed = includesAllowed;</span>
<span class="fc" id="L1555">    }</span>

    /**
     * Sets the {@code IOFactory} to be used for creating readers and writers when loading or saving this configuration.
     * Using this method a client can customize the reader and writer classes used by the load and save operations. Note
     * that this method must be called before invoking one of the {@code load()} and {@code save()} methods. Especially, if
     * you want to use a custom {@code IOFactory} for changing the {@code PropertiesReader}, you cannot load the
     * configuration data in the constructor.
     *
     * @param ioFactory the new {@code IOFactory} (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the {@code IOFactory} is &lt;b&gt;null&lt;/b&gt;
     * @since 1.7
     */
    public void setIOFactory(final IOFactory ioFactory) {
<span class="fc bfc" id="L1569" title="All 2 branches covered.">        if (ioFactory == null) {</span>
<span class="fc" id="L1570">            throw new IllegalArgumentException(&quot;IOFactory must not be null.&quot;);</span>
        }

<span class="fc" id="L1573">        this.ioFactory = ioFactory;</span>
<span class="fc" id="L1574">    }</span>

    /**
     * Sets the associated layout object.
     *
     * @param layout the new layout object; can be &lt;b&gt;null&lt;/b&gt;, then a new layout object will be created
     * @since 1.3
     */
    public void setLayout(final PropertiesConfigurationLayout layout) {
<span class="fc" id="L1583">        installLayout(layout);</span>
<span class="fc" id="L1584">    }</span>

    /**
     * {@inheritDoc} This implementation delegates to the associated layout object which does the actual saving. Note that,
     * analogous to {@link #read(Reader)}, this method does not do any synchronization.
     *
     * @since 2.0
     */
    @Override
    public void write(final Writer out) throws ConfigurationException, IOException {
<span class="fc" id="L1594">        getLayout().save(this, out);</span>
<span class="fc" id="L1595">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>