<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">AbstractConfiguration.java</span></div><h1>AbstractConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.configuration2;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

import org.apache.commons.configuration2.convert.ConversionHandler;
import org.apache.commons.configuration2.convert.DefaultConversionHandler;
import org.apache.commons.configuration2.convert.DisabledListDelimiterHandler;
import org.apache.commons.configuration2.convert.ListDelimiterHandler;
import org.apache.commons.configuration2.event.BaseEventSource;
import org.apache.commons.configuration2.event.ConfigurationErrorEvent;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.ex.ConversionException;
import org.apache.commons.configuration2.interpol.ConfigurationInterpolator;
import org.apache.commons.configuration2.interpol.InterpolatorSpecification;
import org.apache.commons.configuration2.interpol.Lookup;
import org.apache.commons.configuration2.io.ConfigurationLogger;
import org.apache.commons.configuration2.sync.LockMode;
import org.apache.commons.configuration2.sync.NoOpSynchronizer;
import org.apache.commons.configuration2.sync.Synchronizer;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;

/**
 * &lt;p&gt;
 * Abstract configuration class. Provides basic functionality but does not store any data.
 * &lt;/p&gt;
 * &lt;p&gt;
 * If you want to write your own Configuration class then you should implement only abstract methods from this class. A
 * lot of functionality needed by typical implementations of the {@code Configuration} interface is already provided by
 * this base class. Following is a list of features implemented here:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Data conversion support. The various data types required by the {@code Configuration} interface are already
 * handled by this base class. A concrete sub class only needs to provide a generic {@code getProperty()} method.&lt;/li&gt;
 * &lt;li&gt;Support for variable interpolation. Property values containing special variable tokens (like {@code ${var}}) will
 * be replaced by their corresponding values.&lt;/li&gt;
 * &lt;li&gt;Optional support for string lists. The values of properties to be added to this configuration are checked whether
 * they contain a list delimiter character. If this is the case and if list splitting is enabled, the string is split
 * and multiple values are added for this property. List splitting is controlled by a {@link ListDelimiterHandler}
 * object which can be set using the {@link #setListDelimiterHandler(ListDelimiterHandler)} method. It is disabled per
 * default. To enable this feature, set a suitable {@code ListDelimiterHandler}, e.g. an instance of
 * {@link org.apache.commons.configuration2.convert.DefaultListDelimiterHandler DefaultListDelimiterHandler} configured
 * with the desired list delimiter character.&lt;/li&gt;
 * &lt;li&gt;Allows specifying how missing properties are treated. Per default the get methods returning an object will return
 * &lt;b&gt;null&lt;/b&gt; if the searched property key is not found (and no default value is provided). With the
 * {@code setThrowExceptionOnMissing()} method this behavior can be changed to throw an exception when a requested
 * property cannot be found.&lt;/li&gt;
 * &lt;li&gt;Basic event support. Whenever this configuration is modified registered event listeners are notified. Refer to
 * the various {@code EVENT_XXX} constants to get an impression about which event types are supported.&lt;/li&gt;
 * &lt;li&gt;Support for proper synchronization based on the {@link Synchronizer} interface.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Most methods defined by the {@code Configuration} interface are already implemented in this class. Many method
 * implementations perform basic book-keeping tasks (e.g. firing events, handling synchronization), and then delegate to
 * other (protected) methods executing the actual work. Subclasses override these protected methods to define or adapt
 * behavior. The public entry point methods are final to prevent subclasses from breaking basic functionality.
 * &lt;/p&gt;
 */
public abstract class AbstractConfiguration extends BaseEventSource implements Configuration {

    /**
     * Checks an object provided as default value for the {@code getArray()} method. Throws an exception if this is not an
     * array with the correct component type.
     *
     * @param cls the component class for the array
     * @param defaultValue the default value object to be checked
     * @throws IllegalArgumentException if this is not a valid default object
     */
    private static void checkDefaultValueArray(final Class&lt;?&gt; cls, final Object defaultValue) {
<span class="fc bfc" id="L104" title="All 6 branches covered.">        if (defaultValue != null &amp;&amp; (!defaultValue.getClass().isArray() || !cls.isAssignableFrom(defaultValue.getClass().getComponentType()))) {</span>
<span class="fc" id="L105">            throw new IllegalArgumentException(</span>
<span class="fc" id="L106">                &quot;The type of the default value (&quot; + defaultValue.getClass() + &quot;)&quot; + &quot; is not an array of the specified class (&quot; + cls + &quot;)&quot;);</span>
        }
<span class="fc" id="L108">    }</span>

    /**
     * Checks whether the specified value is &lt;b&gt;null&lt;/b&gt; and throws an exception in this case. This method is used by
     * conversion methods returning primitive Java types. Here values to be returned must not be &lt;b&gt;null&lt;/b&gt;.
     *
     * @param &lt;T&gt; the type of the object to be checked
     * @param key the key which caused the problem
     * @param value the value to be checked
     * @return the passed in value for chaining this method call
     * @throws NoSuchElementException if the value is &lt;b&gt;null&lt;/b&gt;
     */
    private static &lt;T&gt; T checkNonNullValue(final String key, final T value) {
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (value == null) {</span>
<span class="nc" id="L122">            throwMissingPropertyException(key);</span>
        }
<span class="fc" id="L124">        return value;</span>
    }

    /**
     * Finds a {@code ConfigurationLookup} pointing to the specified configuration in the default lookups for the specified
     * {@code ConfigurationInterpolator}.
     *
     * @param ci the {@code ConfigurationInterpolator} in question
     * @param targetConf the target configuration of the searched lookup
     * @return the found {@code Lookup} object or &lt;b&gt;null&lt;/b&gt;
     */
    private static Lookup findConfigurationLookup(final ConfigurationInterpolator ci, final ImmutableConfiguration targetConf) {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (final Lookup l : ci.getDefaultLookups()) {</span>
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">            if (l instanceof ConfigurationLookup &amp;&amp; targetConf == ((ConfigurationLookup) l).getConfiguration()) {</span>
<span class="fc" id="L138">                return l;</span>
            }
<span class="nc" id="L140">        }</span>
<span class="fc" id="L141">        return null;</span>
    }

    /**
     * Handles the default collection for a collection conversion. This method fills the target collection with the content
     * of the default collection. Both collections may be &lt;b&gt;null&lt;/b&gt;.
     *
     * @param target the target collection
     * @param defaultValue the default collection
     * @return the initialized target collection
     */
    private static &lt;T&gt; Collection&lt;T&gt; handleDefaultCollection(final Collection&lt;T&gt; target, final Collection&lt;T&gt; defaultValue) {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (defaultValue == null) {</span>
<span class="fc" id="L154">            return null;</span>
        }

        final Collection&lt;T&gt; result;
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (target == null) {</span>
<span class="fc" id="L159">            result = new ArrayList&lt;&gt;(defaultValue);</span>
        } else {
<span class="fc" id="L161">            target.addAll(defaultValue);</span>
<span class="fc" id="L162">            result = target;</span>
        }
<span class="fc" id="L164">        return result;</span>
    }

    /**
     * Helper method for throwing an exception for a key that does not map to an existing object.
     *
     * @param key the key (to be part of the error message)
     */
    private static void throwMissingPropertyException(final String key) {
<span class="fc" id="L173">        throw new NoSuchElementException(String.format(&quot;Key '%s' does not map to an existing object!&quot;, key));</span>
    }

    /** The list delimiter handler. */
    private ListDelimiterHandler listDelimiterHandler;

    /** The conversion handler. */
    private ConversionHandler conversionHandler;

    /**
     * Whether the configuration should throw NoSuchElementExceptions or simply return null when a property does not exist.
     * Defaults to return null.
     */
    private boolean throwExceptionOnMissing;

    /** Stores a reference to the object that handles variable interpolation. */
    private AtomicReference&lt;ConfigurationInterpolator&gt; interpolator;

    /** The object responsible for synchronization. */
    private volatile Synchronizer synchronizer;

    /** The object used for dealing with encoded property values. */
    private ConfigurationDecoder configurationDecoder;

    /** Stores the logger. */
    private ConfigurationLogger log;

    /**
     * Creates a new instance of {@code AbstractConfiguration}.
     */
<span class="fc" id="L203">    public AbstractConfiguration() {</span>
<span class="fc" id="L204">        interpolator = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L205">        initLogger(null);</span>
<span class="fc" id="L206">        installDefaultInterpolator();</span>
<span class="fc" id="L207">        listDelimiterHandler = DisabledListDelimiterHandler.INSTANCE;</span>
<span class="fc" id="L208">        conversionHandler = DefaultConversionHandler.INSTANCE;</span>
<span class="fc" id="L209">    }</span>

    /**
     * Adds a special {@link EventListener} object to this configuration that will log all internal errors. This method is
     * intended to be used by certain derived classes, for which it is known that they can fail on property access (e.g.
     * {@code DatabaseConfiguration}).
     *
     * @since 1.4
     */
    public final void addErrorLogListener() {
<span class="pc" id="L219">        addEventListener(ConfigurationErrorEvent.ANY, event -&gt; getLogger().warn(&quot;Internal error&quot;, event.getCause()));</span>
<span class="fc" id="L220">    }</span>

    @Override
    public final void addProperty(final String key, final Object value) {
<span class="fc" id="L224">        beginWrite(false);</span>
        try {
<span class="fc" id="L226">            fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, true);</span>
<span class="fc" id="L227">            addPropertyInternal(key, value);</span>
<span class="fc" id="L228">            fireEvent(ConfigurationEvent.ADD_PROPERTY, key, value, false);</span>
        } finally {
<span class="fc" id="L230">            endWrite();</span>
        }
<span class="fc" id="L232">    }</span>

    /**
     * Adds a key/value pair to the Configuration. Override this method to provide write access to underlying Configuration
     * store.
     *
     * @param key key to use for mapping
     * @param value object to store
     */
    protected abstract void addPropertyDirect(String key, Object value);

    /**
     * Actually adds a property to this configuration. This method is called by {@code addProperty()}. It performs list
     * splitting if necessary and delegates to {@link #addPropertyDirect(String, Object)} for every single property value.
     *
     * @param key the key of the property to be added
     * @param value the new property value
     * @since 2.0
     */
    protected void addPropertyInternal(final String key, final Object value) {
<span class="fc" id="L252">        getListDelimiterHandler().parse(value).forEach(obj -&gt; addPropertyDirect(key, obj));</span>
<span class="fc" id="L253">    }</span>

    /**
     * Appends the content of the specified configuration to this configuration. The values of all properties contained in
     * the specified configuration will be appended to this configuration. So if a property is already present in this
     * configuration, its new value will be a union of the values in both configurations. &lt;em&gt;Note:&lt;/em&gt; This method won't
     * work well when appending hierarchical configurations because it is not able to copy information about the properties'
     * structure (i.e. the parent-child-relationships will get lost). So when dealing with hierarchical configuration
     * objects their {@link BaseHierarchicalConfiguration#clone() clone()} methods should be used.
     *
     * @param c the configuration to be appended (can be &lt;b&gt;null&lt;/b&gt;, then this operation will have no effect)
     * @since 1.5
     */
    public void append(final Configuration c) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (c != null) {</span>
<span class="fc" id="L268">            c.lock(LockMode.READ);</span>
            try {
<span class="fc" id="L270">                c.getKeys().forEachRemaining(key -&gt; addProperty(key, encodeForCopy(c.getProperty(key))));</span>
            } finally {
<span class="fc" id="L272">                c.unlock(LockMode.READ);</span>
            }
        }
<span class="fc" id="L275">    }</span>

    /**
     * Notifies this configuration's {@link Synchronizer} that a read operation is about to start. This method is called by
     * all methods which access this configuration in a read-only mode. Subclasses may override it to perform additional
     * actions before this read operation. The boolean &lt;em&gt;optimize&lt;/em&gt; argument can be evaluated by overridden methods in
     * derived classes. Some operations which require a lock do not need a fully initialized configuration object. By
     * setting this flag to &lt;strong&gt;true&lt;/strong&gt;, such operations can give a corresponding hint. An overridden
     * implementation of {@code beginRead()} can then decide to skip some initialization steps. All basic operations in this
     * class (and most of the basic {@code Configuration} implementations) call this method with a parameter value of
     * &lt;strong&gt;false&lt;/strong&gt;. &lt;strong&gt;In any case the inherited method must be called! Otherwise, proper synchronization is
     * not guaranteed.&lt;/strong&gt;
     *
     * @param optimize a flag whether optimization can be performed
     * @since 2.0
     */
    protected void beginRead(final boolean optimize) {
<span class="fc" id="L292">        getSynchronizer().beginRead();</span>
<span class="fc" id="L293">    }</span>

    /**
     * Notifies this configuration's {@link Synchronizer} that an update operation is about to start. This method is called
     * by all methods which modify this configuration. Subclasses may override it to perform additional operations before an
     * update. For a description of the boolean &lt;em&gt;optimize&lt;/em&gt; argument refer to the documentation of
     * {@code beginRead()}. &lt;strong&gt;In any case the inherited method must be called! Otherwise, proper synchronization is
     * not guaranteed.&lt;/strong&gt;
     *
     * @param optimize a flag whether optimization can be performed
     * @see #beginRead(boolean)
     * @since 2.0
     */
    protected void beginWrite(final boolean optimize) {
<span class="fc" id="L307">        getSynchronizer().beginWrite();</span>
<span class="fc" id="L308">    }</span>

    @Override
    public final void clear() {
<span class="fc" id="L312">        beginWrite(false);</span>
        try {
<span class="fc" id="L314">            fireEvent(ConfigurationEvent.CLEAR, null, null, true);</span>
<span class="fc" id="L315">            clearInternal();</span>
<span class="fc" id="L316">            fireEvent(ConfigurationEvent.CLEAR, null, null, false);</span>
        } finally {
<span class="fc" id="L318">            endWrite();</span>
        }
<span class="fc" id="L320">    }</span>

    /**
     * Clears the whole configuration. This method is called by {@code clear()} after some preparations have been made. This
     * base implementation uses the iterator provided by {@code getKeys()} to remove every single property. Subclasses
     * should override this method if there is a more efficient way of clearing the configuration.
     */
    protected void clearInternal() {
<span class="fc" id="L328">        setDetailEvents(false);</span>
<span class="fc" id="L329">        boolean useIterator = true;</span>
        try {
<span class="fc" id="L331">            final Iterator&lt;String&gt; it = getKeys();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L333">                final String key = it.next();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                if (useIterator) {</span>
                    try {
<span class="fc" id="L336">                        it.remove();</span>
<span class="fc" id="L337">                    } catch (final UnsupportedOperationException usoex) {</span>
<span class="fc" id="L338">                        useIterator = false;</span>
<span class="fc" id="L339">                    }</span>
                }

<span class="fc bfc" id="L342" title="All 4 branches covered.">                if (useIterator &amp;&amp; containsKey(key)) {</span>
<span class="fc" id="L343">                    useIterator = false;</span>
                }

<span class="fc bfc" id="L346" title="All 2 branches covered.">                if (!useIterator) {</span>
                    // workaround for Iterators that do not remove the
                    // property
                    // on calling remove() or do not support remove() at all
<span class="fc" id="L350">                    clearProperty(key);</span>
                }
<span class="fc" id="L352">            }</span>
        } finally {
<span class="fc" id="L354">            setDetailEvents(true);</span>
        }
<span class="fc" id="L356">    }</span>

    /**
     * Removes the specified property from this configuration. This implementation performs some preparations and then
     * delegates to {@code clearPropertyDirect()}, which will do the real work.
     *
     * @param key the key to be removed
     */
    @Override
    public final void clearProperty(final String key) {
<span class="fc" id="L366">        beginWrite(false);</span>
        try {
<span class="fc" id="L368">            fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, null, true);</span>
<span class="fc" id="L369">            clearPropertyDirect(key);</span>
<span class="fc" id="L370">            fireEvent(ConfigurationEvent.CLEAR_PROPERTY, key, null, false);</span>
        } finally {
<span class="fc" id="L372">            endWrite();</span>
        }
<span class="fc" id="L374">    }</span>

    /**
     * Removes the specified property from this configuration. This method is called by {@code clearProperty()} after it has
     * done some preparations. It must be overridden in sub classes.
     *
     * @param key the key to be removed
     */
    protected abstract void clearPropertyDirect(String key);

    /**
     * Creates a clone of the {@code ConfigurationInterpolator} used by this instance. This method can be called by
     * {@code clone()} implementations of derived classes. Normally, the {@code ConfigurationInterpolator} of a
     * configuration instance must not be shared with other instances because it contains a specific {@code Lookup} object
     * pointing to the owning configuration. This has to be taken into account when cloning a configuration. This method
     * creates a new {@code ConfigurationInterpolator} for this configuration instance which contains all lookup objects
     * from the original {@code ConfigurationInterpolator} except for the configuration specific lookup pointing to the
     * passed in original configuration. This one is replaced by a corresponding {@code Lookup} referring to this
     * configuration.
     *
     * @param orgConfig the original configuration from which this one was cloned
     * @since 2.0
     */
    protected void cloneInterpolator(final AbstractConfiguration orgConfig) {
<span class="fc" id="L398">        interpolator = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L399">        final ConfigurationInterpolator orgInterpolator = orgConfig.getInterpolator();</span>
<span class="fc" id="L400">        final List&lt;Lookup&gt; defaultLookups = orgInterpolator.getDefaultLookups();</span>
<span class="fc" id="L401">        final Lookup lookup = findConfigurationLookup(orgInterpolator, orgConfig);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (lookup != null) {</span>
<span class="fc" id="L403">            defaultLookups.remove(lookup);</span>
        }

<span class="fc" id="L406">        installInterpolator(orgInterpolator.getLookups(), defaultLookups);</span>
<span class="fc" id="L407">    }</span>

    /**
     * Checks if the specified value exists in the properties structure mapped by the provided keys.
     *
     * @param keys an Iterator of String keys to search for the value
     * @param value the String value to search for in the properties
     * @return true if the value is found in the properties, false otherwise
     * @since 2.11.0
     */
    protected boolean contains(final Iterator&lt;String&gt; keys, final Object value) {
<span class="fc bfc" id="L418" title="All 2 branches covered.">        while (keys.hasNext()) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (Objects.equals(value, getProperty(keys.next()))) {</span>
<span class="fc" id="L420">                return true;</span>
            }
        }
<span class="fc" id="L423">        return false;</span>
    }

    /**
     * {@inheritDoc} This implementation handles synchronization and delegates to {@code containsKeyInternal()}.
     */
    @Override
    public final boolean containsKey(final String key) {
<span class="fc" id="L431">        beginRead(false);</span>
        try {
<span class="fc" id="L433">            return containsKeyInternal(key);</span>
        } finally {
<span class="fc" id="L435">            endRead();</span>
        }
    }

    /**
     * Actually checks whether the specified key is contained in this configuration. This method is called by
     * {@code containsKey()}. It has to be defined by concrete subclasses.
     *
     * @param key the key in question
     * @return &lt;b&gt;true&lt;/b&gt; if this key is contained in this configuration, &lt;b&gt;false&lt;/b&gt; otherwise
     * @since 2.0
     */
    protected abstract boolean containsKeyInternal(String key);

    /**
     * {@inheritDoc} This implementation handles synchronization and delegates to {@code containsKeyInternal()}.
     * @since 2.11.0
     */
    @Override
    public final boolean containsValue(final Object value) {
<span class="fc" id="L455">        beginRead(false);</span>
        try {
<span class="fc" id="L457">            return containsValueInternal(value);</span>
        } finally {
<span class="fc" id="L459">            endRead();</span>
        }
    }

    /**
     * Tests whether this configuration contains one or more matches to this value. This operation stops at first match but may be more expensive than the
     * {@link #containsKeyInternal containsKey} method.
     * &lt;p&gt;
     * The implementation of this method will be different depending on the type of Configuration used.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Note that this method is identical in functionality to {@link #containsValue containsValue}, (which is part of the {@link ImmutableConfiguration}
     * interface).
     * &lt;/p&gt;
     *
     * @param value the value in question
     * @return {@code true} if and only if some key maps to the {@code value} argument in this configuration as determined by the {@code equals} method;
     *         {@code false} otherwise.
     * @since 2.11.0
     */
    protected abstract boolean containsValueInternal(Object value);

    /**
     * Helper method for obtaining a property value with a type conversion.
     *
     * @param &lt;T&gt; the target type of the conversion
     * @param cls the target class
     * @param key the key of the desired property
     * @param defValue a default value
     * @param throwOnMissing a flag whether an exception should be thrown for a missing value
     * @return the converted value
     */
    private &lt;T&gt; T convert(final Class&lt;T&gt; cls, final String key, final T defValue, final boolean throwOnMissing) {
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (cls.isArray()) {</span>
<span class="fc" id="L494">            return cls.cast(convertToArray(cls.getComponentType(), key, defValue));</span>
        }

<span class="fc" id="L497">        final T result = getAndConvertProperty(cls, key, defValue);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">            if (throwOnMissing &amp;&amp; isThrowExceptionOnMissing()) {</span>
<span class="nc" id="L500">                throwMissingPropertyException(key);</span>
            }
<span class="fc" id="L502">            return defValue;</span>
        }

<span class="fc" id="L505">        return result;</span>
    }

    /**
     * Performs a conversion to an array result class. This implementation delegates to the {@link ConversionHandler} to
     * perform the actual type conversion. If this results in a &lt;b&gt;null&lt;/b&gt; result (because the property is undefined), the
     * default value is returned. It is checked whether the default value is an array with the correct component type. If
     * not, an exception is thrown.
     *
     * @param cls the component class of the array
     * @param key the configuration key
     * @param defaultValue an optional default value
     * @return the converted array
     * @throws IllegalArgumentException if the default value is not a compatible array
     */
    private Object convertToArray(final Class&lt;?&gt; cls, final String key, final Object defaultValue) {
<span class="fc" id="L521">        checkDefaultValueArray(cls, defaultValue);</span>
<span class="fc" id="L522">        return ObjectUtils.defaultIfNull(getConversionHandler().toArray(getProperty(key), cls, getInterpolator()), defaultValue);</span>
    }

    /**
     * Copies the content of the specified configuration into this configuration. If the specified configuration contains a
     * key that is also present in this configuration, the value of this key will be replaced by the new value.
     * &lt;em&gt;Note:&lt;/em&gt; This method won't work well when copying hierarchical configurations because it is not able to copy
     * information about the properties' structure (i.e. the parent-child-relationships will get lost). So when dealing with
     * hierarchical configuration objects their {@link BaseHierarchicalConfiguration#clone() clone()} methods should be
     * used.
     *
     * @param c the configuration to copy (can be &lt;b&gt;null&lt;/b&gt;, then this operation will have no effect)
     * @since 1.5
     */
    public void copy(final Configuration c) {
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (c != null) {</span>
<span class="fc" id="L538">            c.lock(LockMode.READ);</span>
            try {
<span class="fc" id="L540">                c.getKeys().forEachRemaining(key -&gt; setProperty(key, encodeForCopy(c.getProperty(key))));</span>
            } finally {
<span class="fc" id="L542">                c.unlock(LockMode.READ);</span>
            }
        }
<span class="fc" id="L545">    }</span>

    /**
     * Encodes a property value so that it can be added to this configuration. This method deals with list delimiters. The
     * passed in object has to be escaped so that an add operation yields the same result. If it is a list, all of its
     * values have to be escaped.
     *
     * @param value the value to be encoded
     * @return the encoded value
     */
    private Object encodeForCopy(final Object value) {
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (value instanceof Collection) {</span>
<span class="fc" id="L557">            return encodeListForCopy((Collection&lt;?&gt;) value);</span>
        }
<span class="fc" id="L559">        return getListDelimiterHandler().escape(value, ListDelimiterHandler.NOOP_TRANSFORMER);</span>
    }

    /**
     * Encodes a list with property values so that it can be added to this configuration. This method calls
     * {@code encodeForCopy()} for all list elements.
     *
     * @param values the list to be encoded
     * @return a list with encoded elements
     */
    private Object encodeListForCopy(final Collection&lt;?&gt; values) {
<span class="fc" id="L570">        return values.stream().map(this::encodeForCopy).collect(Collectors.toList());</span>
    }

    /**
     * Notifies this configuration's {@link Synchronizer} that a read operation has finished. This method is called by all
     * methods which access this configuration in a read-only manner at the end of their execution. Subclasses may override
     * it to perform additional actions after this read operation. &lt;strong&gt;In any case the inherited method must be called!
     * Otherwise, the read lock will not be released.&lt;/strong&gt;
     *
     * @since 2.0
     */
    protected void endRead() {
<span class="fc" id="L582">        getSynchronizer().endRead();</span>
<span class="fc" id="L583">    }</span>

    /**
     * Notifies this configuration's {@link Synchronizer} that an update operation has finished. This method is called by
     * all methods which modify this configuration at the end of their execution. Subclasses may override it to perform
     * additional operations after an update. &lt;strong&gt;In any case the inherited method must be called! Otherwise, the write
     * lock will not be released.&lt;/strong&gt;
     *
     * @since 2.0
     */
    protected void endWrite() {
<span class="fc" id="L594">        getSynchronizer().endWrite();</span>
<span class="fc" id="L595">    }</span>

    /**
     * Finds a {@code ConfigurationLookup} pointing to this configuration in the default lookups of the specified
     * {@code ConfigurationInterpolator}. This method is called to ensure that there is exactly one default lookup querying
     * this configuration.
     *
     * @param ci the {@code ConfigurationInterpolator} in question
     * @return the found {@code Lookup} object or &lt;b&gt;null&lt;/b&gt;
     */
    private Lookup findConfigurationLookup(final ConfigurationInterpolator ci) {
<span class="fc" id="L606">        return findConfigurationLookup(ci, this);</span>
    }

    @Override
    public &lt;T&gt; T get(final Class&lt;T&gt; cls, final String key) {
<span class="fc" id="L611">        return convert(cls, key, null, true);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to the {@link ConversionHandler} to perform the actual type conversion.
     */
    @Override
    public &lt;T&gt; T get(final Class&lt;T&gt; cls, final String key, final T defaultValue) {
<span class="fc" id="L619">        return convert(cls, key, defaultValue, false);</span>
    }

    /**
     * Obtains the property value for the specified key and converts it to the given target class.
     *
     * @param &lt;T&gt; the target type of the conversion
     * @param cls the target class
     * @param key the key of the desired property
     * @param defaultValue a default value
     * @return the converted value of this property
     * @throws ConversionException if the conversion cannot be performed
     */
    private &lt;T&gt; T getAndConvertProperty(final Class&lt;T&gt; cls, final String key, final T defaultValue) {
<span class="fc" id="L633">        final Object value = getProperty(key);</span>
        try {
<span class="fc" id="L635">            return ObjectUtils.defaultIfNull(getConversionHandler().to(value, cls, getInterpolator()), defaultValue);</span>
<span class="fc" id="L636">        } catch (final ConversionException cex) {</span>
            // improve error message
<span class="fc" id="L638">            throw new ConversionException(String.format(&quot;Key '%s' cannot be converted to class %s. Value is: '%s'.&quot;, key, cls.getName(), String.valueOf(value)),</span>
<span class="fc" id="L639">                cex.getCause());</span>
        }
    }

    @Override
    public Object getArray(final Class&lt;?&gt; cls, final String key) {
<span class="fc" id="L645">        return getArray(cls, key, null);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to the {@link ConversionHandler} to perform the actual type conversion.
     * If this results in a &lt;b&gt;null&lt;/b&gt; result (because the property is undefined), the default value is returned. It is
     * checked whether the default value is an array with the correct component type. If not, an exception is thrown.
     *
     * @throws IllegalArgumentException if the default value is not a compatible array
     */
    @Override
    public Object getArray(final Class&lt;?&gt; cls, final String key, final Object defaultValue) {
<span class="fc" id="L657">        return convertToArray(cls, key, defaultValue);</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see #setThrowExceptionOnMissing(boolean)
     */
    @Override
    public BigDecimal getBigDecimal(final String key) {
<span class="fc" id="L667">        return convert(BigDecimal.class, key, null, true);</span>
    }

    @Override
    public BigDecimal getBigDecimal(final String key, final BigDecimal defaultValue) {
<span class="fc" id="L672">        return convert(BigDecimal.class, key, defaultValue, false);</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see #setThrowExceptionOnMissing(boolean)
     */
    @Override
    public BigInteger getBigInteger(final String key) {
<span class="fc" id="L682">        return convert(BigInteger.class, key, null, true);</span>
    }

    @Override
    public BigInteger getBigInteger(final String key, final BigInteger defaultValue) {
<span class="fc" id="L687">        return convert(BigInteger.class, key, defaultValue, false);</span>
    }

    @Override
    public boolean getBoolean(final String key) {
<span class="fc" id="L692">        final Boolean b = convert(Boolean.class, key, null, true);</span>
<span class="fc" id="L693">        return checkNonNullValue(key, b).booleanValue();</span>
    }

    @Override
    public boolean getBoolean(final String key, final boolean defaultValue) {
<span class="fc" id="L698">        return getBoolean(key, Boolean.valueOf(defaultValue)).booleanValue();</span>
    }

    /**
     * Obtains the value of the specified key and tries to convert it into a {@code Boolean} object. If the property has no
     * value, the passed in default value will be used.
     *
     * @param key the key of the property
     * @param defaultValue the default value
     * @return the value of this key converted to a {@code Boolean}
     * @throws ConversionException if the value cannot be converted to a {@code Boolean}
     */
    @Override
    public Boolean getBoolean(final String key, final Boolean defaultValue) {
<span class="fc" id="L712">        return convert(Boolean.class, key, defaultValue, false);</span>
    }

    @Override
    public byte getByte(final String key) {
<span class="fc" id="L717">        final Byte b = convert(Byte.class, key, null, true);</span>
<span class="fc" id="L718">        return checkNonNullValue(key, b).byteValue();</span>
    }

    @Override
    public byte getByte(final String key, final byte defaultValue) {
<span class="fc" id="L723">        return getByte(key, Byte.valueOf(defaultValue)).byteValue();</span>
    }

    @Override
    public Byte getByte(final String key, final Byte defaultValue) {
<span class="fc" id="L728">        return convert(Byte.class, key, defaultValue, false);</span>
    }

    @Override
    public &lt;T&gt; Collection&lt;T&gt; getCollection(final Class&lt;T&gt; cls, final String key, final Collection&lt;T&gt; target) {
<span class="fc" id="L733">        return getCollection(cls, key, target, null);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to the {@link ConversionHandler} to perform the actual conversion. If no
     * target collection is provided, an {@code ArrayList} is created.
     */
    @Override
    public &lt;T&gt; Collection&lt;T&gt; getCollection(final Class&lt;T&gt; cls, final String key, final Collection&lt;T&gt; target, final Collection&lt;T&gt; defaultValue) {
<span class="fc" id="L742">        final Object src = getProperty(key);</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (src == null) {</span>
<span class="fc" id="L744">            return handleDefaultCollection(target, defaultValue);</span>
        }

<span class="fc bfc" id="L747" title="All 2 branches covered.">        final Collection&lt;T&gt; targetCol = target != null ? target : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L748">        getConversionHandler().toCollection(src, cls, getInterpolator(), targetCol);</span>
<span class="fc" id="L749">        return targetCol;</span>
    }

    /**
     * Gets the {@code ConfigurationDecoder} used by this instance.
     *
     * @return the {@code ConfigurationDecoder}
     * @since 2.0
     */
    public ConfigurationDecoder getConfigurationDecoder() {
<span class="fc" id="L759">        return configurationDecoder;</span>
    }

    /**
     * Gets the {@code ConversionHandler} used by this instance.
     *
     * @return the {@code ConversionHandler}
     * @since 2.0
     */
    public ConversionHandler getConversionHandler() {
<span class="fc" id="L769">        return conversionHandler;</span>
    }

    @Override
    public double getDouble(final String key) {
<span class="fc" id="L774">        final Double d = convert(Double.class, key, null, true);</span>
<span class="fc" id="L775">        return checkNonNullValue(key, d).doubleValue();</span>
    }

    @Override
    public double getDouble(final String key, final double defaultValue) {
<span class="fc" id="L780">        return getDouble(key, Double.valueOf(defaultValue)).doubleValue();</span>
    }

    @Override
    public Double getDouble(final String key, final Double defaultValue) {
<span class="fc" id="L785">        return convert(Double.class, key, defaultValue, false);</span>
    }

    @Override
    public Duration getDuration(final String key) {
<span class="fc" id="L790">        return checkNonNullValue(key, convert(Duration.class, key, null, true));</span>
    }

    @Override
    public Duration getDuration(final String key, final Duration defaultValue) {
<span class="fc" id="L795">        return convert(Duration.class, key, defaultValue, false);</span>
    }

    /**
     * {@inheritDoc} This implementation makes use of the {@code ConfigurationDecoder} set for this configuration. If no
     * such object has been set, an {@code IllegalStateException} exception is thrown.
     *
     * @throws IllegalStateException if no {@code ConfigurationDecoder} is set
     * @see #setConfigurationDecoder(ConfigurationDecoder)
     */
    @Override
    public String getEncodedString(final String key) {
<span class="fc" id="L807">        final ConfigurationDecoder decoder = getConfigurationDecoder();</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (decoder == null) {</span>
<span class="fc" id="L809">            throw new IllegalStateException(&quot;No default ConfigurationDecoder defined!&quot;);</span>
        }
<span class="fc" id="L811">        return getEncodedString(key, decoder);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to {@link #getString(String)} in order to obtain the value of the passed
     * in key. This value is passed to the decoder. Because {@code getString()} is used behind the scenes all standard
     * features like handling of missing keys and interpolation work as expected.
     */
    @Override
    public String getEncodedString(final String key, final ConfigurationDecoder decoder) {
<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (decoder == null) {</span>
<span class="fc" id="L822">            throw new IllegalArgumentException(&quot;ConfigurationDecoder must not be null!&quot;);</span>
        }

<span class="fc" id="L825">        final String value = getString(key);</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">        return value != null ? decoder.decode(value) : null;</span>
    }

    @Override
    public float getFloat(final String key) {
<span class="fc" id="L831">        final Float f = convert(Float.class, key, null, true);</span>
<span class="fc" id="L832">        return checkNonNullValue(key, f).floatValue();</span>
    }

    @Override
    public float getFloat(final String key, final float defaultValue) {
<span class="fc" id="L837">        return getFloat(key, Float.valueOf(defaultValue)).floatValue();</span>
    }

    @Override
    public Float getFloat(final String key, final Float defaultValue) {
<span class="fc" id="L842">        return convert(Float.class, key, defaultValue, false);</span>
    }

    @Override
    public int getInt(final String key) {
<span class="fc" id="L847">        final Integer i = convert(Integer.class, key, null, true);</span>
<span class="fc" id="L848">        return checkNonNullValue(key, i).intValue();</span>
    }

    @Override
    public int getInt(final String key, final int defaultValue) {
<span class="fc" id="L853">        return getInteger(key, Integer.valueOf(defaultValue)).intValue();</span>
    }

    @Override
    public Integer getInteger(final String key, final Integer defaultValue) {
<span class="fc" id="L858">        return convert(Integer.class, key, defaultValue, false);</span>
    }

    /**
     * Gets the {@code ConfigurationInterpolator} object that manages the lookup objects for resolving variables.
     * Unless a custom interpolator has been set or the instance has been modified, the returned interpolator will
     * resolve values from this configuration instance and support the
     * {@link ConfigurationInterpolator#getDefaultPrefixLookups() default prefix lookups}.
     *
     * @return the {@code ConfigurationInterpolator} associated with this configuration
     * @since 1.4
     * @see ConfigurationInterpolator#getDefaultPrefixLookups()
     */
    @Override
    public ConfigurationInterpolator getInterpolator() {
<span class="fc" id="L873">        return interpolator.get();</span>
    }

    /**
     * {@inheritDoc} This implementation takes care of synchronization and then delegates to {@code getKeysInternal()} for
     * obtaining the actual iterator. Note that depending on a concrete implementation, an iteration may fail if the
     * configuration is updated concurrently.
     */
    @Override
    public final Iterator&lt;String&gt; getKeys() {
<span class="fc" id="L883">        beginRead(false);</span>
        try {
<span class="fc" id="L885">            return getKeysInternal();</span>
        } finally {
<span class="fc" id="L887">            endRead();</span>
        }
    }

    /**
     * {@inheritDoc} This implementation returns keys that either match the prefix or start with the prefix followed by a
     * dot ('.'). So the call {@code getKeys(&quot;db&quot;);} will find the keys {@code db}, {@code db.user}, or {@code db.password},
     * but not the key {@code dbdriver}.
     */
    @Override
    public final Iterator&lt;String&gt; getKeys(final String prefix) {
<span class="fc" id="L898">        beginRead(false);</span>
        try {
<span class="fc" id="L900">            return getKeysInternal(prefix);</span>
        } finally {
<span class="fc" id="L902">            endRead();</span>
        }
    }

    /**
     * {@inheritDoc} This implementation returns keys that either match the prefix or start with the prefix followed by the delimiter.
     * So the call {@code getKeys(&quot;db&quot;);} will find the keys {@code db}, {@code db@user}, or {@code db@password},
     * but not the key {@code dbdriver}.
     */
    @Override
    public final Iterator&lt;String&gt; getKeys(final String prefix, final String delimiter) {
<span class="fc" id="L913">        beginRead(false);</span>
        try {
<span class="fc" id="L915">            return getKeysInternal(prefix, delimiter);</span>
        } finally {
<span class="fc" id="L917">            endRead();</span>
        }
    }

    /**
     * Actually creates an iterator for iterating over the keys in this configuration. This method is called by
     * {@code getKeys()}, it has to be defined by concrete subclasses.
     *
     * @return an {@code Iterator} with all property keys in this configuration
     * @since 2.0
     */
    protected abstract Iterator&lt;String&gt; getKeysInternal();

    /**
     * Gets an {@code Iterator} with all property keys starting with the specified prefix. This method is called by
     * {@link #getKeys(String)}. It is fully implemented by delegating to {@code getKeysInternal()} and returning a special
     * iterator which filters for the passed in prefix. Subclasses can override it if they can provide a more efficient way
     * to iterate over specific keys only.
     *
     * @param prefix the prefix for the keys to be taken into account
     * @return an {@code Iterator} returning the filtered keys
     * @since 2.0
     */
    protected Iterator&lt;String&gt; getKeysInternal(final String prefix) {
<span class="fc" id="L941">        return new PrefixedKeysIterator(getKeysInternal(), prefix);</span>
    }

    /**
     * Gets an {@code Iterator} with all property keys starting with the specified prefix and specified delimiter. This method is called by
     * {@link #getKeys(String)}. It is fully implemented by delegating to {@code getKeysInternal()} and returning a special
     * iterator which filters for the passed in prefix. Subclasses can override it if they can provide a more efficient way
     * to iterate over specific keys only.
     *
     * @param prefix the prefix for the keys to be taken into account
     * @param delimiter the prefix delimiter
     * @return an {@code Iterator} returning the filtered keys
     * @since 2.10.0
     */
    protected Iterator&lt;String&gt; getKeysInternal(final String prefix, final String delimiter) {
<span class="fc" id="L956">        return new PrefixedKeysIterator(getKeysInternal(), prefix, delimiter);</span>
    }

    @Override
    public &lt;T&gt; List&lt;T&gt; getList(final Class&lt;T&gt; cls, final String key) {
<span class="fc" id="L961">        return getList(cls, key, null);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to the generic {@code getCollection()}. As target collection a newly
     * created {@code ArrayList} is passed in.
     */
    @Override
    public &lt;T&gt; List&lt;T&gt; getList(final Class&lt;T&gt; cls, final String key, final List&lt;T&gt; defaultValue) {
<span class="fc" id="L970">        final List&lt;T&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">        if (getCollection(cls, key, result, defaultValue) == null) {</span>
<span class="fc" id="L972">            return null;</span>
        }
<span class="fc" id="L974">        return result;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see #getStringArray(String)
     */
    @Override
    public List&lt;Object&gt; getList(final String key) {
<span class="fc" id="L984">        return getList(key, new ArrayList&lt;&gt;());</span>
    }

    @Override
    public List&lt;Object&gt; getList(final String key, final List&lt;?&gt; defaultValue) {
<span class="fc" id="L989">        final Object value = getProperty(key);</span>
        final List&lt;Object&gt; list;

<span class="fc bfc" id="L992" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L993">            list = new ArrayList&lt;&gt;(1);</span>
<span class="fc" id="L994">            list.add(interpolate((String) value));</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">        } else if (value instanceof List) {</span>
<span class="fc" id="L996">            list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L997">            final List&lt;?&gt; l = (List&lt;?&gt;) value;</span>

            // add the interpolated elements in the new list
<span class="fc" id="L1000">            l.forEach(elem -&gt; list.add(interpolate(elem)));</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        } else if (value == null) {</span>
            // This is okay because we just return this list to the caller
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1004">            final List&lt;Object&gt; resultList = (List&lt;Object&gt;) defaultValue;</span>
<span class="fc" id="L1005">            list = resultList;</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        } else if (value.getClass().isArray()) {</span>
<span class="fc" id="L1007">            return Arrays.asList((Object[]) value);</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        } else if (isScalarValue(value)) {</span>
<span class="fc" id="L1009">            return Collections.singletonList((Object) value.toString());</span>
        } else {
<span class="nc" id="L1011">            throw new ConversionException('\'' + key + &quot;' doesn't map to a List object: &quot; + value + &quot;, a &quot; + value.getClass().getName());</span>
        }
<span class="fc" id="L1013">        return list;</span>
    }

    /**
     * Gets the {@code ListDelimiterHandler} used by this instance.
     *
     * @return the {@code ListDelimiterHandler}
     * @since 2.0
     */
    public ListDelimiterHandler getListDelimiterHandler() {
<span class="fc" id="L1023">        return listDelimiterHandler;</span>
    }

    /**
     * Gets the logger used by this configuration object.
     *
     * @return the logger
     * @since 2.0
     */
    public ConfigurationLogger getLogger() {
<span class="fc" id="L1033">        return log;</span>
    }

    @Override
    public long getLong(final String key) {
<span class="fc" id="L1038">        final Long l = convert(Long.class, key, null, true);</span>
<span class="fc" id="L1039">        return checkNonNullValue(key, l).longValue();</span>
    }

    @Override
    public long getLong(final String key, final long defaultValue) {
<span class="fc" id="L1044">        return getLong(key, Long.valueOf(defaultValue)).longValue();</span>
    }

    @Override
    public Long getLong(final String key, final Long defaultValue) {
<span class="fc" id="L1049">        return convert(Long.class, key, defaultValue, false);</span>
    }

    @Override
    public Properties getProperties(final String key) {
<span class="fc" id="L1054">        return getProperties(key, null);</span>
    }

    /**
     * Gets a list of properties associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaults Any default values for the returned {@code Properties} object. Ignored if {@code null}.
     *
     * @return The associated properties if key is found.
     *
     * @throws ConversionException is thrown if the key maps to an object that is not a String/List of Strings.
     *
     * @throws IllegalArgumentException if one of the tokens is malformed (does not contain an equals sign).
     */
    public Properties getProperties(final String key, final Properties defaults) {
        /*
         * Grab an array of the tokens for this key.
         */
<span class="fc" id="L1073">        final String[] tokens = getStringArray(key);</span>

        /*
         * Each token is of the form 'key=value'.
         */
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        final Properties props = defaults == null ? new Properties() : new Properties(defaults);</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        for (final String token : tokens) {</span>
<span class="fc" id="L1080">            final int equalSign = token.indexOf('=');</span>
<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">            if (equalSign &gt; 0) {</span>
<span class="fc" id="L1082">                final String pkey = token.substring(0, equalSign).trim();</span>
<span class="fc" id="L1083">                final String pvalue = token.substring(equalSign + 1).trim();</span>
<span class="fc" id="L1084">                props.put(pkey, pvalue);</span>
<span class="pc bnc" id="L1085" title="All 4 branches missed.">            } else if (tokens.length == 1 &amp;&amp; StringUtils.isEmpty(key)) {</span>
                // Semantically equivalent to an empty Properties
                // object.
<span class="nc" id="L1088">                break;</span>
            } else {
<span class="nc" id="L1090">                throw new IllegalArgumentException('\'' + token + &quot;' does not contain an equals sign&quot;);</span>
            }
        }
<span class="fc" id="L1093">        return props;</span>
    }

    /**
     * {@inheritDoc} This implementation ensures proper synchronization. Subclasses have to define the abstract
     * {@code getPropertyInternal()} method which is called from here.
     */
    @Override
    public final Object getProperty(final String key) {
<span class="fc" id="L1102">        beginRead(false);</span>
        try {
<span class="fc" id="L1104">            return getPropertyInternal(key);</span>
        } finally {
<span class="fc" id="L1106">            endRead();</span>
        }
    }

    /**
     * Actually obtains the value of the specified property. This method is called by {@code getProperty()}. Concrete
     * subclasses must define it to fetch the value of the desired property.
     *
     * @param key the key of the property in question
     * @return the (raw) value of this property
     * @since 2.0
     */
    protected abstract Object getPropertyInternal(String key);

    @Override
    public short getShort(final String key) {
<span class="fc" id="L1122">        final Short s = convert(Short.class, key, null, true);</span>
<span class="fc" id="L1123">        return checkNonNullValue(key, s).shortValue();</span>
    }

    @Override
    public short getShort(final String key, final short defaultValue) {
<span class="fc" id="L1128">        return getShort(key, Short.valueOf(defaultValue)).shortValue();</span>
    }

    @Override
    public Short getShort(final String key, final Short defaultValue) {
<span class="fc" id="L1133">        return convert(Short.class, key, defaultValue, false);</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see #setThrowExceptionOnMissing(boolean)
     */
    @Override
    public String getString(final String key) {
<span class="fc" id="L1143">        return convert(String.class, key, null, true);</span>
    }

    @Override
    public String getString(final String key, final String defaultValue) {
<span class="fc" id="L1148">        final String result = convert(String.class, key, null, false);</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">        return result != null ? result : interpolate(defaultValue);</span>
    }

    /**
     * Gets an array of strings associated with the given configuration key. If the key doesn't map to an existing object, an
     * empty array is returned. When a property is added to a configuration, it is checked whether it contains multiple
     * values. This is obvious if the added object is a list or an array. For strings the association
     * {@link ListDelimiterHandler} is consulted to find out whether the string can be split into multiple values.
     *
     * @param key The configuration key.
     * @return The associated string array if key is found.
     *
     * @throws ConversionException is thrown if the key maps to an object that is not a String/List of Strings.
     * @see #setListDelimiterHandler(ListDelimiterHandler)
     */
    @Override
    public String[] getStringArray(final String key) {
<span class="fc" id="L1166">        final String[] result = (String[]) getArray(String.class, key);</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">        return result == null ? ArrayUtils.EMPTY_STRING_ARRAY : result;</span>
    }

    /**
     * Gets the object responsible for synchronizing this configuration. All access to this configuration - both read and
     * write access - is controlled by this object. This implementation never returns &lt;b&gt;null&lt;/b&gt;. If no
     * {@code Synchronizer} has been set, a {@link NoOpSynchronizer} is returned. So, per default, instances of
     * {@code AbstractConfiguration} are not thread-safe unless a suitable {@code Synchronizer} is set!
     *
     * @return the {@code Synchronizer} used by this instance
     * @since 2.0
     */
    @Override
    public final Synchronizer getSynchronizer() {
<span class="fc" id="L1181">        final Synchronizer sync = synchronizer;</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        return sync != null ? sync : NoOpSynchronizer.INSTANCE;</span>
    }

    @Override
    public ImmutableConfiguration immutableSubset(final String prefix) {
<span class="fc" id="L1187">        return ConfigurationUtils.unmodifiableConfiguration(subset(prefix));</span>
    }

    /**
     * Initializes the logger. Supports &lt;b&gt;null&lt;/b&gt; input. This method can be called by derived classes in order to enable
     * logging.
     *
     * @param log the logger
     * @since 2.0
     */
    protected final void initLogger(final ConfigurationLogger log) {
<span class="fc bfc" id="L1198" title="All 2 branches covered.">        this.log = log != null ? log : ConfigurationLogger.newDummyLogger();</span>
<span class="fc" id="L1199">    }</span>

    /**
     * Creates a default {@code ConfigurationInterpolator} which is initialized with all default {@code Lookup} objects.
     * This method is called by the constructor. It ensures that default interpolation works for every new configuration
     * instance.
     */
    private void installDefaultInterpolator() {
<span class="fc" id="L1207">        installInterpolator(ConfigurationInterpolator.getDefaultPrefixLookups(), null);</span>
<span class="fc" id="L1208">    }</span>

    /**
     * {@inheritDoc} This implementation creates a new {@code ConfigurationInterpolator} instance and initializes it with
     * the given {@code Lookup} objects. In addition, it adds a specialized default {@code Lookup} object which queries this
     * {@code Configuration}.
     *
     * @since 2.0
     */
    @Override
    public final void installInterpolator(final Map&lt;String, ? extends Lookup&gt; prefixLookups, final Collection&lt;? extends Lookup&gt; defLookups) {
<span class="fc" id="L1219">        final InterpolatorSpecification spec = new InterpolatorSpecification.Builder().withPrefixLookups(prefixLookups).withDefaultLookups(defLookups)</span>
<span class="fc" id="L1220">            .withDefaultLookup(new ConfigurationLookup(this)).create();</span>
<span class="fc" id="L1221">        setInterpolator(ConfigurationInterpolator.fromSpecification(spec));</span>
<span class="fc" id="L1222">    }</span>

    /**
     * Returns the interpolated value. This implementation delegates to the current {@code ConfigurationInterpolator}. If no
     * {@code ConfigurationInterpolator} is set, the passed in value is returned without changes.
     *
     * @param value the value to interpolate
     * @return the value with variables substituted
     */
    protected Object interpolate(final Object value) {
<span class="fc" id="L1232">        final ConfigurationInterpolator ci = getInterpolator();</span>
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">        return ci != null ? ci.interpolate(value) : value;</span>
    }

    /**
     * interpolate key names to handle ${key} stuff
     *
     * @param base string to interpolate
     *
     * @return returns the key name with the ${key} substituted
     */
    protected String interpolate(final String base) {
<span class="fc" id="L1244">        return Objects.toString(interpolate((Object) base), null);</span>
    }

    /**
     * Returns a configuration with the same content as this configuration, but with all variables replaced by their actual
     * values. This method tries to clone the configuration and then perform interpolation on all properties. So property
     * values of the form {@code ${var}} will be resolved as far as possible (if a variable cannot be resolved, it remains
     * unchanged). This operation is useful if the content of a configuration is to be exported or processed by an external
     * component that does not support variable interpolation.
     *
     * @return a configuration with all variables interpolated
     * @throws org.apache.commons.configuration2.ex.ConfigurationRuntimeException if this configuration cannot be cloned
     * @since 1.5
     */
    public Configuration interpolatedConfiguration() {
        // first clone this configuration
<span class="fc" id="L1260">        final AbstractConfiguration c = (AbstractConfiguration) ConfigurationUtils.cloneConfiguration(this);</span>

        // now perform interpolation
<span class="fc" id="L1263">        c.setListDelimiterHandler(new DisabledListDelimiterHandler());</span>
<span class="fc" id="L1264">        getKeys().forEachRemaining(key -&gt; c.setProperty(key, getList(key)));</span>
<span class="fc" id="L1265">        c.setListDelimiterHandler(getListDelimiterHandler());</span>
<span class="fc" id="L1266">        return c;</span>
    }

    /**
     * {@inheritDoc} This implementation handles synchronization and delegates to {@code isEmptyInternal()}.
     */
    @Override
    public final boolean isEmpty() {
<span class="fc" id="L1274">        beginRead(false);</span>
        try {
<span class="fc" id="L1276">            return isEmptyInternal();</span>
        } finally {
<span class="fc" id="L1278">            endRead();</span>
        }
    }

    /**
     * Actually checks whether this configuration contains data. This method is called by {@code isEmpty()}. It has to be
     * defined by concrete subclasses.
     *
     * @return &lt;b&gt;true&lt;/b&gt; if this configuration contains no data, &lt;b&gt;false&lt;/b&gt; otherwise
     * @since 2.0
     */
    protected abstract boolean isEmptyInternal();

    /**
     * Checks whether the specified object is a scalar value. This method is called by {@code getList()} and
     * {@code getStringArray()} if the property requested is not a string, a list, or an array. If it returns &lt;b&gt;true&lt;/b&gt;,
     * the calling method transforms the value to a string and returns a list or an array with this single element. This
     * implementation returns &lt;b&gt;true&lt;/b&gt; if the value is of a wrapper type for a primitive type.
     *
     * @param value the value to be checked
     * @return a flag whether the value is a scalar
     * @since 1.7
     */
    protected boolean isScalarValue(final Object value) {
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">        return ClassUtils.wrapperToPrimitive(value.getClass()) != null;</span>
    }

    /**
     * Returns true if missing values throw Exceptions.
     *
     * @return true if missing values throw Exceptions
     */
    public boolean isThrowExceptionOnMissing() {
<span class="fc" id="L1311">        return throwExceptionOnMissing;</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to {@code beginRead()} or {@code beginWrite()}, depending on the
     * {@code LockMode} argument. Subclasses can override these protected methods to perform additional steps when a
     * configuration is locked.
     *
     * @since 2.0
     * @throws NullPointerException if the argument is &lt;b&gt;null&lt;/b&gt;
     */
    @Override
    public final void lock(final LockMode mode) {
<span class="pc bpc" id="L1324" title="1 of 3 branches missed.">        switch (mode) {</span>
        case READ:
<span class="fc" id="L1326">            beginRead(false);</span>
<span class="fc" id="L1327">            break;</span>
        case WRITE:
<span class="fc" id="L1329">            beginWrite(false);</span>
<span class="fc" id="L1330">            break;</span>
        default:
<span class="nc" id="L1332">            throw new IllegalArgumentException(&quot;Unsupported LockMode: &quot; + mode);</span>
        }
<span class="fc" id="L1334">    }</span>

    /**
     * Sets the {@code ConfigurationDecoder} for this configuration. This object is used by
     * {@link #getEncodedString(String)}.
     *
     * @param configurationDecoder the {@code ConfigurationDecoder}
     * @since 2.0
     */
    public void setConfigurationDecoder(final ConfigurationDecoder configurationDecoder) {
<span class="fc" id="L1344">        this.configurationDecoder = configurationDecoder;</span>
<span class="fc" id="L1345">    }</span>

    /**
     * Sets the {@code ConversionHandler} to be used by this instance. The {@code ConversionHandler} is responsible for
     * every kind of data type conversion. It is consulted by all get methods returning results in specific data types. A
     * newly created configuration uses a default {@code ConversionHandler} implementation. This can be changed while
     * initializing the configuration (e.g. via a builder). Note that access to this property is not synchronized.
     *
     * @param conversionHandler the {@code ConversionHandler} to be used (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the {@code ConversionHandler} is &lt;b&gt;null&lt;/b&gt;
     * @since 2.0
     */
    public void setConversionHandler(final ConversionHandler conversionHandler) {
<span class="fc bfc" id="L1358" title="All 2 branches covered.">        if (conversionHandler == null) {</span>
<span class="fc" id="L1359">            throw new IllegalArgumentException(&quot;ConversionHandler must not be null!&quot;);</span>
        }
<span class="fc" id="L1361">        this.conversionHandler = conversionHandler;</span>
<span class="fc" id="L1362">    }</span>

    /**
     * Adds all {@code Lookup} objects in the given collection as default lookups (i.e. lookups without a variable prefix)
     * to the {@code ConfigurationInterpolator} object of this configuration. In addition, it adds a specialized default
     * {@code Lookup} object which queries this {@code Configuration}. The set of {@code Lookup} objects with prefixes is
     * not modified by this method. If this configuration does not have a {@code ConfigurationInterpolator}, a new instance
     * is created. Note: This method is mainly intended to be used for initializing a configuration when it is created by a
     * builder. Normal client code should better call {@link #installInterpolator(Map, Collection)} to define the
     * {@code ConfigurationInterpolator} in a single step.
     *
     * @param lookups the collection with default {@code Lookup} objects to be added
     * @since 2.0
     */
    public void setDefaultLookups(final Collection&lt;? extends Lookup&gt; lookups) {
        boolean success;
        do {
<span class="fc" id="L1379">            final ConfigurationInterpolator ciOld = getInterpolator();</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">            final ConfigurationInterpolator ciNew = ciOld != null ? ciOld : new ConfigurationInterpolator();</span>
<span class="fc" id="L1381">            Lookup confLookup = findConfigurationLookup(ciNew);</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">            if (confLookup == null) {</span>
<span class="fc" id="L1383">                confLookup = new ConfigurationLookup(this);</span>
            } else {
<span class="fc" id="L1385">                ciNew.removeDefaultLookup(confLookup);</span>
            }
<span class="fc" id="L1387">            ciNew.addDefaultLookups(lookups);</span>
<span class="fc" id="L1388">            ciNew.addDefaultLookup(confLookup);</span>
<span class="fc" id="L1389">            success = interpolator.compareAndSet(ciOld, ciNew);</span>
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">        } while (!success);</span>
<span class="fc" id="L1391">    }</span>

    /**
     * {@inheritDoc} This implementation sets the passed in object without further modifications. A &lt;b&gt;null&lt;/b&gt; argument is
     * allowed; this disables interpolation.
     *
     * @since 2.0
     */
    @Override
    public final void setInterpolator(final ConfigurationInterpolator ci) {
<span class="fc" id="L1401">        interpolator.set(ci);</span>
<span class="fc" id="L1402">    }</span>

    /**
     * &lt;p&gt;
     * Sets the {@code ListDelimiterHandler} to be used by this instance. This object is invoked every time when dealing
     * with string properties that may contain a list delimiter and thus have to be split to multiple values. Per default, a
     * {@code ListDelimiterHandler} implementation is set which does not support list splitting. This can be changed for
     * instance by setting a {@link org.apache.commons.configuration2.convert.DefaultListDelimiterHandler
     * DefaultListDelimiterHandler} object.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt; Be careful when changing the list delimiter handler when the configuration has already been
     * loaded/populated. List handling is typically applied already when properties are added to the configuration. If later
     * another handler is set which processes lists differently, results may be unexpected; some operations may even cause
     * exceptions.
     * &lt;/p&gt;
     *
     * @param listDelimiterHandler the {@code ListDelimiterHandler} to be used (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the {@code ListDelimiterHandler} is &lt;b&gt;null&lt;/b&gt;
     * @since 2.0
     */
    public void setListDelimiterHandler(final ListDelimiterHandler listDelimiterHandler) {
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        if (listDelimiterHandler == null) {</span>
<span class="fc" id="L1425">            throw new IllegalArgumentException(&quot;List delimiter handler must not be null!&quot;);</span>
        }
<span class="fc" id="L1427">        this.listDelimiterHandler = listDelimiterHandler;</span>
<span class="fc" id="L1428">    }</span>

    /**
     * Allows setting the logger to be used by this configuration object. This method makes it possible for clients to
     * exactly control logging behavior. Per default a logger is set that will ignore all log messages. Derived classes that
     * want to enable logging should call this method during their initialization with the logger to be used. It is legal to
     * pass a &lt;b&gt;null&lt;/b&gt; logger; in this case, logging will be disabled.
     *
     * @param log the new logger
     * @since 2.0
     */
    public void setLogger(final ConfigurationLogger log) {
<span class="fc" id="L1440">        initLogger(log);</span>
<span class="fc" id="L1441">    }</span>

    /**
     * Sets the specified {@code ConfigurationInterpolator} as the parent of this configuration's
     * {@code ConfigurationInterpolator}. If this configuration does not have a {@code ConfigurationInterpolator}, a new
     * instance is created. Note: This method is mainly intended to be used for initializing a configuration when it is
     * created by a builder. Normal client code can directly update the {@code ConfigurationInterpolator}.
     *
     * @param parent the parent {@code ConfigurationInterpolator} to be set
     * @since 2.0
     */
    public void setParentInterpolator(final ConfigurationInterpolator parent) {
        boolean success;
        do {
<span class="fc" id="L1455">            final ConfigurationInterpolator ciOld = getInterpolator();</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            final ConfigurationInterpolator ciNew = ciOld != null ? ciOld : new ConfigurationInterpolator();</span>
<span class="fc" id="L1457">            ciNew.setParentInterpolator(parent);</span>
<span class="fc" id="L1458">            success = interpolator.compareAndSet(ciOld, ciNew);</span>
<span class="pc bpc" id="L1459" title="1 of 2 branches missed.">        } while (!success);</span>
<span class="fc" id="L1460">    }</span>

    /**
     * Registers all {@code Lookup} objects in the given map at the current {@code ConfigurationInterpolator} of this
     * configuration. The set of default lookup objects (for variables without a prefix) is not modified by this method. If
     * this configuration does not have a {@code ConfigurationInterpolator}, a new instance is created. Note: This method is
     * mainly intended to be used for initializing a configuration when it is created by a builder. Normal client code
     * should better call {@link #installInterpolator(Map, Collection)} to define the {@code ConfigurationInterpolator} in a
     * single step.
     *
     * @param lookups a map with new {@code Lookup} objects and their prefixes (may be &lt;b&gt;null&lt;/b&gt;)
     * @since 2.0
     */
    public void setPrefixLookups(final Map&lt;String, ? extends Lookup&gt; lookups) {
        boolean success;
        do {
            // do this in a loop because the ConfigurationInterpolator
            // instance may be changed by another thread
<span class="fc" id="L1478">            final ConfigurationInterpolator ciOld = getInterpolator();</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">            final ConfigurationInterpolator ciNew = ciOld != null ? ciOld : new ConfigurationInterpolator();</span>
<span class="fc" id="L1480">            ciNew.registerLookups(lookups);</span>
<span class="fc" id="L1481">            success = interpolator.compareAndSet(ciOld, ciNew);</span>
<span class="pc bpc" id="L1482" title="1 of 2 branches missed.">        } while (!success);</span>
<span class="fc" id="L1483">    }</span>

    @Override
    public final void setProperty(final String key, final Object value) {
<span class="fc" id="L1487">        beginWrite(false);</span>
        try {
<span class="fc" id="L1489">            fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, true);</span>
<span class="fc" id="L1490">            setPropertyInternal(key, value);</span>
<span class="fc" id="L1491">            fireEvent(ConfigurationEvent.SET_PROPERTY, key, value, false);</span>
        } finally {
<span class="fc" id="L1493">            endWrite();</span>
        }
<span class="fc" id="L1495">    }</span>

    /**
     * Actually sets the value of a property. This method is called by {@code setProperty()}. It provides a default
     * implementation of this functionality by clearing the specified key and delegating to {@code addProperty()}.
     * Subclasses should override this method if they can provide a more efficient algorithm for setting a property value.
     *
     * @param key the property key
     * @param value the new property value
     * @since 2.0
     */
    protected void setPropertyInternal(final String key, final Object value) {
<span class="fc" id="L1507">        setDetailEvents(false);</span>
        try {
<span class="fc" id="L1509">            clearProperty(key);</span>
<span class="fc" id="L1510">            addProperty(key, value);</span>
        } finally {
<span class="fc" id="L1512">            setDetailEvents(true);</span>
        }
<span class="fc" id="L1514">    }</span>

    /**
     * Sets the object responsible for synchronizing this configuration. This method has to be called with a suitable
     * {@code Synchronizer} object when initializing this configuration instance in order to make it thread-safe.
     *
     * @param synchronizer the new {@code Synchronizer}; can be &lt;b&gt;null&lt;/b&gt;, then this instance uses a
     *        {@link NoOpSynchronizer}
     * @since 2.0
     */
    @Override
    public final void setSynchronizer(final Synchronizer synchronizer) {
<span class="fc" id="L1526">        this.synchronizer = synchronizer;</span>
<span class="fc" id="L1527">    }</span>

    /**
     * Allows to set the {@code throwExceptionOnMissing} flag. This flag controls the behavior of property getter methods
     * that return objects if the requested property is missing. If the flag is set to &lt;b&gt;false&lt;/b&gt; (which is the default
     * value), these methods will return &lt;b&gt;null&lt;/b&gt;. If set to &lt;b&gt;true&lt;/b&gt;, they will throw a
     * {@code NoSuchElementException} exception. Note that getter methods for primitive data types are not affected by this
     * flag.
     *
     * @param throwExceptionOnMissing The new value for the property
     */
    public void setThrowExceptionOnMissing(final boolean throwExceptionOnMissing) {
<span class="fc" id="L1539">        this.throwExceptionOnMissing = throwExceptionOnMissing;</span>
<span class="fc" id="L1540">    }</span>

    /**
     * {@inheritDoc} This implementation handles synchronization and delegates to {@code sizeInternal()}.
     */
    @Override
    public final int size() {
<span class="fc" id="L1547">        beginRead(false);</span>
        try {
<span class="fc" id="L1549">            return sizeInternal();</span>
        } finally {
<span class="fc" id="L1551">            endRead();</span>
        }
    }

    /**
     * Actually calculates the size of this configuration. This method is called by {@code size()} with a read lock held.
     * The base implementation provided here calculates the size based on the iterator returned by {@code getKeys()}. Sub
     * classes which can determine the size in a more efficient way should override this method.
     *
     * @return the size of this configuration (i.e. the number of keys)
     */
    protected int sizeInternal() {
<span class="fc" id="L1563">        int size = 0;</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">        for (final Iterator&lt;String&gt; keyIt = getKeysInternal(); keyIt.hasNext(); size++) {</span>
<span class="fc" id="L1565">            keyIt.next();</span>
        }
<span class="fc" id="L1567">        return size;</span>
    }

    @Override
    public Configuration subset(final String prefix) {
<span class="fc" id="L1572">        return new SubsetConfiguration(this, prefix, &quot;.&quot;);</span>
    }

    /**
     * {@inheritDoc} This implementation delegates to {@code endRead()} or {@code endWrite()}, depending on the
     * {@code LockMode} argument. Subclasses can override these protected methods to perform additional steps when a
     * configuration's lock is released.
     *
     * @throws NullPointerException if the argument is &lt;b&gt;null&lt;/b&gt;
     */
    @Override
    public final void unlock(final LockMode mode) {
<span class="pc bpc" id="L1584" title="1 of 3 branches missed.">        switch (mode) {</span>
        case READ:
<span class="fc" id="L1586">            endRead();</span>
<span class="fc" id="L1587">            break;</span>
        case WRITE:
<span class="fc" id="L1589">            endWrite();</span>
<span class="fc" id="L1590">            break;</span>
        default:
<span class="nc" id="L1592">            throw new IllegalArgumentException(&quot;Unsupported LockMode: &quot; + mode);</span>
        }
<span class="fc" id="L1594">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>