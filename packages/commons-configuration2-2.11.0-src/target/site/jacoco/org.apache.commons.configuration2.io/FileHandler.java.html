<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.io</a> &gt; <span class="el_source">FileHandler.java</span></div><h1>FileHandler.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.io;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicReference;

import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.io.FileLocator.FileLocatorBuilder;
import org.apache.commons.configuration2.sync.LockMode;
import org.apache.commons.configuration2.sync.NoOpSynchronizer;
import org.apache.commons.configuration2.sync.Synchronizer;
import org.apache.commons.configuration2.sync.SynchronizerSupport;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * A class that manages persistence of an associated {@link FileBased} object.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Instances of this class can be used to load and save arbitrary objects implementing the {@code FileBased} interface
 * in a convenient way from and to various locations. At construction time the {@code FileBased} object to manage is
 * passed in. Basically, this object is assigned a location from which it is loaded and to which it can be saved. The
 * following possibilities exist to specify such a location:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;URLs: With the method {@code setURL()} a full URL to the configuration source can be specified. This is the most
 * flexible way. Note that the {@code save()} methods support only &lt;em&gt;file:&lt;/em&gt; URLs.&lt;/li&gt;
 * &lt;li&gt;Files: The {@code setFile()} method allows to specify the configuration source as a file. This can be either a
 * relative or an absolute file. In the former case the file is resolved based on the current directory.&lt;/li&gt;
 * &lt;li&gt;As file paths in string form: With the {@code setPath()} method a full path to a configuration file can be
 * provided as a string.&lt;/li&gt;
 * &lt;li&gt;Separated as base path and file name: The base path is a string defining either a local directory or a URL. It
 * can be set using the {@code setBasePath()} method. The file name, non surprisingly, defines the name of the
 * configuration file.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * An instance stores a location. The {@code load()} and {@code save()} methods that do not take an argument make use of
 * this internal location. Alternatively, it is also possible to use overloaded variants of {@code load()} and
 * {@code save()} which expect a location. In these cases the location specified takes precedence over the internal one;
 * the internal location is not changed.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The actual position of the file to be loaded is determined by a {@link FileLocationStrategy} based on the location
 * information that has been provided. By providing a custom location strategy the algorithm for searching files can be
 * adapted. Save operations require more explicit information. They cannot rely on a location strategy because the file
 * to be written may not yet exist. So there may be some differences in the way location information is interpreted by
 * load and save operations. In order to avoid this, the following approach is recommended:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Use the desired {@code setXXX()} methods to define the location of the file to be loaded.&lt;/li&gt;
 * &lt;li&gt;Call the {@code locate()} method. This method resolves the referenced file (if possible) and fills out all
 * supported location information.&lt;/li&gt;
 * &lt;li&gt;Later on, {@code save()} can be called. This method now has sufficient information to store the file at the
 * correct location.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * When loading or saving a {@code FileBased} object some additional functionality is performed if the object implements
 * one of the following interfaces:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@code FileLocatorAware}: In this case an object with the current file location is injected before the load or
 * save operation is executed. This is useful for {@code FileBased} objects that depend on their current location, e.g.
 * to resolve relative path names.&lt;/li&gt;
 * &lt;li&gt;{@code SynchronizerSupport}: If this interface is implemented, load and save operations obtain a write lock on
 * the {@code FileBased} object before they access it. (In case of a save operation, a read lock would probably be
 * sufficient, but because of the possible injection of a {@link FileLocator} object it is not allowed to perform
 * multiple save operations in parallel; therefore, by obtaining a write lock, we are on the safe side.)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * This class is thread-safe.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
public class FileHandler {
    /**
     * An internal class that performs all update operations of the handler's {@code FileLocator} in a safe way even if
     * there is concurrent access. This class implements anon-blocking algorithm for replacing the immutable
     * {@code FileLocator} instance stored in an atomic reference by a manipulated instance. (If we already had lambdas,
     * this could be done without a class in a more elegant way.)
     */
<span class="fc" id="L111">    private abstract class AbstractUpdater {</span>
        /**
         * Performs an update of the enclosing file handler's {@code FileLocator} object.
         */
        public void update() {
            boolean done;
            do {
<span class="fc" id="L118">                final FileLocator oldLocator = fileLocator.get();</span>
<span class="fc" id="L119">                final FileLocatorBuilder builder = FileLocatorUtils.fileLocator(oldLocator);</span>
<span class="fc" id="L120">                updateBuilder(builder);</span>
<span class="fc" id="L121">                done = fileLocator.compareAndSet(oldLocator, builder.create());</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            } while (!done);</span>
<span class="fc" id="L123">            fireLocationChangedEvent();</span>
<span class="fc" id="L124">        }</span>

        /**
         * Updates the passed in builder object to apply the manipulation to be performed by this {@code Updater}. The builder
         * has been setup with the former content of the {@code FileLocator} to be manipulated.
         *
         * @param builder the builder for creating an updated {@code FileLocator}
         */
        protected abstract void updateBuilder(FileLocatorBuilder builder);
    }

    /** Constant for the URI scheme for files. */
    private static final String FILE_SCHEME = &quot;file:&quot;;

    /** Constant for the URI scheme for files with slashes. */
    private static final String FILE_SCHEME_SLASH = FILE_SCHEME + &quot;//&quot;;

    /**
     * A dummy implementation of {@code SynchronizerSupport}. This object is used when the file handler's content does not
     * implement the {@code SynchronizerSupport} interface. All methods are just empty dummy implementations.
     */
<span class="fc" id="L145">    private static final SynchronizerSupport DUMMY_SYNC_SUPPORT = new SynchronizerSupport() {</span>
        @Override
        public Synchronizer getSynchronizer() {
<span class="nc" id="L148">            return NoOpSynchronizer.INSTANCE;</span>
        }

        @Override
        public void lock(final LockMode mode) {
            // empty
<span class="fc" id="L154">        }</span>

        @Override
        public void setSynchronizer(final Synchronizer sync) {
            // empty
<span class="nc" id="L159">        }</span>

        @Override
        public void unlock(final LockMode mode) {
            // empty
<span class="fc" id="L164">        }</span>
    };

    /**
     * Helper method for checking a file handler which is to be copied. Throws an exception if the handler is &lt;b&gt;null&lt;/b&gt;.
     *
     * @param c the {@code FileHandler} from which to copy the location
     * @return the same {@code FileHandler}
     */
    private static FileHandler checkSourceHandler(final FileHandler c) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (c == null) {</span>
<span class="fc" id="L175">            throw new IllegalArgumentException(&quot;FileHandler to assign must not be null!&quot;);</span>
        }
<span class="fc" id="L177">        return c;</span>
    }

    /**
     * A helper method for closing a stream. Occurring exceptions will be ignored.
     *
     * @param cl the stream to be closed (may be &lt;b&gt;null&lt;/b&gt;)
     */
    private static void closeSilent(final Closeable cl) {
        try {
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (cl != null) {</span>
<span class="fc" id="L188">                cl.close();</span>
            }
<span class="nc" id="L190">        } catch (final IOException e) {</span>
<span class="nc" id="L191">            LogFactory.getLog(FileHandler.class).warn(&quot;Exception when closing &quot; + cl, e);</span>
<span class="fc" id="L192">        }</span>
<span class="fc" id="L193">    }</span>

    /**
     * Creates a {@code File} object from the content of the given {@code FileLocator} object. If the locator is not
     * defined, result is &lt;b&gt;null&lt;/b&gt;.
     *
     * @param loc the {@code FileLocator}
     * @return a {@code File} object pointing to the associated file
     */
    private static File createFile(final FileLocator loc) {
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">        if (loc.getFileName() == null &amp;&amp; loc.getSourceURL() == null) {</span>
<span class="fc" id="L204">            return null;</span>
        }
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (loc.getSourceURL() != null) {</span>
<span class="nc" id="L207">            return FileLocatorUtils.fileFromURL(loc.getSourceURL());</span>
        }
<span class="fc" id="L209">        return FileLocatorUtils.getFile(loc.getBasePath(), loc.getFileName());</span>
    }

    /**
     * Creates an uninitialized file locator.
     *
     * @return the locator
     */
    private static FileLocator emptyFileLocator() {
<span class="fc" id="L218">        return FileLocatorUtils.fileLocator().create();</span>
    }

    /**
     * Creates a new {@code FileHandler} instance from properties stored in a map. This method tries to extract a
     * {@link FileLocator} from the map. A new {@code FileHandler} is created based on this {@code FileLocator}.
     *
     * @param map the map (may be &lt;b&gt;null&lt;/b&gt;)
     * @return the newly created {@code FileHandler}
     * @see FileLocatorUtils#fromMap(Map)
     */
    public static FileHandler fromMap(final Map&lt;String, ?&gt; map) {
<span class="fc" id="L230">        return new FileHandler(null, FileLocatorUtils.fromMap(map));</span>
    }

    /**
     * Normalizes URLs to files. Ensures that file URLs start with the correct protocol.
     *
     * @param fileName the string to be normalized
     * @return the normalized file URL
     */
    private static String normalizeFileURL(String fileName) {
<span class="fc bfc" id="L240" title="All 6 branches covered.">        if (fileName != null &amp;&amp; fileName.startsWith(FILE_SCHEME) &amp;&amp; !fileName.startsWith(FILE_SCHEME_SLASH)) {</span>
<span class="fc" id="L241">            fileName = FILE_SCHEME_SLASH + fileName.substring(FILE_SCHEME.length());</span>
        }
<span class="fc" id="L243">        return fileName;</span>
    }

    /** The file-based object managed by this handler. */
    private final FileBased content;

    /** A reference to the current {@code FileLocator} object. */
    private final AtomicReference&lt;FileLocator&gt; fileLocator;

    /** A collection with the registered listeners. */
<span class="fc" id="L253">    private final List&lt;FileHandlerListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();</span>

    /**
     * Creates a new instance of {@code FileHandler} which is not associated with a {@code FileBased} object and thus does
     * not have a content. Objects of this kind can be used to define a file location, but it is not possible to actually
     * load or save data.
     */
    public FileHandler() {
<span class="fc" id="L261">        this(null);</span>
<span class="fc" id="L262">    }</span>

    /**
     * Creates a new instance of {@code FileHandler} and sets the managed {@code FileBased} object.
     *
     * @param obj the file-based object to manage
     */
    public FileHandler(final FileBased obj) {
<span class="fc" id="L270">        this(obj, emptyFileLocator());</span>
<span class="fc" id="L271">    }</span>

    /**
     * Creates a new instance of {@code FileHandler} which is associated with the given {@code FileBased} object and the
     * location defined for the given {@code FileHandler} object. A copy of the location of the given {@code FileHandler} is
     * created. This constructor is a possibility to associate a file location with a {@code FileBased} object.
     *
     * @param obj the {@code FileBased} object to manage
     * @param c the {@code FileHandler} from which to copy the location (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the {@code FileHandler} is &lt;b&gt;null&lt;/b&gt;
     */
    public FileHandler(final FileBased obj, final FileHandler c) {
<span class="fc" id="L283">        this(obj, checkSourceHandler(c).getFileLocator());</span>
<span class="fc" id="L284">    }</span>

    /**
     * Creates a new instance of {@code FileHandler} based on the given {@code FileBased} and {@code FileLocator} objects.
     *
     * @param obj the {@code FileBased} object to manage
     * @param locator the {@code FileLocator}
     */
<span class="fc" id="L292">    private FileHandler(final FileBased obj, final FileLocator locator) {</span>
<span class="fc" id="L293">        content = obj;</span>
<span class="fc" id="L294">        fileLocator = new AtomicReference&lt;&gt;(locator);</span>
<span class="fc" id="L295">    }</span>

    /**
     * Adds a listener to this {@code FileHandler}. It is notified about property changes and IO operations.
     *
     * @param l the listener to be added (must not be &lt;b&gt;null&lt;/b&gt;)
     * @throws IllegalArgumentException if the listener is &lt;b&gt;null&lt;/b&gt;
     */
    public void addFileHandlerListener(final FileHandlerListener l) {
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (l == null) {</span>
<span class="fc" id="L305">            throw new IllegalArgumentException(&quot;Listener must not be null!&quot;);</span>
        }
<span class="fc" id="L307">        listeners.add(l);</span>
<span class="fc" id="L308">    }</span>

    /**
     * Checks whether a content object is available. If not, an exception is thrown. This method is called whenever the
     * content object is accessed.
     *
     * @throws ConfigurationException if not content object is defined
     */
    private void checkContent() throws ConfigurationException {
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (getContent() == null) {</span>
<span class="fc" id="L318">            throw new ConfigurationException(&quot;No content available!&quot;);</span>
        }
<span class="fc" id="L320">    }</span>

    /**
     * Checks whether a content object is available and returns the current {@code FileLocator}. If there is no content
     * object, an exception is thrown. This is a typical operation to be performed before a load() or save() operation.
     *
     * @return the current {@code FileLocator} to be used for the calling operation
     * @throws ConfigurationException if not content object is defined
     */
    private FileLocator checkContentAndGetLocator() throws ConfigurationException {
<span class="fc" id="L330">        checkContent();</span>
<span class="fc" id="L331">        return getFileLocator();</span>
    }

    /**
     * Clears the location of this {@code FileHandler}. Afterwards this handler does not point to any valid file.
     */
    public void clearLocation() {
<span class="fc" id="L338">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L341">                builder.basePath(null).fileName(null).sourceURL(null);</span>
<span class="fc" id="L342">            }</span>
<span class="fc" id="L343">        }.update();</span>
<span class="fc" id="L344">    }</span>

    /**
     * Creates a {@code FileLocator} which is a copy of the passed in one, but has the given file name set to reference the
     * target file.
     *
     * @param fileName the file name
     * @param locator the {@code FileLocator} to copy
     * @return the manipulated {@code FileLocator} with the file name
     */
    private FileLocator createLocatorWithFileName(final String fileName, final FileLocator locator) {
<span class="fc" id="L355">        return FileLocatorUtils.fileLocator(locator).sourceURL(null).fileName(fileName).create();</span>
    }

    /**
     * Obtains a {@code SynchronizerSupport} for the current content. If the content implements this interface, it is
     * returned. Otherwise, result is a dummy object. This method is called before load and save operations. The returned
     * object is used for synchronization.
     *
     * @return the {@code SynchronizerSupport} for synchronization
     */
    private SynchronizerSupport fetchSynchronizerSupport() {
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (getContent() instanceof SynchronizerSupport) {</span>
<span class="fc" id="L367">            return (SynchronizerSupport) getContent();</span>
        }
<span class="fc" id="L369">        return DUMMY_SYNC_SUPPORT;</span>
    }

    /**
     * Notifies the registered listeners about a completed load operation.
     */
    private void fireLoadedEvent() {
<span class="fc" id="L376">        listeners.forEach(l -&gt; l.loaded(this));</span>
<span class="fc" id="L377">    }</span>

    /**
     * Notifies the registered listeners about the start of a load operation.
     */
    private void fireLoadingEvent() {
<span class="fc" id="L383">        listeners.forEach(l -&gt; l.loading(this));</span>
<span class="fc" id="L384">    }</span>

    /**
     * Notifies the registered listeners about a property update.
     */
    private void fireLocationChangedEvent() {
<span class="fc" id="L390">        listeners.forEach(l -&gt; l.locationChanged(this));</span>
<span class="fc" id="L391">    }</span>

    /**
     * Notifies the registered listeners about a completed save operation.
     */
    private void fireSavedEvent() {
<span class="fc" id="L397">        listeners.forEach(l -&gt; l.saved(this));</span>
<span class="fc" id="L398">    }</span>

    /**
     * Notifies the registered listeners about the start of a save operation.
     */
    private void fireSavingEvent() {
<span class="fc" id="L404">        listeners.forEach(l -&gt; l.saving(this));</span>
<span class="fc" id="L405">    }</span>

    /**
     * Gets the base path. If no base path is defined, but a URL, the base path is derived from there.
     *
     * @return the base path
     */
    public String getBasePath() {
<span class="fc" id="L413">        final FileLocator locator = getFileLocator();</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (locator.getBasePath() != null) {</span>
<span class="fc" id="L415">            return locator.getBasePath();</span>
        }

<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (locator.getSourceURL() != null) {</span>
<span class="fc" id="L419">            return FileLocatorUtils.getBasePath(locator.getSourceURL());</span>
        }

<span class="fc" id="L422">        return null;</span>
    }

    /**
     * Gets the {@code FileBased} object associated with this {@code FileHandler}.
     *
     * @return the associated {@code FileBased} object
     */
    public final FileBased getContent() {
<span class="fc" id="L431">        return content;</span>
    }

    /**
     * Gets the encoding of the associated file. Result can be &lt;b&gt;null&lt;/b&gt; if no encoding has been set.
     *
     * @return the encoding of the associated file
     */
    public String getEncoding() {
<span class="fc" id="L440">        return getFileLocator().getEncoding();</span>
    }

    /**
     * Gets the location of the associated file as a {@code File} object. If the base path is a URL with a protocol
     * different than &amp;quot;file&amp;quot;, or the file is within a compressed archive, the return value will not point to a
     * valid file object.
     *
     * @return the location as {@code File} object; this can be &lt;b&gt;null&lt;/b&gt;
     */
    public File getFile() {
<span class="fc" id="L451">        return createFile(getFileLocator());</span>
    }

    /**
     * Gets a {@code FileLocator} object with the specification of the file stored by this {@code FileHandler}. Note that
     * this method returns the internal data managed by this {@code FileHandler} as it was defined. This is not necessarily
     * the same as the data returned by the single access methods like {@code getFileName()} or {@code getURL()}: These
     * methods try to derive missing data from other values that have been set.
     *
     * @return a {@code FileLocator} with the referenced file
     */
    public FileLocator getFileLocator() {
<span class="fc" id="L463">        return fileLocator.get();</span>
    }

    /**
     * Gets the name of the file. If only a URL is defined, the file name is derived from there.
     *
     * @return the file name
     */
    public String getFileName() {
<span class="fc" id="L472">        final FileLocator locator = getFileLocator();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (locator.getFileName() != null) {</span>
<span class="fc" id="L474">            return locator.getFileName();</span>
        }

<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (locator.getSourceURL() != null) {</span>
<span class="fc" id="L478">            return FileLocatorUtils.getFileName(locator.getSourceURL());</span>
        }

<span class="fc" id="L481">        return null;</span>
    }

    /**
     * Gets the {@code FileSystem} to be used by this object when locating files. Result is never &lt;b&gt;null&lt;/b&gt;; if no file
     * system has been set, the default file system is returned.
     *
     * @return the used {@code FileSystem}
     */
    public FileSystem getFileSystem() {
<span class="fc" id="L491">        return FileLocatorUtils.getFileSystem(getFileLocator());</span>
    }

    /**
     * Gets the {@code FileLocationStrategy} to be applied when accessing the associated file. This method never returns
     * &lt;b&gt;null&lt;/b&gt;. If a {@code FileLocationStrategy} has been set, it is returned. Otherwise, result is the default
     * {@code FileLocationStrategy}.
     *
     * @return the {@code FileLocationStrategy} to be used
     */
    public FileLocationStrategy getLocationStrategy() {
<span class="fc" id="L502">        return FileLocatorUtils.getLocationStrategy(getFileLocator());</span>
    }

    /**
     * Gets the full path to the associated file. The return value is a valid {@code File} path only if this location is
     * based on a file on the local disk. If the file was loaded from a packed archive, the returned value is the string
     * form of the URL from which the file was loaded.
     *
     * @return the full path to the associated file
     */
    public String getPath() {
<span class="fc" id="L513">        final FileLocator locator = getFileLocator();</span>
<span class="fc" id="L514">        final File file = createFile(locator);</span>
<span class="fc" id="L515">        return FileLocatorUtils.getFileSystem(locator).getPath(file, locator.getSourceURL(), locator.getBasePath(), locator.getFileName());</span>
    }

    /**
     * Gets the location of the associated file as a URL. If a URL is set, it is directly returned. Otherwise, an attempt
     * to locate the referenced file is made.
     *
     * @return a URL to the associated file; can be &lt;b&gt;null&lt;/b&gt; if the location is unspecified
     */
    public URL getURL() {
<span class="fc" id="L525">        final FileLocator locator = getFileLocator();</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        return locator.getSourceURL() != null ? locator.getSourceURL() : FileLocatorUtils.locate(locator);</span>
    }

    /**
     * Injects a {@code FileLocator} pointing to the specified URL if the current {@code FileBased} object implements the
     * {@code FileLocatorAware} interface.
     *
     * @param url the URL for the locator
     */
    private void injectFileLocator(final URL url) {
<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (url == null) {</span>
<span class="fc" id="L537">            injectNullFileLocator();</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        } else if (getContent() instanceof FileLocatorAware) {</span>
<span class="fc" id="L539">            final FileLocator locator = prepareNullLocatorBuilder().sourceURL(url).create();</span>
<span class="fc" id="L540">            ((FileLocatorAware) getContent()).initFileLocator(locator);</span>
        }
<span class="fc" id="L542">    }</span>

    /**
     * Checks whether the associated {@code FileBased} object implements the {@code FileLocatorAware} interface. If this is
     * the case, a {@code FileLocator} instance is injected which returns only &lt;b&gt;null&lt;/b&gt; values. This method is called if
     * no file location is available (e.g. if data is to be loaded from a stream). The encoding of the injected locator is
     * derived from this object.
     */
    private void injectNullFileLocator() {
<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (getContent() instanceof FileLocatorAware) {</span>
<span class="fc" id="L552">            final FileLocator locator = prepareNullLocatorBuilder().create();</span>
<span class="fc" id="L553">            ((FileLocatorAware) getContent()).initFileLocator(locator);</span>
        }
<span class="fc" id="L555">    }</span>

    /**
     * Tests whether a location is defined for this {@code FileHandler}.
     *
     * @return &lt;b&gt;true&lt;/b&gt; if a location is defined, &lt;b&gt;false&lt;/b&gt; otherwise
     */
    public boolean isLocationDefined() {
<span class="fc" id="L563">        return FileLocatorUtils.isLocationDefined(getFileLocator());</span>
    }

    /**
     * Loads the associated file from the underlying location. If no location has been set, an exception is thrown.
     *
     * @throws ConfigurationException if loading of the configuration fails
     */
    public void load() throws ConfigurationException {
<span class="fc" id="L572">        load(checkContentAndGetLocator());</span>
<span class="fc" id="L573">    }</span>

    /**
     * Loads the associated file from the specified {@code File}.
     *
     * @param file the file to load
     * @throws ConfigurationException if an error occurs
     */
    public void load(final File file) throws ConfigurationException {
        final URL url;
        try {
<span class="fc" id="L584">            url = FileLocatorUtils.toURL(file);</span>
<span class="nc" id="L585">        } catch (final MalformedURLException e1) {</span>
<span class="nc" id="L586">            throw new ConfigurationException(&quot;Cannot create URL from file &quot; + file);</span>
<span class="fc" id="L587">        }</span>

<span class="fc" id="L589">        load(url);</span>
<span class="fc" id="L590">    }</span>

    /**
     * Internal helper method for loading the associated file from the location specified in the given {@code FileLocator}.
     *
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L599">        load(FileLocatorUtils.locateOrThrow(locator), locator);</span>
<span class="fc" id="L600">    }</span>

    /**
     * Loads the associated file from the specified stream, using the encoding returned by {@link #getEncoding()}.
     *
     * @param in the input stream
     * @throws ConfigurationException if an error occurs during the load operation
     */
    public void load(final InputStream in) throws ConfigurationException {
<span class="fc" id="L609">        load(in, checkContentAndGetLocator());</span>
<span class="fc" id="L610">    }</span>

    /**
     * Internal helper method for loading a file from the given input stream.
     *
     * @param in the input stream
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final InputStream in, final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L620">        load(in, locator.getEncoding());</span>
<span class="fc" id="L621">    }</span>

    /**
     * Loads the associated file from the specified stream, using the specified encoding. If the encoding is &lt;b&gt;null&lt;/b&gt;,
     * the default encoding is used.
     *
     * @param in the input stream
     * @param encoding the encoding used, {@code null} to use the default encoding
     * @throws ConfigurationException if an error occurs during the load operation
     */
    public void load(final InputStream in, final String encoding) throws ConfigurationException {
<span class="fc" id="L632">        loadFromStream(in, encoding, null);</span>
<span class="fc" id="L633">    }</span>

    /**
     * Loads the associated file from the specified reader.
     *
     * @param in the reader
     * @throws ConfigurationException if an error occurs during the load operation
     */
    public void load(final Reader in) throws ConfigurationException {
<span class="fc" id="L642">        checkContent();</span>
<span class="fc" id="L643">        injectNullFileLocator();</span>
<span class="fc" id="L644">        loadFromReader(in);</span>
<span class="fc" id="L645">    }</span>

    /**
     * Loads the associated file from the given file name. The file name is interpreted in the context of the already set
     * location (e.g. if it is a relative file name, a base path is applied if available). The underlying location is not
     * changed.
     *
     * @param fileName the name of the file to be loaded
     * @throws ConfigurationException if an error occurs
     */
    public void load(final String fileName) throws ConfigurationException {
<span class="fc" id="L656">        load(fileName, checkContentAndGetLocator());</span>
<span class="fc" id="L657">    }</span>

    /**
     * Internal helper method for loading a file from a file name.
     *
     * @param fileName the file name
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final String fileName, final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L667">        final FileLocator locFileName = createLocatorWithFileName(fileName, locator);</span>
<span class="fc" id="L668">        final URL url = FileLocatorUtils.locateOrThrow(locFileName);</span>
<span class="fc" id="L669">        load(url, locator);</span>
<span class="fc" id="L670">    }</span>

    /**
     * Loads the associated file from the specified URL. The location stored in this object is not changed.
     *
     * @param url the URL of the file to be loaded
     * @throws ConfigurationException if an error occurs
     */
    public void load(final URL url) throws ConfigurationException {
<span class="fc" id="L679">        load(url, checkContentAndGetLocator());</span>
<span class="fc" id="L680">    }</span>

    /**
     * Internal helper method for loading a file from the given URL.
     *
     * @param url the URL
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs
     */
    private void load(final URL url, final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L690">        InputStream in = null;</span>

        try {
<span class="fc" id="L693">            final FileSystem fileSystem = FileLocatorUtils.getFileSystem(locator);</span>
<span class="fc" id="L694">            final URLConnectionOptions urlConnectionOptions = locator.getURLConnectionOptions();</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">            in = urlConnectionOptions == null ? fileSystem.getInputStream(url) : fileSystem.getInputStream(url, urlConnectionOptions);</span>
<span class="fc" id="L696">            loadFromStream(in, locator.getEncoding(), url);</span>
<span class="fc" id="L697">        } catch (final ConfigurationException e) {</span>
<span class="fc" id="L698">            throw e;</span>
<span class="nc" id="L699">        } catch (final Exception e) {</span>
<span class="nc" id="L700">            throw new ConfigurationException(&quot;Unable to load the configuration from the URL &quot; + url, e);</span>
        } finally {
<span class="fc" id="L702">            closeSilent(in);</span>
        }
<span class="fc" id="L704">    }</span>

    /**
     * Internal helper method for loading a file from the given reader.
     *
     * @param in the reader
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromReader(final Reader in) throws ConfigurationException {
<span class="fc" id="L713">        fireLoadingEvent();</span>
        try {
<span class="fc" id="L715">            getContent().read(in);</span>
<span class="fc" id="L716">        } catch (final IOException ioex) {</span>
<span class="fc" id="L717">            throw new ConfigurationException(ioex);</span>
        } finally {
<span class="fc" id="L719">            fireLoadedEvent();</span>
        }
<span class="fc" id="L721">    }</span>

    /**
     * Internal helper method for loading a file from an input stream.
     *
     * @param in the input stream
     * @param encoding the encoding
     * @param url the URL of the file to be loaded (if known)
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromStream(final InputStream in, final String encoding, final URL url) throws ConfigurationException {
<span class="fc" id="L732">        checkContent();</span>
<span class="fc" id="L733">        final SynchronizerSupport syncSupport = fetchSynchronizerSupport();</span>
<span class="fc" id="L734">        syncSupport.lock(LockMode.WRITE);</span>
        try {
<span class="fc" id="L736">            injectFileLocator(url);</span>

<span class="fc bfc" id="L738" title="All 2 branches covered.">            if (getContent() instanceof InputStreamSupport) {</span>
<span class="fc" id="L739">                loadFromStreamDirectly(in);</span>
            } else {
<span class="fc" id="L741">                loadFromTransformedStream(in, encoding);</span>
            }
        } finally {
<span class="fc" id="L744">            syncSupport.unlock(LockMode.WRITE);</span>
        }
<span class="fc" id="L746">    }</span>

    /**
     * Loads data from an input stream if the associated {@code FileBased} object implements the {@code InputStreamSupport}
     * interface.
     *
     * @param in the input stream
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromStreamDirectly(final InputStream in) throws ConfigurationException {
        try {
<span class="fc" id="L757">            ((InputStreamSupport) getContent()).read(in);</span>
<span class="fc" id="L758">        } catch (final IOException e) {</span>
<span class="fc" id="L759">            throw new ConfigurationException(e);</span>
<span class="fc" id="L760">        }</span>
<span class="fc" id="L761">    }</span>

    /**
     * Internal helper method for transforming an input stream to a reader and reading its content.
     *
     * @param in the input stream
     * @param encoding the encoding
     * @throws ConfigurationException if an error occurs
     */
    private void loadFromTransformedStream(final InputStream in, final String encoding) throws ConfigurationException {
<span class="fc" id="L771">        Reader reader = null;</span>

<span class="fc bfc" id="L773" title="All 2 branches covered.">        if (encoding != null) {</span>
            try {
<span class="fc" id="L775">                reader = new InputStreamReader(in, encoding);</span>
<span class="nc" id="L776">            } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L777">                throw new ConfigurationException(&quot;The requested encoding is not supported, try the default encoding.&quot;, e);</span>
<span class="fc" id="L778">            }</span>
        }

<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (reader == null) {</span>
<span class="fc" id="L782">            reader = new InputStreamReader(in);</span>
        }

<span class="fc" id="L785">        loadFromReader(reader);</span>
<span class="fc" id="L786">    }</span>

    /**
     * Locates the referenced file if necessary and ensures that the associated {@link FileLocator} is fully initialized.
     * When accessing the referenced file the information stored in the associated {@code FileLocator} is used. If this
     * information is incomplete (e.g. only the file name is set), an attempt to locate the file may have to be performed on
     * each access. By calling this method such an attempt is performed once, and the results of a successful localization
     * are stored. Hence, later access to the referenced file can be more efficient. Also, all properties pointing to the
     * referenced file in this object's {@code FileLocator} are set (i.e. the URL, the base path, and the file name). If the
     * referenced file cannot be located, result is &lt;b&gt;false&lt;/b&gt;. This means that the information in the current
     * {@code FileLocator} is insufficient or wrong. If the {@code FileLocator} is already fully defined, it is not changed.
     *
     * @return a flag whether the referenced file could be located successfully
     * @see FileLocatorUtils#fullyInitializedLocator(FileLocator)
     */
    public boolean locate() {
        boolean result;
        boolean done;

        do {
<span class="fc" id="L806">            final FileLocator locator = getFileLocator();</span>
<span class="fc" id="L807">            FileLocator fullLocator = FileLocatorUtils.fullyInitializedLocator(locator);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">            if (fullLocator == null) {</span>
<span class="fc" id="L809">                result = false;</span>
<span class="fc" id="L810">                fullLocator = locator;</span>
            } else {
<span class="pc bpc" id="L812" title="1 of 4 branches missed.">                result = fullLocator != locator || FileLocatorUtils.isFullyInitialized(locator);</span>
            }
<span class="fc" id="L814">            done = fileLocator.compareAndSet(locator, fullLocator);</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">        } while (!done);</span>

<span class="fc" id="L817">        return result;</span>
    }

    /**
     * Prepares a builder for a {@code FileLocator} which does not have a defined file location. Other properties (e.g.
     * encoding or file system) are initialized from the {@code FileLocator} associated with this object.
     *
     * @return the initialized builder for a {@code FileLocator}
     */
    private FileLocatorBuilder prepareNullLocatorBuilder() {
<span class="fc" id="L827">        return FileLocatorUtils.fileLocator(getFileLocator()).sourceURL(null).basePath(null).fileName(null);</span>
    }

    /**
     * Removes the specified listener from this object.
     *
     * @param l the listener to be removed
     */
    public void removeFileHandlerListener(final FileHandlerListener l) {
<span class="fc" id="L836">        listeners.remove(l);</span>
<span class="fc" id="L837">    }</span>

    /**
     * Resets the {@code FileSystem} used by this object. It is set to the default file system.
     */
    public void resetFileSystem() {
<span class="fc" id="L843">        setFileSystem(null);</span>
<span class="fc" id="L844">    }</span>

    /**
     * Saves the associated file to the current location set for this object. Before this method can be called a valid
     * location must have been set.
     *
     * @throws ConfigurationException if an error occurs or no location has been set yet
     */
    public void save() throws ConfigurationException {
<span class="fc" id="L853">        save(checkContentAndGetLocator());</span>
<span class="fc" id="L854">    }</span>

    /**
     * Saves the associated file to the specified {@code File}. The file is created automatically if it doesn't exist. This
     * does not change the location of this object (use {@link #setFile} if you need it).
     *
     * @param file the target file
     * @throws ConfigurationException if an error occurs during the save operation
     */
    public void save(final File file) throws ConfigurationException {
<span class="fc" id="L864">        save(file, checkContentAndGetLocator());</span>
<span class="fc" id="L865">    }</span>

    /**
     * Internal helper method for saving data to the given {@code File}.
     *
     * @param file the target file
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save operation
     */
    private void save(final File file, final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L875">        OutputStream out = null;</span>

        try {
<span class="fc" id="L878">            out = FileLocatorUtils.getFileSystem(locator).getOutputStream(file);</span>
<span class="fc" id="L879">            saveToStream(out, locator.getEncoding(), file.toURI().toURL());</span>
<span class="nc" id="L880">        } catch (final MalformedURLException muex) {</span>
<span class="nc" id="L881">            throw new ConfigurationException(muex);</span>
        } finally {
<span class="fc" id="L883">            closeSilent(out);</span>
        }
<span class="fc" id="L885">    }</span>

    /**
     * Internal helper method for saving data to the internal location stored for this object.
     *
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save operation
     */
    private void save(final FileLocator locator) throws ConfigurationException {
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if (!FileLocatorUtils.isLocationDefined(locator)) {</span>
<span class="fc" id="L895">            throw new ConfigurationException(&quot;No file location has been set!&quot;);</span>
        }

<span class="fc bfc" id="L898" title="All 2 branches covered.">        if (locator.getSourceURL() != null) {</span>
<span class="fc" id="L899">            save(locator.getSourceURL(), locator);</span>
        } else {
<span class="fc" id="L901">            save(locator.getFileName(), locator);</span>
        }
<span class="fc" id="L903">    }</span>

    /**
     * Saves the associated file to the specified stream using the encoding returned by {@link #getEncoding()}.
     *
     * @param out the output stream
     * @throws ConfigurationException if an error occurs during the save operation
     */
    public void save(final OutputStream out) throws ConfigurationException {
<span class="fc" id="L912">        save(out, checkContentAndGetLocator());</span>
<span class="fc" id="L913">    }</span>

    /**
     * Internal helper method for saving a file to the given output stream.
     *
     * @param out the output stream
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save operation
     */
    private void save(final OutputStream out, final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L923">        save(out, locator.getEncoding());</span>
<span class="fc" id="L924">    }</span>

    /**
     * Saves the associated file to the specified stream using the specified encoding. If the encoding is &lt;b&gt;null&lt;/b&gt;, the
     * default encoding is used.
     *
     * @param out the output stream
     * @param encoding the encoding to be used, {@code null} to use the default encoding
     * @throws ConfigurationException if an error occurs during the save operation
     */
    public void save(final OutputStream out, final String encoding) throws ConfigurationException {
<span class="fc" id="L935">        saveToStream(out, encoding, null);</span>
<span class="fc" id="L936">    }</span>

    /**
     * Saves the associated file to the specified file name. This does not change the location of this object (use
     * {@link #setFileName(String)} if you need it).
     *
     * @param fileName the file name
     * @throws ConfigurationException if an error occurs during the save operation
     */
    public void save(final String fileName) throws ConfigurationException {
<span class="fc" id="L946">        save(fileName, checkContentAndGetLocator());</span>
<span class="fc" id="L947">    }</span>

    /**
     * Internal helper method for saving data to the given file name.
     *
     * @param fileName the path to the target file
     * @param locator the current {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save operation
     */
    private void save(final String fileName, final FileLocator locator) throws ConfigurationException {
        final URL url;
        try {
<span class="fc" id="L959">            url = FileLocatorUtils.getFileSystem(locator).getURL(locator.getBasePath(), fileName);</span>
<span class="fc" id="L960">        } catch (final MalformedURLException e) {</span>
<span class="fc" id="L961">            throw new ConfigurationException(e);</span>
<span class="fc" id="L962">        }</span>

<span class="fc bfc" id="L964" title="All 2 branches covered.">        if (url == null) {</span>
<span class="fc" id="L965">            throw new ConfigurationException(&quot;Cannot locate configuration source &quot; + fileName);</span>
        }
<span class="fc" id="L967">        save(url, locator);</span>
<span class="fc" id="L968">    }</span>

    /**
     * Saves the associated file to the specified URL. This does not change the location of this object (use
     * {@link #setURL(URL)} if you need it).
     *
     * @param url the URL
     * @throws ConfigurationException if an error occurs during the save operation
     */
    public void save(final URL url) throws ConfigurationException {
<span class="fc" id="L978">        save(url, checkContentAndGetLocator());</span>
<span class="fc" id="L979">    }</span>

    /**
     * Internal helper method for saving data to the given URL.
     *
     * @param url the target URL
     * @param locator the {@code FileLocator}
     * @throws ConfigurationException if an error occurs during the save operation
     */
    private void save(final URL url, final FileLocator locator) throws ConfigurationException {
<span class="fc" id="L989">        OutputStream out = null;</span>
        try {
<span class="fc" id="L991">            out = FileLocatorUtils.getFileSystem(locator).getOutputStream(url);</span>
<span class="fc" id="L992">            saveToStream(out, locator.getEncoding(), url);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">            if (out instanceof VerifiableOutputStream) {</span>
                try {
<span class="fc" id="L995">                    ((VerifiableOutputStream) out).verify();</span>
<span class="fc" id="L996">                } catch (final IOException e) {</span>
<span class="fc" id="L997">                    throw new ConfigurationException(e);</span>
<span class="fc" id="L998">                }</span>
            }
        } finally {
<span class="fc" id="L1001">            closeSilent(out);</span>
        }
<span class="fc" id="L1003">    }</span>

    /**
     * Saves the associated file to the given {@code Writer}.
     *
     * @param out the {@code Writer}
     * @throws ConfigurationException if an error occurs during the save operation
     */
    public void save(final Writer out) throws ConfigurationException {
<span class="fc" id="L1012">        checkContent();</span>
<span class="fc" id="L1013">        injectNullFileLocator();</span>
<span class="fc" id="L1014">        saveToWriter(out);</span>
<span class="fc" id="L1015">    }</span>

    /**
     * Internal helper method for saving a file to the given stream.
     *
     * @param out the output stream
     * @param encoding the encoding
     * @param url the URL of the output file if known
     * @throws ConfigurationException if an error occurs
     */
    private void saveToStream(final OutputStream out, final String encoding, final URL url) throws ConfigurationException {
<span class="fc" id="L1026">        checkContent();</span>
<span class="fc" id="L1027">        final SynchronizerSupport syncSupport = fetchSynchronizerSupport();</span>
<span class="fc" id="L1028">        syncSupport.lock(LockMode.WRITE);</span>
        try {
<span class="fc" id="L1030">            injectFileLocator(url);</span>
<span class="fc" id="L1031">            Writer writer = null;</span>

<span class="fc bfc" id="L1033" title="All 2 branches covered.">            if (encoding != null) {</span>
                try {
<span class="fc" id="L1035">                    writer = new OutputStreamWriter(out, encoding);</span>
<span class="nc" id="L1036">                } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L1037">                    throw new ConfigurationException(&quot;The requested encoding is not supported, try the default encoding.&quot;, e);</span>
<span class="fc" id="L1038">                }</span>
            }

<span class="fc bfc" id="L1041" title="All 2 branches covered.">            if (writer == null) {</span>
<span class="fc" id="L1042">                writer = new OutputStreamWriter(out);</span>
            }

<span class="fc" id="L1045">            saveToWriter(writer);</span>
        } finally {
<span class="fc" id="L1047">            syncSupport.unlock(LockMode.WRITE);</span>
        }
<span class="fc" id="L1049">    }</span>

    /**
     * Internal helper method for saving a file into the given writer.
     *
     * @param out the writer
     * @throws ConfigurationException if an error occurs
     */
    private void saveToWriter(final Writer out) throws ConfigurationException {
<span class="fc" id="L1058">        fireSavingEvent();</span>
        try {
<span class="fc" id="L1060">            getContent().write(out);</span>
<span class="fc" id="L1061">        } catch (final IOException ioex) {</span>
<span class="fc" id="L1062">            throw new ConfigurationException(ioex);</span>
        } finally {
<span class="fc" id="L1064">            fireSavedEvent();</span>
        }
<span class="fc" id="L1066">    }</span>

    /**
     * Sets the base path. The base path is typically either a path to a directory or a URL. Together with the value passed
     * to the {@code setFileName()} method it defines the location of the configuration file to be loaded. The strategies
     * for locating the file are quite tolerant. For instance if the file name is already an absolute path or a fully
     * defined URL, the base path will be ignored. The base path can also be a URL, in which case the file name is
     * interpreted in this URL's context. If other methods are used for determining the location of the associated file
     * (e.g. {@code setFile()} or {@code setURL()}), the base path is automatically set. Setting the base path using this
     * method automatically sets the URL to &lt;b&gt;null&lt;/b&gt; because it has to be determined anew based on the file name and the
     * base path.
     *
     * @param basePath the base path.
     */
    public void setBasePath(final String basePath) {
<span class="fc" id="L1081">        final String path = normalizeFileURL(basePath);</span>
<span class="fc" id="L1082">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1085">                builder.basePath(path);</span>
<span class="fc" id="L1086">                builder.sourceURL(null);</span>
<span class="fc" id="L1087">            }</span>
<span class="fc" id="L1088">        }.update();</span>
<span class="fc" id="L1089">    }</span>

    /**
     * Sets the encoding of the associated file. The encoding applies if binary files are loaded. Note that in this case
     * setting an encoding is recommended; otherwise the platform's default encoding is used.
     *
     * @param encoding the encoding of the associated file
     */
    public void setEncoding(final String encoding) {
<span class="fc" id="L1098">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1101">                builder.encoding(encoding);</span>
<span class="fc" id="L1102">            }</span>
<span class="fc" id="L1103">        }.update();</span>
<span class="fc" id="L1104">    }</span>

    /**
     * Sets the location of the associated file as a {@code File} object. The passed in {@code File} is made absolute if it
     * is not yet. Then the file's path component becomes the base path and its name component becomes the file name.
     *
     * @param file the location of the associated file
     */
    public void setFile(final File file) {
<span class="fc" id="L1113">        final String fileName = file.getName();</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        final String basePath = file.getParentFile() != null ? file.getParentFile().getAbsolutePath() : null;</span>
<span class="fc" id="L1115">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1118">                builder.fileName(fileName).basePath(basePath).sourceURL(null);</span>
<span class="fc" id="L1119">            }</span>
<span class="fc" id="L1120">        }.update();</span>
<span class="fc" id="L1121">    }</span>

    /**
     * Sets the file to be accessed by this {@code FileHandler} as a {@code FileLocator} object.
     *
     * @param locator the {@code FileLocator} with the definition of the file to be accessed (must not be &lt;b&gt;null&lt;/b&gt;
     * @throws IllegalArgumentException if the {@code FileLocator} is &lt;b&gt;null&lt;/b&gt;
     */
    public void setFileLocator(final FileLocator locator) {
<span class="fc bfc" id="L1130" title="All 2 branches covered.">        if (locator == null) {</span>
<span class="fc" id="L1131">            throw new IllegalArgumentException(&quot;FileLocator must not be null!&quot;);</span>
        }

<span class="fc" id="L1134">        fileLocator.set(locator);</span>
<span class="fc" id="L1135">        fireLocationChangedEvent();</span>
<span class="fc" id="L1136">    }</span>

    /**
     * Sets the name of the file. The passed in file name can contain a relative path. It must be used when referring files
     * with relative paths from classpath. Use {@code setPath()} to set a full qualified file name. The URL is set to
     * &lt;b&gt;null&lt;/b&gt; as it has to be determined anew based on the file name and the base path.
     *
     * @param fileName the name of the file
     */
    public void setFileName(final String fileName) {
<span class="fc" id="L1146">        final String name = normalizeFileURL(fileName);</span>
<span class="fc" id="L1147">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1150">                builder.fileName(name);</span>
<span class="fc" id="L1151">                builder.sourceURL(null);</span>
<span class="fc" id="L1152">            }</span>
<span class="fc" id="L1153">        }.update();</span>
<span class="fc" id="L1154">    }</span>

    /**
     * Sets the {@code FileSystem} to be used by this object when locating files. If a &lt;b&gt;null&lt;/b&gt; value is passed in, the
     * file system is reset to the default file system.
     *
     * @param fileSystem the {@code FileSystem}
     */
    public void setFileSystem(final FileSystem fileSystem) {
<span class="fc" id="L1163">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1166">                builder.fileSystem(fileSystem);</span>
<span class="fc" id="L1167">            }</span>
<span class="fc" id="L1168">        }.update();</span>
<span class="fc" id="L1169">    }</span>

    /**
     * Sets the {@code FileLocationStrategy} to be applied when accessing the associated file. The strategy is stored in the
     * underlying {@link FileLocator}. The argument can be &lt;b&gt;null&lt;/b&gt;; this causes the default {@code FileLocationStrategy}
     * to be used.
     *
     * @param strategy the {@code FileLocationStrategy}
     * @see FileLocatorUtils#DEFAULT_LOCATION_STRATEGY
     */
    public void setLocationStrategy(final FileLocationStrategy strategy) {
<span class="fc" id="L1180">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1183">                builder.locationStrategy(strategy);</span>
<span class="fc" id="L1184">            }</span>

<span class="fc" id="L1186">        }.update();</span>
<span class="fc" id="L1187">    }</span>

    /**
     * Sets the location of the associated file as a full or relative path name. The passed in path should represent a valid
     * file name on the file system. It must not be used to specify relative paths for files that exist in classpath, either
     * plain file system or compressed archive, because this method expands any relative path to an absolute one which may
     * end in an invalid absolute path for classpath references.
     *
     * @param path the full path name of the associated file
     */
    public void setPath(final String path) {
<span class="fc" id="L1198">        setFile(new File(path));</span>
<span class="fc" id="L1199">    }</span>

    /**
     * Sets the location of the associated file as a URL. For loading this can be an arbitrary URL with a supported
     * protocol. If the file is to be saved, too, a URL with the &amp;quot;file&amp;quot; protocol should be provided. This method
     * sets the file name and the base path to &lt;b&gt;null&lt;/b&gt;. They have to be determined anew based on the new URL.
     *
     * @param url the location of the file as URL
     */
    public void setURL(final URL url) {
<span class="fc" id="L1209">        setURL(url, URLConnectionOptions.DEFAULT);</span>
<span class="fc" id="L1210">    }</span>

    /**
     * Sets the location of the associated file as a URL. For loading this can be an arbitrary URL with a supported
     * protocol. If the file is to be saved, too, a URL with the &amp;quot;file&amp;quot; protocol should be provided. This method
     * sets the file name and the base path to &lt;b&gt;null&lt;/b&gt;. They have to be determined anew based on the new URL.
     *
     * @param url the location of the file as URL
     * @param urlConnectionOptions URL connection options
     * @since 2.8.0
     */
    public void setURL(final URL url, final URLConnectionOptions urlConnectionOptions) {
<span class="fc" id="L1222">        new AbstractUpdater() {</span>
            @Override
            protected void updateBuilder(final FileLocatorBuilder builder) {
<span class="fc" id="L1225">                builder.sourceURL(url);</span>
<span class="fc" id="L1226">                builder.urlConnectionOptions(urlConnectionOptions);</span>
<span class="fc" id="L1227">                builder.basePath(null).fileName(null);</span>
<span class="fc" id="L1228">            }</span>
<span class="fc" id="L1229">        }.update();</span>
<span class="fc" id="L1230">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>