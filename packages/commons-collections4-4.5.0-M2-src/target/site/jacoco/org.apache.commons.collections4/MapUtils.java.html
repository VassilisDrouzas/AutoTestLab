<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Collections</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4</a> &gt; <span class="el_source">MapUtils.java</span></div><h1>MapUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4;

import java.io.PrintStream;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.apache.commons.collections4.map.AbstractMapDecorator;
import org.apache.commons.collections4.map.AbstractSortedMapDecorator;
import org.apache.commons.collections4.map.FixedSizeMap;
import org.apache.commons.collections4.map.FixedSizeSortedMap;
import org.apache.commons.collections4.map.LazyMap;
import org.apache.commons.collections4.map.LazySortedMap;
import org.apache.commons.collections4.map.ListOrderedMap;
import org.apache.commons.collections4.map.MultiValueMap;
import org.apache.commons.collections4.map.PredicatedMap;
import org.apache.commons.collections4.map.PredicatedSortedMap;
import org.apache.commons.collections4.map.TransformedMap;
import org.apache.commons.collections4.map.TransformedSortedMap;
import org.apache.commons.collections4.map.UnmodifiableMap;
import org.apache.commons.collections4.map.UnmodifiableSortedMap;

/**
 * Provides utility methods and decorators for {@link Map} and {@link SortedMap} instances.
 * &lt;p&gt;
 * It contains various type safe methods as well as other useful features like deep copying.
 * &lt;/p&gt;
 * &lt;p&gt;
 * It also provides the following decorators:
 * &lt;/p&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #fixedSizeMap(Map)}
 * &lt;li&gt;{@link #fixedSizeSortedMap(SortedMap)}
 * &lt;li&gt;{@link #lazyMap(Map,Factory)}
 * &lt;li&gt;{@link #lazyMap(Map,Transformer)}
 * &lt;li&gt;{@link #lazySortedMap(SortedMap,Factory)}
 * &lt;li&gt;{@link #lazySortedMap(SortedMap,Transformer)}
 * &lt;li&gt;{@link #predicatedMap(Map,Predicate,Predicate)}
 * &lt;li&gt;{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}
 * &lt;li&gt;{@link #transformedMap(Map, Transformer, Transformer)}
 * &lt;li&gt;{@link #transformedSortedMap(SortedMap, Transformer, Transformer)}
 * &lt;li&gt;{@link #multiValueMap( Map )}
 * &lt;li&gt;{@link #multiValueMap( Map, Class )}
 * &lt;li&gt;{@link #multiValueMap( Map, Factory )}
 * &lt;/ul&gt;
 *
 * @since 1.0
 */
@SuppressWarnings(&quot;deprecation&quot;)
public class MapUtils {

    /**
     * An empty unmodifiable sorted map. This is not provided in the JDK.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L87">    public static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap&lt;&gt;());</span>

    /**
     * String used to indent the verbose and debug Map prints.
     */
    private static final String INDENT_STRING = &quot;    &quot;;

    /**
     * Applies the {@code getFunction} and returns its result if non-null, if null returns the result of applying the
     * default function.
     *
     * @param &lt;K&gt; The key type.
     * @param &lt;R&gt; The result type.
     * @param map The map to query.
     * @param key The key into the map.
     * @param getFunction The get function.
     * @param defaultFunction The function to provide a default value.
     * @return The result of applying a function.
     */
    private static &lt;K, R&gt; R applyDefaultFunction(final Map&lt;? super K, ?&gt; map, final K key,
            final BiFunction&lt;Map&lt;? super K, ?&gt;, K, R&gt; getFunction, final Function&lt;K, R&gt; defaultFunction) {
<span class="fc" id="L108">        return applyDefaultFunction(map, key, getFunction, defaultFunction, null);</span>
    }

    /**
     * Applies the {@code getFunction} and returns its result if non-null, if null returns the result of applying the
     * default function.
     *
     * @param &lt;K&gt; The key type.
     * @param &lt;R&gt; The result type.
     * @param map The map to query.
     * @param key The key into the map.
     * @param getFunction The get function.
     * @param defaultFunction The function to provide a default value.
     * @param defaultValue The default value.
     * @return The result of applying a function.
     */
    private static &lt;K, R&gt; R applyDefaultFunction(final Map&lt;? super K, ?&gt; map, final K key,
            final BiFunction&lt;Map&lt;? super K, ?&gt;, K, R&gt; getFunction, final Function&lt;K, R&gt; defaultFunction,
            final R defaultValue) {
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">        R value = map != null &amp;&amp; getFunction != null ? getFunction.apply(map, key) : null;</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            value = defaultFunction != null ? defaultFunction.apply(key) : null;</span>
        }
<span class="fc bfc" id="L131" title="All 2 branches covered.">        return value != null ? value : defaultValue;</span>
    }

    /**
     * Applies the {@code getFunction} and returns its result if non-null, if null returns the {@code defaultValue}.
     *
     * @param &lt;K&gt; The key type.
     * @param &lt;R&gt; The result type.
     * @param map The map to query.
     * @param key The key into the map.
     * @param getFunction The get function.
     * @param defaultValue The default value.
     * @return The result of applying a function.
     */
    private static &lt;K, R&gt; R applyDefaultValue(final Map&lt;? super K, ?&gt; map, final K key,
            final BiFunction&lt;Map&lt;? super K, ?&gt;, K, R&gt; getFunction, final R defaultValue) {
<span class="pc bpc" id="L147" title="1 of 4 branches missed.">        final R value = map != null &amp;&amp; getFunction != null ? getFunction.apply(map, key) : null;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        return value == null ? defaultValue : value;</span>
    }

    /**
     * Prints the given map with nice line breaks.
     * &lt;p&gt;
     * This method prints a nicely formatted String describing the Map. Each map entry will be printed with key, value
     * and value class name. When the value is a Map, recursive behavior occurs.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the
     * stream as required.
     * &lt;/p&gt;
     *
     * @param out the stream to print to, must not be null
     * @param label The label to be used, may be {@code null}. If {@code null}, the label is not output. It
     *        typically represents the name of the property in a bean or similar.
     * @param map The map to print, may be {@code null}. If {@code null}, the text 'null' is output.
     * @throws NullPointerException if the stream is {@code null}
     */
    public static void debugPrint(final PrintStream out, final Object label, final Map&lt;?, ?&gt; map) {
<span class="fc" id="L169">        verbosePrintInternal(out, label, map, new ArrayDeque&lt;&gt;(), true);</span>
<span class="fc" id="L170">    }</span>

    /**
     * Returns an immutable empty map if the argument is {@code null}, or the argument itself otherwise.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map, possibly {@code null}
     * @return an empty map if the argument is {@code null}
     */
    public static &lt;K, V&gt; Map&lt;K, V&gt; emptyIfNull(final Map&lt;K, V&gt; map) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        return map == null ? Collections.&lt;K, V&gt;emptyMap() : map;</span>
    }

    /**
     * Returns a fixed-sized map backed by the given map. Elements may not be added or removed from the returned map,
     * but existing elements can be changed (for instance, via the {@link Map#put(Object,Object)} method).
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map whose size to fix, must not be null
     * @return a fixed-size map backed by that map
     * @throws NullPointerException if the Map is null
     */
    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; fixedSizeMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L195">        return FixedSizeMap.fixedSizeMap(map);</span>
    }

    /**
     * Returns a fixed-sized sorted map backed by the given sorted map. Elements may not be added or removed from the
     * returned map, but existing elements can be changed (for instance, via the {@link Map#put(Object,Object)} method).
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map whose size to fix, must not be null
     * @return a fixed-size map backed by that map
     * @throws NullPointerException if the SortedMap is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; fixedSizeSortedMap(final SortedMap&lt;K, V&gt; map) {
<span class="fc" id="L209">        return FixedSizeSortedMap.fixedSizeSortedMap(map);</span>
    }

    /**
     * Gets a Boolean from a Map in a null-safe manner.
     * &lt;p&gt;
     * If the value is a {@code Boolean} it is returned directly. If the value is a {@code String} and it
     * equals 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a
     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.
     * Otherwise, {@code null} is returned.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Boolean, {@code null} if null map input
     */
    public static &lt;K&gt; Boolean getBoolean(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc" id="L228">            final Object answer = map.get(key);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (answer != null) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                if (answer instanceof Boolean) {</span>
<span class="fc" id="L231">                    return (Boolean) answer;</span>
                }
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (answer instanceof String) {</span>
<span class="fc" id="L234">                    return Boolean.valueOf((String) answer);</span>
                }
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">                if (answer instanceof Number) {</span>
<span class="fc" id="L237">                    final Number n = (Number) answer;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                    return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;</span>
                }
            }
        }
<span class="fc" id="L242">        return null;</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a boolean, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a boolean, or defaultValue if the original value is null, the map is null or the
     *         boolean conversion fails
     */
    public static &lt;K&gt; Boolean getBoolean(final Map&lt;? super K, ?&gt; map, final K key, final Boolean defaultValue) {
<span class="fc" id="L257">        return applyDefaultValue(map, key, MapUtils::getBoolean, defaultValue);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a boolean, using the defaultFunction to
     * produce the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a boolean, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the boolean conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Boolean getBoolean(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Boolean&gt; defaultFunction) {
<span class="fc" id="L274">        return applyDefaultFunction(map, key, MapUtils::getBoolean, defaultFunction);</span>
    }

    /**
     * Gets a boolean from a Map in a null-safe manner.
     * &lt;p&gt;
     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals
     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a
     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.
     * Otherwise, {@code false} is returned.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Boolean, {@code false} if null map input
     */
    public static &lt;K&gt; boolean getBooleanValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L292">        return Boolean.TRUE.equals(getBoolean(map, key));</span>
    }

    /**
     * Gets a boolean from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals
     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a
     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.
     * Otherwise, {@code defaultValue} is returned.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as a Boolean, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; boolean getBooleanValue(final Map&lt;? super K, ?&gt; map, final K key, final boolean defaultValue) {
<span class="fc" id="L311">        return applyDefaultValue(map, key, MapUtils::getBoolean, defaultValue).booleanValue();</span>
    }

    /**
     * Gets a boolean from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals
     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a
     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.
     * Otherwise, defaultValue produced by the {@code defaultFunction} is returned.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as a Boolean, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; boolean getBooleanValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Boolean&gt; defaultFunction) {
<span class="fc" id="L334">        return applyDefaultFunction(map, key, MapUtils::getBoolean, defaultFunction, false).booleanValue();</span>
    }

    /**
     * Gets a Byte from a Map in a null-safe manner.
     * &lt;p&gt;
     * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Byte, {@code null} if null map input
     */
    public static &lt;K&gt; Byte getByte(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L349">        final Number answer = getNumber(map, key);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (answer == null) {</span>
<span class="fc" id="L351">            return null;</span>
        }
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (answer instanceof Byte) {</span>
<span class="fc" id="L354">            return (Byte) answer;</span>
        }
<span class="fc" id="L356">        return Byte.valueOf(answer.byteValue());</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a byte, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Byte getByte(final Map&lt;? super K, ?&gt; map, final K key, final Byte defaultValue) {
<span class="fc" id="L371">        return applyDefaultValue(map, key, MapUtils::getByte, defaultValue);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a byte, using the defaultFunction to produce
     * the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Byte getByte(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Byte&gt; defaultFunction) {
<span class="fc" id="L387">        return applyDefaultFunction(map, key, MapUtils::getByte, defaultFunction);</span>
    }

    /**
     * Gets a byte from a Map in a null-safe manner.
     * &lt;p&gt;
     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a byte, {@code 0} if null map input
     */
    public static &lt;K&gt; byte getByteValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L402">        return applyDefaultValue(map, key, MapUtils::getByte, 0).byteValue();</span>
    }

    /**
     * Gets a byte from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as a byte, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; byte getByteValue(final Map&lt;? super K, ?&gt; map, final K key, final byte defaultValue) {
<span class="fc" id="L418">        return applyDefaultValue(map, key, MapUtils::getByte, defaultValue).byteValue();</span>
    }

    /**
     * Gets a byte from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as a byte, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; byte getByteValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Byte&gt; defaultFunction) {
<span class="fc" id="L438">        return applyDefaultFunction(map, key, MapUtils::getByte, defaultFunction, (byte) 0).byteValue();</span>
    }

    /**
     * Gets a Double from a Map in a null-safe manner.
     * &lt;p&gt;
     * The Double is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Double, {@code null} if null map input
     */
    public static &lt;K&gt; Double getDouble(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L453">        final Number answer = getNumber(map, key);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (answer == null) {</span>
<span class="fc" id="L455">            return null;</span>
        }
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if (answer instanceof Double) {</span>
<span class="fc" id="L458">            return (Double) answer;</span>
        }
<span class="fc" id="L460">        return Double.valueOf(answer.doubleValue());</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a double, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Double getDouble(final Map&lt;? super K, ?&gt; map, final K key, final Double defaultValue) {
<span class="fc" id="L475">        return applyDefaultValue(map, key, MapUtils::getDouble, defaultValue);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a double, using the defaultFunction to
     * produce the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Double getDouble(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Double&gt; defaultFunction) {
<span class="fc" id="L492">        return applyDefaultFunction(map, key, MapUtils::getDouble, defaultFunction);</span>
    }

    /**
     * Gets a double from a Map in a null-safe manner.
     * &lt;p&gt;
     * The double is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a double, {@code 0.0} if null map input
     */
    public static &lt;K&gt; double getDoubleValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L507">        return applyDefaultValue(map, key, MapUtils::getDouble, 0d).doubleValue();</span>
    }

    /**
     * Gets a double from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * The double is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as a double, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; double getDoubleValue(final Map&lt;? super K, ?&gt; map, final K key, final double defaultValue) {
<span class="fc" id="L523">        return applyDefaultValue(map, key, MapUtils::getDouble, defaultValue).doubleValue();</span>
    }

    /**
     * Gets a double from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * The double is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as a double, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; double getDoubleValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Double&gt; defaultFunction) {
<span class="fc" id="L543">        return applyDefaultFunction(map, key, MapUtils::getDouble, defaultFunction, 0d).doubleValue();</span>
    }

    /**
     * Gets a Float from a Map in a null-safe manner.
     * &lt;p&gt;
     * The Float is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Float, {@code null} if null map input
     */
    public static &lt;K&gt; Float getFloat(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L558">        final Number answer = getNumber(map, key);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        if (answer == null) {</span>
<span class="fc" id="L560">            return null;</span>
        }
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (answer instanceof Float) {</span>
<span class="fc" id="L563">            return (Float) answer;</span>
        }
<span class="fc" id="L565">        return Float.valueOf(answer.floatValue());</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a float, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Float getFloat(final Map&lt;? super K, ?&gt; map, final K key, final Float defaultValue) {
<span class="fc" id="L580">        return applyDefaultValue(map, key, MapUtils::getFloat, defaultValue);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a float, using the defaultFunction to produce
     * the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Float getFloat(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Float&gt; defaultFunction) {
<span class="fc" id="L597">        return applyDefaultFunction(map, key, MapUtils::getFloat, defaultFunction);</span>
    }

    /**
     * Gets a float from a Map in a null-safe manner.
     * &lt;p&gt;
     * The float is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a float, {@code 0.0F} if null map input
     */
    public static &lt;K&gt; float getFloatValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L612">        return applyDefaultValue(map, key, MapUtils::getFloat, 0f).floatValue();</span>
    }

    /**
     * Gets a float from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * The float is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as a float, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; float getFloatValue(final Map&lt;? super K, ?&gt; map, final K key, final float defaultValue) {
<span class="fc" id="L628">        return applyDefaultValue(map, key, MapUtils::getFloat, defaultValue).floatValue();</span>
    }

    /**
     * Gets a float from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * The float is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as a float, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; float getFloatValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Float&gt; defaultFunction) {
<span class="fc" id="L648">        return applyDefaultFunction(map, key, MapUtils::getFloat, defaultFunction, 0f).floatValue();</span>
    }

    /**
     * Gets an Integer from a Map in a null-safe manner.
     * &lt;p&gt;
     * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as an Integer, {@code null} if null map input
     */
    public static &lt;K&gt; Integer getInteger(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L663">        final Number answer = getNumber(map, key);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (answer == null) {</span>
<span class="fc" id="L665">            return null;</span>
        }
<span class="fc bfc" id="L667" title="All 2 branches covered.">        if (answer instanceof Integer) {</span>
<span class="fc" id="L668">            return (Integer) answer;</span>
        }
<span class="fc" id="L670">        return Integer.valueOf(answer.intValue());</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into an integer, using the defaultFunction to
     * produce the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Integer getInteger(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Integer&gt; defaultFunction) {
<span class="fc" id="L687">        return applyDefaultFunction(map, key, MapUtils::getInteger, defaultFunction);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into an integer, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Integer getInteger(final Map&lt;? super K, ?&gt; map, final K key, final Integer defaultValue) {
<span class="fc" id="L702">        return applyDefaultValue(map, key, MapUtils::getInteger, defaultValue);</span>
    }

    /**
     * Gets an int from a Map in a null-safe manner.
     * &lt;p&gt;
     * The int is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as an int, {@code 0} if null map input
     */
    public static &lt;K&gt; int getIntValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L717">        return applyDefaultValue(map, key, MapUtils::getInteger, 0).intValue();</span>
    }

    /**
     * Gets an int from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * The int is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as an int, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; int getIntValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Integer&gt; defaultFunction) {
<span class="fc" id="L737">        return applyDefaultFunction(map, key, MapUtils::getInteger, defaultFunction, 0).byteValue();</span>
    }

    /**
     * Gets an int from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * The int is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as an int, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; int getIntValue(final Map&lt;? super K, ?&gt; map, final K key, final int defaultValue) {
<span class="fc" id="L753">        return applyDefaultValue(map, key, MapUtils::getInteger, defaultValue).intValue();</span>
    }

    /**
     * Gets a Long from a Map in a null-safe manner.
     * &lt;p&gt;
     * The Long is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Long, {@code null} if null map input
     */
    public static &lt;K&gt; Long getLong(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L768">        final Number answer = getNumber(map, key);</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">        if (answer == null) {</span>
<span class="fc" id="L770">            return null;</span>
        }
<span class="fc bfc" id="L772" title="All 2 branches covered.">        if (answer instanceof Long) {</span>
<span class="fc" id="L773">            return (Long) answer;</span>
        }
<span class="fc" id="L775">        return Long.valueOf(answer.longValue());</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a Long, using the defaultFunction to produce
     * the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Long getLong(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Long&gt; defaultFunction) {
<span class="fc" id="L791">        return applyDefaultFunction(map, key, MapUtils::getLong, defaultFunction);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a long, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Long getLong(final Map&lt;? super K, ?&gt; map, final K key, final Long defaultValue) {
<span class="fc" id="L806">        return applyDefaultValue(map, key, MapUtils::getLong, defaultValue);</span>
    }

    /**
     * Gets a long from a Map in a null-safe manner.
     * &lt;p&gt;
     * The long is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a long, {@code 0L} if null map input
     */
    public static &lt;K&gt; long getLongValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L821">        return applyDefaultValue(map, key, MapUtils::getLong, 0L).longValue();</span>
    }

    /**
     * Gets a long from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * The long is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as a long, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; long getLongValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Long&gt; defaultFunction) {
<span class="fc" id="L841">        return applyDefaultFunction(map, key, MapUtils::getLong, defaultFunction, 0L).byteValue();</span>
    }

    /**
     * Gets a long from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * The long is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as a long, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; long getLongValue(final Map&lt;? super K, ?&gt; map, final K key, final long defaultValue) {
<span class="fc" id="L857">        return applyDefaultValue(map, key, MapUtils::getLong, defaultValue).longValue();</span>
    }

    /**
     * Gets a Map from a Map in a null-safe manner.
     * &lt;p&gt;
     * If the value returned from the specified map is not a Map then {@code null} is returned.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Map, {@code null} if null map input
     */
    public static &lt;K&gt; Map&lt;?, ?&gt; getMap(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (map != null) {</span>
<span class="fc" id="L873">            final Object answer = map.get(key);</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">            if (answer instanceof Map) {</span>
<span class="fc" id="L875">                return (Map&lt;?, ?&gt;) answer;</span>
            }
        }
<span class="fc" id="L878">        return null;</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a map, using the defaultFunction to produce
     * the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the map conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Map&lt;?, ?&gt; getMap(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Map&lt;?, ?&gt;&gt; defaultFunction) {
<span class="nc" id="L895">        return applyDefaultFunction(map, key, MapUtils::getMap, defaultFunction);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a map, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         map conversion fails
     */
    public static &lt;K&gt; Map&lt;?, ?&gt; getMap(final Map&lt;? super K, ?&gt; map, final K key, final Map&lt;?, ?&gt; defaultValue) {
<span class="fc" id="L910">        return applyDefaultValue(map, key, MapUtils::getMap, defaultValue);</span>
    }

    /**
     * Gets a Number from a Map in a null-safe manner.
     * &lt;p&gt;
     * If the value is a {@code Number} it is returned directly. If the value is a {@code String} it is
     * converted using {@link NumberFormat#parse(String)} on the system default formatter returning {@code null} if
     * the conversion fails. Otherwise, {@code null} is returned.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Number, {@code null} if null map input
     */
    public static &lt;K&gt; Number getNumber(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (map != null) {</span>
<span class="fc" id="L928">            final Object answer = map.get(key);</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">            if (answer != null) {</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">                if (answer instanceof Number) {</span>
<span class="fc" id="L931">                    return (Number) answer;</span>
                }
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">                if (answer instanceof String) {</span>
                    try {
<span class="fc" id="L935">                        final String text = (String) answer;</span>
<span class="fc" id="L936">                        return NumberFormat.getInstance().parse(text);</span>
<span class="fc" id="L937">                    } catch (final ParseException e) { // NOPMD</span>
                        // failure means null is returned
                    }
                }
            }
        }
<span class="fc" id="L943">        return null;</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a number, using the defaultFunction to
     * produce the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Number getNumber(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Number&gt; defaultFunction) {
<span class="fc" id="L960">        return applyDefaultFunction(map, key, MapUtils::getNumber, defaultFunction);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a number, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Number getNumber(final Map&lt;? super K, ?&gt; map, final K key, final Number defaultValue) {
<span class="fc" id="L975">        return applyDefaultValue(map, key, MapUtils::getNumber, defaultValue);</span>
    }

    /**
     * Gets from a Map in a null-safe manner.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map, {@code null} if null map input
     */
    public static &lt;K, V&gt; V getObject(final Map&lt;? super K, V&gt; map, final K key) {
<span class="fc bfc" id="L988" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc" id="L989">            return map.get(key);</span>
        }
<span class="fc" id="L991">        return null;</span>
    }

    /**
     * Looks up the given key in the given map, converting null into the given default value.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null
     * @return the value in the map, or defaultValue if the original value is null or the map is null
     */
    public static &lt;K, V&gt; V getObject(final Map&lt;K, V&gt; map, final K key, final V defaultValue) {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc" id="L1006">            final V answer = map.get(key);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (answer != null) {</span>
<span class="fc" id="L1008">                return answer;</span>
            }
        }
<span class="fc" id="L1011">        return defaultValue;</span>
    }

    /**
     * Gets a Short from a Map in a null-safe manner.
     * &lt;p&gt;
     * The Short is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a Short, {@code null} if null map input
     */
    public static &lt;K&gt; Short getShort(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L1026">        final Number answer = getNumber(map, key);</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        if (answer == null) {</span>
<span class="fc" id="L1028">            return null;</span>
        }
<span class="fc bfc" id="L1030" title="All 2 branches covered.">        if (answer instanceof Short) {</span>
<span class="fc" id="L1031">            return (Short) answer;</span>
        }
<span class="fc" id="L1033">        return Short.valueOf(answer.shortValue());</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a short, using the defaultFunction to produce
     * the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the number conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; Short getShort(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Short&gt; defaultFunction) {
<span class="fc" id="L1050">        return applyDefaultFunction(map, key, MapUtils::getShort, defaultFunction);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a short, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the
     *         number conversion fails
     */
    public static &lt;K&gt; Short getShort(final Map&lt;? super K, ?&gt; map, final K key, final Short defaultValue) {
<span class="fc" id="L1065">        return applyDefaultValue(map, key, MapUtils::getShort, defaultValue);</span>
    }

    /**
     * Gets a short from a Map in a null-safe manner.
     * &lt;p&gt;
     * The short is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a short, {@code 0} if null map input
     */
    public static &lt;K&gt; short getShortValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L1080">        return applyDefaultValue(map, key, MapUtils::getShort, 0).shortValue();</span>
    }

    /**
     * Gets a short from a Map in a null-safe manner, using the default value produced by the defaultFunction if the
     * conversion fails.
     * &lt;p&gt;
     * The short is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails
     * @return the value in the Map as a short, default value produced by the {@code defaultFunction} if null map
     *         input
     * @since 4.5
     */
    public static &lt;K&gt; short getShortValue(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, Short&gt; defaultFunction) {
<span class="fc" id="L1100">        return applyDefaultFunction(map, key, MapUtils::getShort, defaultFunction, (short) 0).shortValue();</span>
    }

    /**
     * Gets a short from a Map in a null-safe manner, using the default value if the conversion fails.
     * &lt;p&gt;
     * The short is obtained from the results of {@link #getNumber(Map,Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @param defaultValue return if the value is null or if the conversion fails
     * @return the value in the Map as a short, {@code defaultValue} if null map input
     */
    public static &lt;K&gt; short getShortValue(final Map&lt;? super K, ?&gt; map, final K key, final short defaultValue) {
<span class="fc" id="L1116">        return applyDefaultValue(map, key, MapUtils::getShort, defaultValue).shortValue();</span>
    }

    /**
     * Gets a String from a Map in a null-safe manner.
     * &lt;p&gt;
     * The String is obtained via {@code toString}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to use
     * @param key the key to look up
     * @return the value in the Map as a String, {@code null} if null map input
     */
    public static &lt;K&gt; String getString(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc bfc" id="L1131" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc" id="L1132">            final Object answer = map.get(key);</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">            if (answer != null) {</span>
<span class="fc" id="L1134">                return answer.toString();</span>
            }
        }
<span class="fc" id="L1137">        return null;</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a string, using the defaultFunction to
     * produce the default value if the conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails
     * @return the value in the map as a string, or defaultValue produced by the defaultFunction if the original value
     *         is null, the map is null or the string conversion fails
     * @since 4.5
     */
    public static &lt;K&gt; String getString(final Map&lt;? super K, ?&gt; map, final K key,
            final Function&lt;K, String&gt; defaultFunction) {
<span class="fc" id="L1154">        return applyDefaultFunction(map, key, MapUtils::getString, defaultFunction);</span>
    }

    /**
     * Looks up the given key in the given map, converting the result into a string, using the default value if the
     * conversion fails.
     *
     * @param &lt;K&gt; the key type
     * @param map the map whose value to look up
     * @param key the key of the value to look up in that map
     * @param defaultValue what to return if the value is null or if the conversion fails
     * @return the value in the map as a string, or defaultValue if the original value is null, the map is null or the
     *         string conversion fails
     */
    public static &lt;K&gt; String getString(final Map&lt;? super K, ?&gt; map, final K key, final String defaultValue) {
<span class="fc" id="L1169">        return applyDefaultValue(map, key, MapUtils::getString, defaultValue);</span>
    }

    /**
     * Inverts the supplied map returning a new HashMap such that the keys of the input are swapped with the values.
     * &lt;p&gt;
     * This operation assumes that the inverse mapping is well defined. If the input map had multiple entries with the
     * same value mapped to different keys, the returned map will map one of those keys to the value, but the exact key
     * which will be mapped is undefined.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to invert, must not be null
     * @return a new HashMap containing the inverted data
     * @throws NullPointerException if the map is null
     */
    public static &lt;K, V&gt; Map&lt;V, K&gt; invertMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L1187">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc" id="L1188">        final Map&lt;V, K&gt; out = new HashMap&lt;&gt;(map.size());</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">        for (final Entry&lt;K, V&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L1190">            out.put(entry.getValue(), entry.getKey());</span>
<span class="fc" id="L1191">        }</span>
<span class="fc" id="L1192">        return out;</span>
    }

    /**
     * Null-safe check if the specified map is empty.
     * &lt;p&gt;
     * Null returns true.
     * &lt;/p&gt;
     *
     * @param map the map to check, may be null
     * @return true if empty or null
     * @since 3.2
     */
    public static boolean isEmpty(final Map&lt;?, ?&gt; map) {
<span class="fc bfc" id="L1206" title="All 4 branches covered.">        return map == null || map.isEmpty();</span>
    }

    /**
     * Null-safe check if the specified map is not empty.
     * &lt;p&gt;
     * Null returns false.
     * &lt;/p&gt;
     *
     * @param map the map to check, may be null
     * @return true if non-null and non-empty
     * @since 3.2
     */
    public static boolean isNotEmpty(final Map&lt;?, ?&gt; map) {
<span class="fc bfc" id="L1220" title="All 2 branches covered.">        return !isEmpty(map);</span>
    }

    /**
     * Gets the specified {@link Map} as an {@link IterableMap}.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map to wrap if necessary.
     * @return IterableMap&amp;lt;K, V&amp;gt;
     * @throws NullPointerException if map is null
     * @since 4.0
     */
    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; iterableMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L1234">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        return map instanceof IterableMap ? (IterableMap&lt;K, V&gt;) map : new AbstractMapDecorator&lt;K, V&gt;(map) {</span>
            // empty
        };
    }

    /**
     * Gets the specified {@link SortedMap} as an {@link IterableSortedMap}.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param sortedMap to wrap if necessary
     * @return {@link IterableSortedMap}&amp;lt;K, V&amp;gt;
     * @throws NullPointerException if sortedMap is null
     * @since 4.0
     */
    public static &lt;K, V&gt; IterableSortedMap&lt;K, V&gt; iterableSortedMap(final SortedMap&lt;K, V&gt; sortedMap) {
<span class="fc" id="L1251">        Objects.requireNonNull(sortedMap, &quot;sortedMap&quot;);</span>
<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap&lt;K, V&gt;) sortedMap</span>
<span class="fc" id="L1253">                : new AbstractSortedMapDecorator&lt;K, V&gt;(sortedMap) {</span>
                    // empty
                };
    }

    /**
     * Returns a &quot;lazy&quot; map whose values will be created on demand.
     * &lt;p&gt;
     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the
     * factory will be used to create a new object and that object will become the value associated with that key.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For instance:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Factory factory = new Factory() {
     *     public Object create() {
     *         return new Date();
     *     }
     * }
     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);
     * Object obj = lazyMap.get(&quot;test&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * After the above code is executed, {@code obj} will contain a new {@code Date} instance. Furthermore,
     * that {@code Date} instance is the value for the {@code &quot;test&quot;} key in the map.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to make lazy, must not be null
     * @param factory the factory for creating new objects, must not be null
     * @return a lazy map backed by the given map
     * @throws NullPointerException if the Map or Factory is null
     */
    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; lazyMap(final Map&lt;K, V&gt; map, final Factory&lt;? extends V&gt; factory) {
<span class="fc" id="L1289">        return LazyMap.lazyMap(map, factory);</span>
    }

    /**
     * Returns a &quot;lazy&quot; map whose values will be created on demand.
     * &lt;p&gt;
     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the
     * factory will be used to create a new object and that object will become the value associated with that key. The
     * factory is a {@link Transformer} that will be passed the key which it must transform into the value.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For instance:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Transformer factory = new Transformer() {
     *     public Object transform(Object mapKey) {
     *         return new File(mapKey);
     *     }
     * }
     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);
     * Object obj = lazyMap.get(&quot;C:/dev&quot;);
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * After the above code is executed, {@code obj} will contain a new {@code File} instance for the C drive
     * dev directory. Furthermore, that {@code File} instance is the value for the {@code &quot;C:/dev&quot;} key in the
     * map.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If a lazy map is wrapped by a synchronized map, the result is a simple synchronized cache. When an object is not
     * is the cache, the cache itself calls back to the factory Transformer to populate itself, all within the same
     * synchronized block.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to make lazy, must not be null
     * @param transformerFactory the factory for creating new objects, must not be null
     * @return a lazy map backed by the given map
     * @throws NullPointerException if the Map or Transformer is null
     */
    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; lazyMap(final Map&lt;K, V&gt; map,
            final Transformer&lt;? super K, ? extends V&gt; transformerFactory) {
<span class="fc" id="L1332">        return LazyMap.lazyMap(map, transformerFactory);</span>
    }

    /**
     * Returns a &quot;lazy&quot; sorted map whose values will be created on demand.
     * &lt;p&gt;
     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the
     * factory will be used to create a new object and that object will become the value associated with that key.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For instance:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Factory factory = new Factory() {
     *     public Object create() {
     *         return new Date();
     *     }
     * }
     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);
     * Object obj = lazy.get(&quot;test&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * After the above code is executed, {@code obj} will contain a new {@code Date} instance. Furthermore,
     * that {@code Date} instance is the value for the {@code &quot;test&quot;} key.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to make lazy, must not be null
     * @param factory the factory for creating new objects, must not be null
     * @return a lazy map backed by the given map
     * @throws NullPointerException if the SortedMap or Factory is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; lazySortedMap(final SortedMap&lt;K, V&gt; map, final Factory&lt;? extends V&gt; factory) {
<span class="fc" id="L1366">        return LazySortedMap.lazySortedMap(map, factory);</span>
    }

    /**
     * Returns a &quot;lazy&quot; sorted map whose values will be created on demand.
     * &lt;p&gt;
     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the
     * factory will be used to create a new object and that object will become the value associated with that key. The
     * factory is a {@link Transformer} that will be passed the key which it must transform into the value.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For instance:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Transformer factory = new Transformer() {
     *     public Object transform(Object mapKey) {
     *         return new File(mapKey);
     *     }
     * }
     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);
     * Object obj = lazy.get(&quot;C:/dev&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * After the above code is executed, {@code obj} will contain a new {@code File} instance for the C drive
     * dev directory. Furthermore, that {@code File} instance is the value for the {@code &quot;C:/dev&quot;} key in the
     * map.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If a lazy map is wrapped by a synchronized map, the result is a simple synchronized cache. When an object is not
     * is the cache, the cache itself calls back to the factory Transformer to populate itself, all within the same
     * synchronized block.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to make lazy, must not be null
     * @param transformerFactory the factory for creating new objects, must not be null
     * @return a lazy map backed by the given map
     * @throws NullPointerException if the Map or Transformer is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; lazySortedMap(final SortedMap&lt;K, V&gt; map,
            final Transformer&lt;? super K, ? extends V&gt; transformerFactory) {
<span class="fc" id="L1408">        return LazySortedMap.lazySortedMap(map, transformerFactory);</span>
    }

    /**
     * Creates a multi-value map backed by the given map which returns collections of type ArrayList.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to decorate
     * @return a multi-value map backed by the given map which returns ArrayLists of values.
     * @see MultiValueMap
     * @since 3.2
     * @deprecated since 4.1, use {@link MultiValuedMap} instead
     */
    @Deprecated
    public static &lt;K, V&gt; MultiValueMap&lt;K, V&gt; multiValueMap(final Map&lt;K, ? super Collection&lt;V&gt;&gt; map) {
<span class="nc" id="L1424">        return MultiValueMap.&lt;K, V&gt;multiValueMap(map);</span>
    }

    /**
     * Creates a multi-value map backed by the given map which returns collections of the specified type.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param &lt;C&gt; the collection class type
     * @param map the map to decorate
     * @param collectionClass the type of collections to return from the map (must contain public no-arg constructor and
     *        extend Collection)
     * @return a multi-value map backed by the given map which returns collections of the specified type
     * @see MultiValueMap
     * @since 3.2
     * @deprecated since 4.1, use {@link MultiValuedMap} instead
     */
    @Deprecated
    public static &lt;K, V, C extends Collection&lt;V&gt;&gt; MultiValueMap&lt;K, V&gt; multiValueMap(final Map&lt;K, C&gt; map,
            final Class&lt;C&gt; collectionClass) {
<span class="nc" id="L1444">        return MultiValueMap.multiValueMap(map, collectionClass);</span>
    }

    /**
     * Creates a multi-value map backed by the given map which returns collections created by the specified collection
     * factory.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param &lt;C&gt; the collection class type
     * @param map the map to decorate
     * @param collectionFactory a factor which creates collection objects
     * @return a multi-value map backed by the given map which returns collections created by the specified collection
     *         factory
     * @see MultiValueMap
     * @since 3.2
     * @deprecated since 4.1, use {@link MultiValuedMap} instead
     */
    @Deprecated
    public static &lt;K, V, C extends Collection&lt;V&gt;&gt; MultiValueMap&lt;K, V&gt; multiValueMap(final Map&lt;K, C&gt; map,
            final Factory&lt;C&gt; collectionFactory) {
<span class="nc" id="L1465">        return MultiValueMap.multiValueMap(map, collectionFactory);</span>
    }

    /**
     * Returns a map that maintains the order of keys that are added backed by the given map.
     * &lt;p&gt;
     * If a key is added twice, the order is determined by the first add. The order is observed through the keySet,
     * values and entrySet.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to order, must not be null
     * @return an ordered map backed by the given map
     * @throws NullPointerException if the Map is null
     */
    public static &lt;K, V&gt; OrderedMap&lt;K, V&gt; orderedMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L1482">        return ListOrderedMap.listOrderedMap(map);</span>
    }

    /**
     * Populates a Map using the supplied {@code Transformer}s to transform the elements into keys and values.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param &lt;E&gt; the type of object contained in the {@link Iterable}
     * @param map the {@code Map} to populate.
     * @param elements the {@code Iterable} containing the input values for the map.
     * @param keyTransformer the {@code Transformer} used to transform the element into a key value
     * @param valueTransformer the {@code Transformer} used to transform the element into a value
     * @throws NullPointerException if the map, elements or transformers are null
     */
    public static &lt;K, V, E&gt; void populateMap(final Map&lt;K, V&gt; map, final Iterable&lt;? extends E&gt; elements,
            final Transformer&lt;E, K&gt; keyTransformer, final Transformer&lt;E, V&gt; valueTransformer) {
<span class="fc bfc" id="L1499" title="All 2 branches covered.">        for (final E temp : elements) {</span>
<span class="fc" id="L1500">            map.put(keyTransformer.transform(temp), valueTransformer.transform(temp));</span>
<span class="fc" id="L1501">        }</span>
<span class="fc" id="L1502">    }</span>

    /**
     * Populates a Map using the supplied {@code Transformer} to transform the elements into keys, using the
     * unaltered element as the value in the {@code Map}.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the {@code Map} to populate.
     * @param elements the {@code Iterable} containing the input values for the map.
     * @param keyTransformer the {@code Transformer} used to transform the element into a key value
     * @throws NullPointerException if the map, elements or transformer are null
     */
    public static &lt;K, V&gt; void populateMap(final Map&lt;K, V&gt; map, final Iterable&lt;? extends V&gt; elements,
            final Transformer&lt;V, K&gt; keyTransformer) {
<span class="fc" id="L1517">        populateMap(map, elements, keyTransformer, TransformerUtils.&lt;V&gt;nopTransformer());</span>
<span class="fc" id="L1518">    }</span>

    /**
     * Populates a MultiMap using the supplied {@code Transformer}s to transform the elements into keys and values.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param &lt;E&gt; the type of object contained in the {@link Iterable}
     * @param map the {@code MultiMap} to populate.
     * @param elements the {@code Iterable} containing the input values for the map.
     * @param keyTransformer the {@code Transformer} used to transform the element into a key value
     * @param valueTransformer the {@code Transformer} used to transform the element into a value
     * @throws NullPointerException if the map, collection or transformers are null
     */
    public static &lt;K, V, E&gt; void populateMap(final MultiMap&lt;K, V&gt; map, final Iterable&lt;? extends E&gt; elements,
            final Transformer&lt;E, K&gt; keyTransformer, final Transformer&lt;E, V&gt; valueTransformer) {
<span class="fc bfc" id="L1534" title="All 2 branches covered.">        for (final E temp : elements) {</span>
<span class="fc" id="L1535">            map.put(keyTransformer.transform(temp), valueTransformer.transform(temp));</span>
<span class="fc" id="L1536">        }</span>
<span class="fc" id="L1537">    }</span>

    /**
     * Populates a MultiMap using the supplied {@code Transformer} to transform the elements into keys, using the
     * unaltered element as the value in the {@code MultiMap}.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the {@code MultiMap} to populate.
     * @param elements the {@code Iterable} to use as input values for the map.
     * @param keyTransformer the {@code Transformer} used to transform the element into a key value
     * @throws NullPointerException if the map, elements or transformer are null
     */
    public static &lt;K, V&gt; void populateMap(final MultiMap&lt;K, V&gt; map, final Iterable&lt;? extends V&gt; elements,
            final Transformer&lt;V, K&gt; keyTransformer) {
<span class="nc" id="L1552">        populateMap(map, elements, keyTransformer, TransformerUtils.&lt;V&gt;nopTransformer());</span>
<span class="nc" id="L1553">    }</span>

    /**
     * Returns a predicated (validating) map backed by the given map.
     * &lt;p&gt;
     * Only objects that pass the tests in the given predicates can be added to the map. Trying to add an invalid object
     * results in an IllegalArgumentException. Keys must pass the key predicate, values must pass the value predicate.
     * It is important not to use the original map after invoking this method, as it is a backdoor for adding invalid
     * objects.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to predicate, must not be null
     * @param keyPred the predicate for keys, null means no check
     * @param valuePred the predicate for values, null means no check
     * @return a predicated map backed by the given map
     * @throws NullPointerException if the Map is null
     */
    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; predicatedMap(final Map&lt;K, V&gt; map, final Predicate&lt;? super K&gt; keyPred,
            final Predicate&lt;? super V&gt; valuePred) {
<span class="fc" id="L1574">        return PredicatedMap.predicatedMap(map, keyPred, valuePred);</span>
    }

    /**
     * Returns a predicated (validating) sorted map backed by the given map.
     * &lt;p&gt;
     * Only objects that pass the tests in the given predicates can be added to the map. Trying to add an invalid object
     * results in an IllegalArgumentException. Keys must pass the key predicate, values must pass the value predicate.
     * It is important not to use the original map after invoking this method, as it is a backdoor for adding invalid
     * objects.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to predicate, must not be null
     * @param keyPred the predicate for keys, null means no check
     * @param valuePred the predicate for values, null means no check
     * @return a predicated map backed by the given map
     * @throws NullPointerException if the SortedMap is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; predicatedSortedMap(final SortedMap&lt;K, V&gt; map,
            final Predicate&lt;? super K&gt; keyPred, final Predicate&lt;? super V&gt; valuePred) {
<span class="nc" id="L1596">        return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);</span>
    }

    /**
     * Writes indentation to the given stream.
     *
     * @param out the stream to indent
     * @param indent the index of the indentation
     */
    private static void printIndent(final PrintStream out, final int indent) {
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        for (int i = 0; i &lt; indent; i++) {</span>
<span class="fc" id="L1607">            out.print(INDENT_STRING);</span>
        }
<span class="fc" id="L1609">    }</span>

    /**
     * Puts all the keys and values from the specified array into the map.
     * &lt;p&gt;
     * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)} method and constructors. It
     * allows you to build a map from an object array of various possible styles.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the first entry in the object array implements {@link java.util.Map.Entry} or {@link KeyValue} then the key
     * and value are added from that object. If the first entry in the object array is an object array itself, then it
     * is assumed that index 0 in the sub-array is the key and index 1 is the value. Otherwise, the array is treated as
     * keys and values in alternate indices.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For example, to create a color map:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Map colorMap = MapUtils.putAll(new HashMap(),
     *         new String[][] { { &quot;RED&quot;, &quot;#FF0000&quot; }, { &quot;GREEN&quot;, &quot;#00FF00&quot; }, { &quot;BLUE&quot;, &quot;#0000FF&quot; } });
     * &lt;/pre&gt;
     * &lt;p&gt;
     * or:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Map colorMap = MapUtils.putAll(new HashMap(),
     *         new String[] { &quot;RED&quot;, &quot;#FF0000&quot;, &quot;GREEN&quot;, &quot;#00FF00&quot;, &quot;BLUE&quot;, &quot;#0000FF&quot; });
     * &lt;/pre&gt;
     * &lt;p&gt;
     * or:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] { new DefaultMapEntry(&quot;RED&quot;, &quot;#FF0000&quot;),
     *         new DefaultMapEntry(&quot;GREEN&quot;, &quot;#00FF00&quot;), new DefaultMapEntry(&quot;BLUE&quot;, &quot;#0000FF&quot;) });
     * &lt;/pre&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to populate, must not be null
     * @param array an array to populate from, null ignored
     * @return the input map
     * @throws NullPointerException if map is null
     * @throws IllegalArgumentException if sub-array or entry matching used and an entry is invalid
     * @throws ClassCastException if the array contents is mixed
     * @since 3.2
     */
    @SuppressWarnings(&quot;unchecked&quot;) // As per Javadoc throws CCE for invalid array contents
    public static &lt;K, V&gt; Map&lt;K, V&gt; putAll(final Map&lt;K, V&gt; map, final Object[] array) {
<span class="fc" id="L1657">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc bfc" id="L1658" title="All 4 branches covered.">        if (array == null || array.length == 0) {</span>
<span class="fc" id="L1659">            return map;</span>
        }
<span class="fc" id="L1661">        final Object obj = array[0];</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">        if (obj instanceof Map.Entry) {</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">            for (final Object element : array) {</span>
                // cast ok here, type is checked above
<span class="fc" id="L1665">                final Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) element;</span>
<span class="fc" id="L1666">                map.put(entry.getKey(), entry.getValue());</span>
            }
<span class="fc bfc" id="L1668" title="All 2 branches covered.">        } else if (obj instanceof KeyValue) {</span>
<span class="fc bfc" id="L1669" title="All 2 branches covered.">            for (final Object element : array) {</span>
                // cast ok here, type is checked above
<span class="fc" id="L1671">                final KeyValue&lt;K, V&gt; keyval = (KeyValue&lt;K, V&gt;) element;</span>
<span class="fc" id="L1672">                map.put(keyval.getKey(), keyval.getValue());</span>
            }
<span class="fc bfc" id="L1674" title="All 2 branches covered.">        } else if (obj instanceof Object[]) {</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc" id="L1676">                final Object[] sub = (Object[]) array[i];</span>
<span class="fc bfc" id="L1677" title="All 4 branches covered.">                if (sub == null || sub.length &lt; 2) {</span>
<span class="fc" id="L1678">                    throw new IllegalArgumentException(&quot;Invalid array element: &quot; + i);</span>
                }
                // these casts can fail if array has incorrect types
<span class="fc" id="L1681">                map.put((K) sub[0], (V) sub[1]);</span>
            }
        } else {
<span class="fc bfc" id="L1684" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length - 1;) {</span>
                // these casts can fail if array has incorrect types
<span class="fc" id="L1686">                map.put((K) array[i++], (V) array[i++]);</span>
            }
        }
<span class="fc" id="L1689">        return map;</span>
    }

    /**
     * Protects against adding null values to a map.
     * &lt;p&gt;
     * This method checks the value being added to the map, and if it is null it is replaced by an empty string.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This could be useful if the map does not accept null values, or for receiving data from a source that may provide
     * null or empty string which should be held in the same way in the map.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Keys are not validated. Note that this method can be used to circumvent the map's value type at runtime.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param map the map to add to, must not be null
     * @param key the key
     * @param value the value, null converted to &quot;&quot;
     * @throws NullPointerException if the map is null
     */
    public static &lt;K&gt; void safeAddToMap(final Map&lt;? super K, Object&gt; map, final K key, final Object value)
            throws NullPointerException {
<span class="fc" id="L1713">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc bfc" id="L1714" title="All 2 branches covered.">        map.put(key, value == null ? &quot;&quot; : value);</span>
<span class="fc" id="L1715">    }</span>

    /**
     * Gets the given map size or 0 if the map is null
     *
     * @param map a Map or null
     * @return the given map size or 0 if the map is null
     */
    public static int size(final Map&lt;?, ?&gt; map) {
<span class="fc bfc" id="L1724" title="All 2 branches covered.">        return map == null ? 0 : map.size();</span>
    }

    /**
     * Returns a synchronized map backed by the given map.
     * &lt;p&gt;
     * You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Map m = MapUtils.synchronizedMap(myMap);
     * Sets s = m.keySet(); // outside synchronized block
     * synchronized (m) { // synchronized on MAP!
     *     Iterator i = s.iterator();
     *     while (i.hasNext()) {
     *         process(i.next());
     *     }
     * }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This method uses the implementation in {@link java.util.Collections Collections}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to synchronize, must not be null
     * @return a synchronized map backed by the given map
     */
    public static &lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(final Map&lt;K, V&gt; map) {
<span class="nc" id="L1752">        return Collections.synchronizedMap(map);</span>
    }

    /**
     * Returns a synchronized sorted map backed by the given sorted map.
     * &lt;p&gt;
     * You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * Map m = MapUtils.synchronizedSortedMap(myMap);
     * Sets s = m.keySet(); // outside synchronized block
     * synchronized (m) { // synchronized on MAP!
     *     Iterator i = s.iterator();
     *     while (i.hasNext()) {
     *         process(i.next());
     *     }
     * }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This method uses the implementation in {@link java.util.Collections Collections}.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to synchronize, must not be null
     * @return a synchronized map backed by the given map
     * @throws NullPointerException if the map is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; synchronizedSortedMap(final SortedMap&lt;K, V&gt; map) {
<span class="nc" id="L1781">        return Collections.synchronizedSortedMap(map);</span>
    }

    /**
     * Creates a new HashMap using data copied from a ResourceBundle.
     *
     * @param resourceBundle the resource bundle to convert, must not be null
     * @return the HashMap containing the data
     * @throws NullPointerException if the bundle is null
     */
    public static Map&lt;String, Object&gt; toMap(final ResourceBundle resourceBundle) {
<span class="fc" id="L1792">        Objects.requireNonNull(resourceBundle, &quot;resourceBundle&quot;);</span>
<span class="fc" id="L1793">        final Enumeration&lt;String&gt; enumeration = resourceBundle.getKeys();</span>
<span class="fc" id="L1794">        final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L1796" title="All 2 branches covered.">        while (enumeration.hasMoreElements()) {</span>
<span class="fc" id="L1797">            final String key = enumeration.nextElement();</span>
<span class="fc" id="L1798">            final Object value = resourceBundle.getObject(key);</span>
<span class="fc" id="L1799">            map.put(key, value);</span>
<span class="fc" id="L1800">        }</span>

<span class="fc" id="L1802">        return map;</span>
    }

    /**
     * Gets a new Properties object initialized with the values from a Map. A null input will return an empty properties
     * object.
     * &lt;p&gt;
     * A Properties object may only store non-null keys and values, thus if the provided map contains either a key or
     * value which is {@code null}, a {@link NullPointerException} will be thrown.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to convert to a Properties object
     * @return the properties object
     * @throws NullPointerException if a key or value in the provided map is {@code null}
     */
    public static &lt;K, V&gt; Properties toProperties(final Map&lt;K, V&gt; map) {
<span class="fc" id="L1820">        final Properties answer = new Properties();</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc bfc" id="L1822" title="All 2 branches covered.">            for (final Entry&lt;K, V&gt; entry2 : map.entrySet()) {</span>
<span class="fc" id="L1823">                final Map.Entry&lt;?, ?&gt; entry = entry2;</span>
<span class="fc" id="L1824">                final Object key = entry.getKey();</span>
<span class="fc" id="L1825">                final Object value = entry.getValue();</span>
<span class="fc" id="L1826">                answer.put(key, value);</span>
<span class="fc" id="L1827">            }</span>
        }
<span class="fc" id="L1829">        return answer;</span>
    }

    /**
     * Returns a transformed map backed by the given map.
     * &lt;p&gt;
     * This method returns a new map (decorating the specified map) that will transform any new entries added to it.
     * Existing entries in the specified map will not be transformed. If you want that behavior, see
     * {@link TransformedMap#transformedMap}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Each object is passed through the transformers as it is added to the Map. It is important not to use the original
     * map after invoking this method, as it is a backdoor for adding untransformed objects.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If there are any elements already in the map being decorated, they are NOT transformed.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to transform, must not be null, typically empty
     * @param keyTransformer the transformer for the map keys, null means no transformation
     * @param valueTransformer the transformer for the map values, null means no transformation
     * @return a transformed map backed by the given map
     * @throws NullPointerException if the Map is null
     */
    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; transformedMap(final Map&lt;K, V&gt; map,
            final Transformer&lt;? super K, ? extends K&gt; keyTransformer,
            final Transformer&lt;? super V, ? extends V&gt; valueTransformer) {
<span class="fc" id="L1858">        return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);</span>
    }

    /**
     * Returns a transformed sorted map backed by the given map.
     * &lt;p&gt;
     * This method returns a new sorted map (decorating the specified map) that will transform any new entries added to
     * it. Existing entries in the specified map will not be transformed. If you want that behavior, see
     * {@link TransformedSortedMap#transformedSortedMap}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Each object is passed through the transformers as it is added to the Map. It is important not to use the original
     * map after invoking this method, as it is a backdoor for adding untransformed objects.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If there are any elements already in the map being decorated, they are NOT transformed.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to transform, must not be null, typically empty
     * @param keyTransformer the transformer for the map keys, null means no transformation
     * @param valueTransformer the transformer for the map values, null means no transformation
     * @return a transformed map backed by the given map
     * @throws NullPointerException if the SortedMap is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; transformedSortedMap(final SortedMap&lt;K, V&gt; map,
            final Transformer&lt;? super K, ? extends K&gt; keyTransformer,
            final Transformer&lt;? super V, ? extends V&gt; valueTransformer) {
<span class="fc" id="L1887">        return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);</span>
    }

    /**
     * Returns an unmodifiable map backed by the given map.
     * &lt;p&gt;
     * This method uses the implementation in the decorators subpackage.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the map to make unmodifiable, must not be null
     * @return an unmodifiable map backed by the given map
     * @throws NullPointerException if the map is null
     */
    public static &lt;K, V&gt; Map&lt;K, V&gt; unmodifiableMap(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L1903">        return UnmodifiableMap.unmodifiableMap(map);</span>
    }

    /**
     * Returns an unmodifiable sorted map backed by the given sorted map.
     * &lt;p&gt;
     * This method uses the implementation in the decorators subpackage.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param map the sorted map to make unmodifiable, must not be null
     * @return an unmodifiable map backed by the given map
     * @throws NullPointerException if the map is null
     */
    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(final SortedMap&lt;K, ? extends V&gt; map) {
<span class="fc" id="L1919">        return UnmodifiableSortedMap.unmodifiableSortedMap(map);</span>
    }

    /**
     * Prints the given map with nice line breaks.
     * &lt;p&gt;
     * This method prints a nicely formatted String describing the Map. Each map entry will be printed with key and
     * value. When the value is a Map, recursive behavior occurs.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the
     * stream as required.
     * &lt;/p&gt;
     *
     * @param out the stream to print to, must not be null
     * @param label The label to be used, may be {@code null}. If {@code null}, the label is not output. It
     *        typically represents the name of the property in a bean or similar.
     * @param map The map to print, may be {@code null}. If {@code null}, the text 'null' is output.
     * @throws NullPointerException if the stream is {@code null}
     */
    public static void verbosePrint(final PrintStream out, final Object label, final Map&lt;?, ?&gt; map) {
<span class="fc" id="L1940">        verbosePrintInternal(out, label, map, new ArrayDeque&lt;&gt;(), false);</span>
<span class="fc" id="L1941">    }</span>

    /**
     * Implementation providing functionality for {@link #debugPrint} and for {@link #verbosePrint}. This prints the
     * given map with nice line breaks. If the debug flag is true, it additionally prints the type of the object value.
     * If the contents of a map include the map itself, then the text &lt;em&gt;(this Map)&lt;/em&gt; is printed out. If the
     * contents include a parent container of the map, the text &lt;em&gt;(ancestor[i] Map)&lt;/em&gt; is printed, where it actually
     * indicates the number of levels which must be traversed in the sequential list of ancestors (e.g. father,
     * grandfather, great-grandfather, etc.).
     *
     * @param out the stream to print to
     * @param label the label to be used, may be {@code null}. If {@code null}, the label is not output. It
     *        typically represents the name of the property in a bean or similar.
     * @param map the map to print, may be {@code null}. If {@code null}, the text 'null' is output
     * @param lineage a stack consisting of any maps in which the previous argument is contained. This is checked to
     *        avoid infinite recursion when printing the output
     * @param debug flag indicating whether type names should be output.
     * @throws NullPointerException if the stream is {@code null}
     */
    private static void verbosePrintInternal(final PrintStream out, final Object label, final Map&lt;?, ?&gt; map,
            final Deque&lt;Map&lt;?, ?&gt;&gt; lineage, final boolean debug) {
<span class="fc" id="L1962">        printIndent(out, lineage.size());</span>

<span class="fc bfc" id="L1964" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc bfc" id="L1965" title="All 2 branches covered.">            if (label != null) {</span>
<span class="fc" id="L1966">                out.print(label);</span>
<span class="fc" id="L1967">                out.print(&quot; = &quot;);</span>
            }
<span class="fc" id="L1969">            out.println(&quot;null&quot;);</span>
<span class="fc" id="L1970">            return;</span>
        }
<span class="fc bfc" id="L1972" title="All 2 branches covered.">        if (label != null) {</span>
<span class="fc" id="L1973">            out.print(label);</span>
<span class="fc" id="L1974">            out.println(&quot; = &quot;);</span>
        }

<span class="fc" id="L1977">        printIndent(out, lineage.size());</span>
<span class="fc" id="L1978">        out.println(&quot;{&quot;);</span>

<span class="fc" id="L1980">        lineage.addLast(map);</span>

<span class="fc bfc" id="L1982" title="All 2 branches covered.">        for (final Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L1983">            final Object childKey = entry.getKey();</span>
<span class="fc" id="L1984">            final Object childValue = entry.getValue();</span>
<span class="fc bfc" id="L1985" title="All 4 branches covered.">            if (childValue instanceof Map &amp;&amp; !lineage.contains(childValue)) {</span>
<span class="fc bfc" id="L1986" title="All 2 branches covered.">                verbosePrintInternal(out, childKey == null ? &quot;null&quot; : childKey, (Map&lt;?, ?&gt;) childValue, lineage, debug);</span>
            } else {
<span class="fc" id="L1988">                printIndent(out, lineage.size());</span>
<span class="fc" id="L1989">                out.print(childKey);</span>
<span class="fc" id="L1990">                out.print(&quot; = &quot;);</span>

<span class="fc" id="L1992">                final int lineageIndex = IterableUtils.indexOf(lineage, PredicateUtils.equalPredicate(childValue));</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">                if (lineageIndex == -1) {</span>
<span class="fc" id="L1994">                    out.print(childValue);</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">                } else if (lineage.size() - 1 == lineageIndex) {</span>
<span class="fc" id="L1996">                    out.print(&quot;(this Map)&quot;);</span>
                } else {
<span class="fc" id="L1998">                    out.print(&quot;(ancestor[&quot; + (lineage.size() - 1 - lineageIndex - 1) + &quot;] Map)&quot;);</span>
                }

<span class="fc bfc" id="L2001" title="All 4 branches covered.">                if (debug &amp;&amp; childValue != null) {</span>
<span class="fc" id="L2002">                    out.print(' ');</span>
<span class="fc" id="L2003">                    out.println(childValue.getClass().getName());</span>
                } else {
<span class="fc" id="L2005">                    out.println();</span>
                }
            }
<span class="fc" id="L2008">        }</span>

<span class="fc" id="L2010">        lineage.removeLast();</span>

<span class="fc" id="L2012">        printIndent(out, lineage.size());</span>
<span class="fc bfc" id="L2013" title="All 2 branches covered.">        out.println(debug ? &quot;} &quot; + map.getClass().getName() : &quot;}&quot;);</span>
<span class="fc" id="L2014">    }</span>

    /**
     * Don't allow instances.
     */
    private MapUtils() {
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>