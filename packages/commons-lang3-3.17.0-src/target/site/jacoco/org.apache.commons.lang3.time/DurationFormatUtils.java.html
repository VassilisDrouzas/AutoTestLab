<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DurationFormatUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3.time</a> &gt; <span class="el_source">DurationFormatUtils.java</span></div><h1>DurationFormatUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang3.time;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Objects;
import java.util.TimeZone;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;

/**
 * Duration formatting utilities and constants. The following table describes the tokens
 * used in the pattern language for formatting.
 * &lt;table border=&quot;1&quot;&gt;
 *  &lt;caption&gt;Pattern Tokens&lt;/caption&gt;
 *  &lt;tr&gt;&lt;th&gt;character&lt;/th&gt;&lt;th&gt;duration element&lt;/th&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;y&lt;/td&gt;&lt;td&gt;years&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;M&lt;/td&gt;&lt;td&gt;months&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;days&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;H&lt;/td&gt;&lt;td&gt;hours&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;m&lt;/td&gt;&lt;td&gt;minutes&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;s&lt;/td&gt;&lt;td&gt;seconds&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;S&lt;/td&gt;&lt;td&gt;milliseconds&lt;/td&gt;&lt;/tr&gt;
 *  &lt;tr&gt;&lt;td&gt;'text'&lt;/td&gt;&lt;td&gt;arbitrary text content&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;b&gt;Note: It's not currently possible to include a single-quote in a format.&lt;/b&gt;
 * &lt;br&gt;
 * Token values are printed using decimal digits.
 * A token character can be repeated to ensure that the field occupies a certain minimum
 * size. Values will be left-padded with 0 unless padding is disabled in the method invocation.
 * &lt;br&gt;
 * Tokens can be marked as optional by surrounding them with brackets [ ]. These tokens will
 * only be printed if the token value is non-zero. Literals within optional blocks will only be
 * printed if the preceding non-literal token is non-zero. Leading optional literals will only
 * be printed if the following non-literal is non-zero.
 * Multiple optional blocks can be used to group literals with the desired token.
 * &lt;p&gt;
 * Notes on Optional Tokens:&lt;br&gt;
 * &lt;b&gt;Multiple optional tokens without literals can result in impossible to understand output.&lt;/b&gt;&lt;br&gt;
 * &lt;b&gt;Patterns where all tokens are optional can produce empty strings.&lt;/b&gt;&lt;br&gt;
 * (See examples below)
 * &lt;/p&gt;
 * &lt;br&gt;
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;Example Output&lt;/caption&gt;
 * &lt;tr&gt;&lt;th&gt;pattern&lt;/th&gt;&lt;th&gt;Duration.ofDays(1)&lt;/th&gt;&lt;th&gt;Duration.ofHours(1)&lt;/th&gt;&lt;th&gt;Duration.ofMinutes(1)&lt;/th&gt;&lt;th&gt;Duration.ZERO&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;d'd'H'h'm'm's's'&lt;/td&gt;&lt;td&gt;1d0h0m0s&lt;/td&gt;&lt;td&gt;0d1h0m0s&lt;/td&gt;&lt;td&gt;0d0h1m0s&lt;/td&gt;&lt;td&gt;0d0h0m0s&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;d'd'[H'h'm'm']s's'&lt;/td&gt;&lt;td&gt;1d0s&lt;/td&gt;&lt;td&gt;0d1h0s&lt;/td&gt;&lt;td&gt;0d1m0s&lt;/td&gt;&lt;td&gt;0d0s&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;[d'd'H'h'm'm']s's'&lt;/td&gt;&lt;td&gt;1d0s&lt;/td&gt;&lt;td&gt;1h0s&lt;/td&gt;&lt;td&gt;1m0s&lt;/td&gt;&lt;td&gt;0s&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;[d'd'H'h'm'm's's']&lt;/td&gt;&lt;td&gt;1d&lt;/td&gt;&lt;td&gt;1h&lt;/td&gt;&lt;td&gt;1m&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;['{'d'}']HH':'mm&lt;/td&gt;&lt;td&gt;{1}00:00&lt;/td&gt;&lt;td&gt;01:00&lt;/td&gt;&lt;td&gt;00:01&lt;/td&gt;&lt;td&gt;00:00&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;['{'dd'}']['&amp;lt;'HH'&amp;gt;']['('mm')']&lt;/td&gt;&lt;td&gt;{01}&lt;/td&gt;&lt;td&gt;&amp;lt;01&amp;gt;&lt;/td&gt;&lt;td&gt;(00)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;[dHms]&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;b&gt;Note: Optional blocks cannot be nested.&lt;/b&gt;
 *
 * @since 2.1
 */
public class DurationFormatUtils {

    /**
     * Element that is parsed from the format pattern.
     */
    static class Token {

        /** Empty array. */
<span class="fc" id="L88">        private static final Token[] EMPTY_ARRAY = {};</span>

        /**
         * Helper method to determine if a set of tokens contain a value
         *
         * @param tokens set to look in
         * @param value to look for
         * @return boolean {@code true} if contained
         */
        static boolean containsTokenWithValue(final Token[] tokens, final Object value) {
<span class="fc bfc" id="L98" title="All 2 branches covered.">            return Stream.of(tokens).anyMatch(token -&gt; token.getValue() == value);</span>
        }

        private final CharSequence value;
        private int count;
<span class="fc" id="L103">        private int optionalIndex = -1;</span>

        /**
         * Wraps a token around a value. A value would be something like a 'Y'.
         *
         * @param value value to wrap, non-null.
         * @param optional whether the token is optional
         * @param optionalIndex the index of the optional token within the pattern
         */
<span class="fc" id="L112">        Token(final CharSequence value, final boolean optional, final int optionalIndex) {</span>
<span class="fc" id="L113">            this.value = Objects.requireNonNull(value, &quot;value&quot;);</span>
<span class="fc" id="L114">            this.count = 1;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (optional) {</span>
<span class="fc" id="L116">                this.optionalIndex = optionalIndex;</span>
            }
<span class="fc" id="L118">        }</span>

        /**
         * Supports equality of this Token to another Token.
         *
         * @param obj2 Object to consider equality of
         * @return boolean {@code true} if equal
         */
        @Override
        public boolean equals(final Object obj2) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (obj2 instanceof Token) {</span>
<span class="fc" id="L129">                final Token tok2 = (Token) obj2;</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                if (this.value.getClass() != tok2.value.getClass()) {</span>
<span class="nc" id="L131">                    return false;</span>
                }
<span class="fc bfc" id="L133" title="All 2 branches covered.">                if (this.count != tok2.count) {</span>
<span class="fc" id="L134">                    return false;</span>
                }
<span class="fc bfc" id="L136" title="All 2 branches covered.">                if (this.value instanceof StringBuilder) {</span>
<span class="fc" id="L137">                    return this.value.toString().equals(tok2.value.toString());</span>
                }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                if (this.value instanceof Number) {</span>
<span class="nc" id="L140">                    return this.value.equals(tok2.value);</span>
                }
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">                return this.value == tok2.value;</span>
            }
<span class="fc" id="L144">            return false;</span>
        }

        /**
         * Gets the current number of values represented
         *
         * @return int number of values represented
         */
        int getCount() {
<span class="fc" id="L153">            return count;</span>
        }

        /**
         * Gets the particular value this token represents.
         *
         * @return Object value, non-null.
         */
        Object getValue() {
<span class="fc" id="L162">            return value;</span>
        }

        /**
         * Returns a hash code for the token equal to the
         * hash code for the token's value. Thus 'TT' and 'TTTT'
         * will have the same hash code.
         *
         * @return The hash code for the token
         */
        @Override
        public int hashCode() {
<span class="fc" id="L174">            return this.value.hashCode();</span>
        }

        /**
         * Adds another one of the value
         */
        void increment() {
<span class="fc" id="L181">            count++;</span>
<span class="fc" id="L182">        }</span>

        /**
         * Represents this token as a String.
         *
         * @return String representation of the token
         */
        @Override
        public String toString() {
<span class="fc" id="L191">            return StringUtils.repeat(this.value.toString(), this.count);</span>
        }
    }

    private static final int MINUTES_PER_HOUR = 60;

    private static final int SECONDS_PER_MINUTES = 60;

    private static final int HOURS_PER_DAY = 24;

    /**
     * Pattern used with {@link FastDateFormat} and {@link SimpleDateFormat}
     * for the ISO 8601 period format used in durations.
     *
     * @see org.apache.commons.lang3.time.FastDateFormat
     * @see java.text.SimpleDateFormat
     */
    public static final String ISO_EXTENDED_FORMAT_PATTERN = &quot;'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'&quot;;

    static final String y = &quot;y&quot;;

    static final String M = &quot;M&quot;;

    static final String d = &quot;d&quot;;

    static final String H = &quot;H&quot;;

    static final String m = &quot;m&quot;;

    static final String s = &quot;s&quot;;

    static final String S = &quot;S&quot;;

    /**
     * The internal method to do the formatting.
     *
     * @param tokens  the tokens
     * @param years  the number of years
     * @param months  the number of months
     * @param days  the number of days
     * @param hours  the number of hours
     * @param minutes  the number of minutes
     * @param seconds  the number of seconds
     * @param milliseconds  the number of millis
     * @param padWithZeros  whether to pad
     * @return the formatted string
     */
    static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes,
            final long seconds,
            final long milliseconds, final boolean padWithZeros) {
<span class="fc" id="L241">        final StringBuilder buffer = new StringBuilder();</span>
<span class="fc" id="L242">        boolean lastOutputSeconds = false;</span>
<span class="fc" id="L243">        boolean lastOutputZero = false;</span>
<span class="fc" id="L244">        int optionalStart = -1;</span>
<span class="fc" id="L245">        boolean firstOptionalNonLiteral = false;</span>
<span class="fc" id="L246">        int optionalIndex = -1;</span>
<span class="fc" id="L247">        boolean inOptional = false;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (final Token token : tokens) {</span>
<span class="fc" id="L249">            final Object value = token.getValue();</span>
<span class="fc" id="L250">            final boolean isLiteral = value instanceof StringBuilder;</span>
<span class="fc" id="L251">            final int count = token.getCount();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (optionalIndex != token.optionalIndex) {</span>
<span class="fc" id="L253">              optionalIndex = token.optionalIndex;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">              if (optionalIndex &gt; -1) {</span>
                //entering new optional block
<span class="fc" id="L256">                optionalStart = buffer.length();</span>
<span class="fc" id="L257">                lastOutputZero = false;</span>
<span class="fc" id="L258">                inOptional = true;</span>
<span class="fc" id="L259">                firstOptionalNonLiteral = false;</span>
              } else {
                //leaving optional block
<span class="fc" id="L262">                inOptional = false;</span>
              }
            }
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (isLiteral) {</span>
<span class="fc bfc" id="L266" title="All 4 branches covered.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L267">                    buffer.append(value.toString());</span>
                }
<span class="fc bfc" id="L269" title="All 2 branches covered.">            } else if (value.equals(y)) {</span>
<span class="fc" id="L270">                lastOutputSeconds = false;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                lastOutputZero = years == 0;</span>
<span class="pc bpc" id="L272" title="3 of 4 branches missed.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L273">                    buffer.append(paddedValue(years, padWithZeros, count));</span>
                }
<span class="fc bfc" id="L275" title="All 2 branches covered.">            } else if (value.equals(M)) {</span>
<span class="fc" id="L276">                lastOutputSeconds = false;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                lastOutputZero = months == 0;</span>
<span class="pc bpc" id="L278" title="3 of 4 branches missed.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L279">                    buffer.append(paddedValue(months, padWithZeros, count));</span>
                }
<span class="fc bfc" id="L281" title="All 2 branches covered.">            } else if (value.equals(d)) {</span>
<span class="fc" id="L282">                lastOutputSeconds = false;</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                lastOutputZero = days == 0;</span>
<span class="fc bfc" id="L284" title="All 4 branches covered.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L285">                    buffer.append(paddedValue(days, padWithZeros, count));</span>
                }
<span class="fc bfc" id="L287" title="All 2 branches covered.">            } else if (value.equals(H)) {</span>
<span class="fc" id="L288">                lastOutputSeconds = false;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                lastOutputZero = hours == 0;</span>
<span class="fc bfc" id="L290" title="All 4 branches covered.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L291">                    buffer.append(paddedValue(hours, padWithZeros, count));</span>
                }
<span class="fc bfc" id="L293" title="All 2 branches covered.">            } else if (value.equals(m)) {</span>
<span class="fc" id="L294">                lastOutputSeconds = false;</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">                lastOutputZero = minutes == 0;</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L297">                    buffer.append(paddedValue(minutes, padWithZeros, count));</span>
                }
<span class="fc bfc" id="L299" title="All 2 branches covered.">            } else if (value.equals(s)) {</span>
<span class="fc" id="L300">                lastOutputSeconds = true;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                lastOutputZero = seconds == 0;</span>
<span class="fc bfc" id="L302" title="All 4 branches covered.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc" id="L303">                    buffer.append(paddedValue(seconds, padWithZeros, count));</span>
                }
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">            } else if (value.equals(S)) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                lastOutputZero = milliseconds == 0;</span>
<span class="fc bfc" id="L307" title="All 4 branches covered.">                if (!inOptional || !lastOutputZero) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                    if (lastOutputSeconds) {</span>
                        // ensure at least 3 digits are displayed even if padding is not selected
<span class="fc bfc" id="L310" title="All 2 branches covered.">                        final int width = padWithZeros ? Math.max(3, count) : 3;</span>
<span class="fc" id="L311">                        buffer.append(paddedValue(milliseconds, true, width));</span>
<span class="fc" id="L312">                    } else {</span>
<span class="fc" id="L313">                        buffer.append(paddedValue(milliseconds, padWithZeros, count));</span>
                    }
                }
<span class="fc" id="L316">                lastOutputSeconds = false;</span>
            }
            //as soon as we hit first nonliteral in optional, check for literal prefix
<span class="fc bfc" id="L319" title="All 6 branches covered.">            if (inOptional &amp;&amp; !isLiteral &amp;&amp; !firstOptionalNonLiteral) {</span>
<span class="fc" id="L320">                firstOptionalNonLiteral = true;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                if (lastOutputZero) {</span>
<span class="fc" id="L322">                    buffer.delete(optionalStart, buffer.length());</span>
                }
            }
        }
<span class="fc" id="L326">        return buffer.toString();</span>
    }

    /**
     * Formats the time gap as a string, using the specified format, and padding with zeros.
     *
     * &lt;p&gt;This method formats durations using the days and lower fields of the
     * format pattern. Months and larger are not used.&lt;/p&gt;
     *
     * @param durationMillis  the duration to format
     * @param format  the way in which to format the duration, not null
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if durationMillis is negative
     */
    public static String formatDuration(final long durationMillis, final String format) {
<span class="fc" id="L341">        return formatDuration(durationMillis, format, true);</span>
    }

    /**
     * Formats the time gap as a string, using the specified format.
     * Padding the left-hand side side of numbers with zeroes is optional.
     *
     * &lt;p&gt;This method formats durations using the days and lower fields of the
     * format pattern. Months and larger are not used.&lt;/p&gt;
     *
     * @param durationMillis  the duration to format
     * @param format  the way in which to format the duration, not null
     * @param padWithZeros  whether to pad the left-hand side side of numbers with 0's
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if durationMillis is negative
     */
    public static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros) {
<span class="fc" id="L358">        Validate.inclusiveBetween(0, Long.MAX_VALUE, durationMillis, &quot;durationMillis must not be negative&quot;);</span>

<span class="fc" id="L360">        final Token[] tokens = lexx(format);</span>

<span class="fc" id="L362">        long days = 0;</span>
<span class="fc" id="L363">        long hours = 0;</span>
<span class="fc" id="L364">        long minutes = 0;</span>
<span class="fc" id="L365">        long seconds = 0;</span>
<span class="fc" id="L366">        long milliseconds = durationMillis;</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (Token.containsTokenWithValue(tokens, d)) {</span>
<span class="fc" id="L369">            days = milliseconds / DateUtils.MILLIS_PER_DAY;</span>
<span class="fc" id="L370">            milliseconds -= days * DateUtils.MILLIS_PER_DAY;</span>
        }
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (Token.containsTokenWithValue(tokens, H)) {</span>
<span class="fc" id="L373">            hours = milliseconds / DateUtils.MILLIS_PER_HOUR;</span>
<span class="fc" id="L374">            milliseconds -= hours * DateUtils.MILLIS_PER_HOUR;</span>
        }
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (Token.containsTokenWithValue(tokens, m)) {</span>
<span class="fc" id="L377">            minutes = milliseconds / DateUtils.MILLIS_PER_MINUTE;</span>
<span class="fc" id="L378">            milliseconds -= minutes * DateUtils.MILLIS_PER_MINUTE;</span>
        }
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (Token.containsTokenWithValue(tokens, s)) {</span>
<span class="fc" id="L381">            seconds = milliseconds / DateUtils.MILLIS_PER_SECOND;</span>
<span class="fc" id="L382">            milliseconds -= seconds * DateUtils.MILLIS_PER_SECOND;</span>
        }

<span class="fc" id="L385">        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);</span>
    }

    /**
     * Formats the time gap as a string.
     *
     * &lt;p&gt;The format used is ISO 8601-like: {@code HH:mm:ss.SSS}.&lt;/p&gt;
     *
     * @param durationMillis  the duration to format
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if durationMillis is negative
     */
    public static String formatDurationHMS(final long durationMillis) {
<span class="fc" id="L398">        return formatDuration(durationMillis, &quot;HH:mm:ss.SSS&quot;);</span>
    }

    /**
     * Formats the time gap as a string.
     *
     * &lt;p&gt;The format used is the ISO 8601 period format.&lt;/p&gt;
     *
     * &lt;p&gt;This method formats durations using the days and lower fields of the
     * ISO format pattern, such as P7D6TH5M4.321S.&lt;/p&gt;
     *
     * @param durationMillis  the duration to format
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if durationMillis is negative
     */
    public static String formatDurationISO(final long durationMillis) {
<span class="fc" id="L414">        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);</span>
    }

    /**
     * Formats an elapsed time into a pluralization correct string.
     *
     * &lt;p&gt;This method formats durations using the days and lower fields of the
     * format pattern. Months and larger are not used.&lt;/p&gt;
     *
     * @param durationMillis  the elapsed time to report in milliseconds
     * @param suppressLeadingZeroElements  suppresses leading 0 elements
     * @param suppressTrailingZeroElements  suppresses trailing 0 elements
     * @return the formatted text in days/hours/minutes/seconds, not null
     * @throws IllegalArgumentException if durationMillis is negative
     */
    public static String formatDurationWords(
        final long durationMillis,
        final boolean suppressLeadingZeroElements,
        final boolean suppressTrailingZeroElements) {

        // This method is generally replaceable by the format method, but
        // there are a series of tweaks and special cases that require
        // trickery to replicate.
<span class="fc" id="L437">        String duration = formatDuration(durationMillis, &quot;d' days 'H' hours 'm' minutes 's' seconds'&quot;);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (suppressLeadingZeroElements) {</span>
            // this is a temporary marker on the front. Like ^ in regexp.
<span class="fc" id="L440">            duration = &quot; &quot; + duration;</span>
<span class="fc" id="L441">            String tmp = StringUtils.replaceOnce(duration, &quot; 0 days&quot;, StringUtils.EMPTY);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (tmp.length() != duration.length()) {</span>
<span class="fc" id="L443">                duration = tmp;</span>
<span class="fc" id="L444">                tmp = StringUtils.replaceOnce(duration, &quot; 0 hours&quot;, StringUtils.EMPTY);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">                if (tmp.length() != duration.length()) {</span>
<span class="fc" id="L446">                    duration = tmp;</span>
<span class="fc" id="L447">                    tmp = StringUtils.replaceOnce(duration, &quot; 0 minutes&quot;, StringUtils.EMPTY);</span>
<span class="fc" id="L448">                    duration = tmp;</span>
                }
            }
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            if (!duration.isEmpty()) {</span>
                // strip the space off again
<span class="fc" id="L453">                duration = duration.substring(1);</span>
            }
        }
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (suppressTrailingZeroElements) {</span>
<span class="fc" id="L457">            String tmp = StringUtils.replaceOnce(duration, &quot; 0 seconds&quot;, StringUtils.EMPTY);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">            if (tmp.length() != duration.length()) {</span>
<span class="fc" id="L459">                duration = tmp;</span>
<span class="fc" id="L460">                tmp = StringUtils.replaceOnce(duration, &quot; 0 minutes&quot;, StringUtils.EMPTY);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">                if (tmp.length() != duration.length()) {</span>
<span class="fc" id="L462">                    duration = tmp;</span>
<span class="fc" id="L463">                    tmp = StringUtils.replaceOnce(duration, &quot; 0 hours&quot;, StringUtils.EMPTY);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                    if (tmp.length() != duration.length()) {</span>
<span class="fc" id="L465">                        duration = StringUtils.replaceOnce(tmp, &quot; 0 days&quot;, StringUtils.EMPTY);</span>
                    }
                }
            }
        }
        // handle plurals
<span class="fc" id="L471">        duration = &quot; &quot; + duration;</span>
<span class="fc" id="L472">        duration = StringUtils.replaceOnce(duration, &quot; 1 seconds&quot;, &quot; 1 second&quot;);</span>
<span class="fc" id="L473">        duration = StringUtils.replaceOnce(duration, &quot; 1 minutes&quot;, &quot; 1 minute&quot;);</span>
<span class="fc" id="L474">        duration = StringUtils.replaceOnce(duration, &quot; 1 hours&quot;, &quot; 1 hour&quot;);</span>
<span class="fc" id="L475">        duration = StringUtils.replaceOnce(duration, &quot; 1 days&quot;, &quot; 1 day&quot;);</span>
<span class="fc" id="L476">        return duration.trim();</span>
    }

    /**
     * Formats the time gap as a string, using the specified format.
     * Padding the left-hand side side of numbers with zeroes is optional.
     *
     * @param startMillis  the start of the duration
     * @param endMillis  the end of the duration
     * @param format  the way in which to format the duration, not null
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if startMillis is greater than endMillis
     */
    public static String formatPeriod(final long startMillis, final long endMillis, final String format) {
<span class="fc" id="L490">        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());</span>
    }

    /**
     * &lt;p&gt;Formats the time gap as a string, using the specified format.
     * Padding the left-hand side side of numbers with zeroes is optional and
     * the time zone may be specified.
     *
     * &lt;p&gt;When calculating the difference between months/days, it chooses to
     * calculate months first. So when working out the number of months and
     * days between January 15th and March 10th, it choose 1 month and
     * 23 days gained by choosing January-&amp;gt;February = 1 month and then
     * calculating days forwards, and not the 1 month and 26 days gained by
     * choosing March -&amp;gt; February = 1 month and then calculating days
     * backwards.&lt;/p&gt;
     *
     * &lt;p&gt;For more control, the &lt;a href=&quot;https://www.joda.org/joda-time/&quot;&gt;Joda-Time&lt;/a&gt;
     * library is recommended.&lt;/p&gt;
     *
     * @param startMillis  the start of the duration
     * @param endMillis  the end of the duration
     * @param format  the way in which to format the duration, not null
     * @param padWithZeros  whether to pad the left-hand side side of numbers with 0's
     * @param timezone  the millis are defined in
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if startMillis is greater than endMillis
     */
    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros,
            final TimeZone timezone) {
<span class="fc bfc" id="L519" title="All 2 branches covered.">        Validate.isTrue(startMillis &lt;= endMillis, &quot;startMillis must not be greater than endMillis&quot;);</span>

        // Used to optimize for differences under 28 days and
        // called formatDuration(millis, format); however this did not work
        // over leap years.
        // TODO: Compare performance to see if anything was lost by
        // losing this optimization.

<span class="fc" id="L527">        final Token[] tokens = lexx(format);</span>

        // time zones get funky around 0, so normalizing everything to GMT
        // stops the hours being off
<span class="fc" id="L531">        final Calendar start = Calendar.getInstance(timezone);</span>
<span class="fc" id="L532">        start.setTime(new Date(startMillis));</span>
<span class="fc" id="L533">        final Calendar end = Calendar.getInstance(timezone);</span>
<span class="fc" id="L534">        end.setTime(new Date(endMillis));</span>

        // initial estimates
<span class="fc" id="L537">        long milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);</span>
<span class="fc" id="L538">        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);</span>
<span class="fc" id="L539">        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);</span>
<span class="fc" id="L540">        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L541">        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);</span>
<span class="fc" id="L542">        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);</span>
<span class="fc" id="L543">        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);</span>

        // each initial estimate is adjusted in case it is under 0
<span class="fc bfc" id="L546" title="All 2 branches covered.">        while (milliseconds &lt; 0) {</span>
<span class="fc" id="L547">            milliseconds += DateUtils.MILLIS_PER_SECOND;</span>
<span class="fc" id="L548">            seconds -= 1;</span>
        }
<span class="fc bfc" id="L550" title="All 2 branches covered.">        while (seconds &lt; 0) {</span>
<span class="fc" id="L551">            seconds += SECONDS_PER_MINUTES;</span>
<span class="fc" id="L552">            minutes -= 1;</span>
        }
<span class="fc bfc" id="L554" title="All 2 branches covered.">        while (minutes &lt; 0) {</span>
<span class="fc" id="L555">            minutes += MINUTES_PER_HOUR;</span>
<span class="fc" id="L556">            hours -= 1;</span>
        }
<span class="fc bfc" id="L558" title="All 2 branches covered.">        while (hours &lt; 0) {</span>
<span class="fc" id="L559">            hours += HOURS_PER_DAY;</span>
<span class="fc" id="L560">            days -= 1;</span>
        }

<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (Token.containsTokenWithValue(tokens, M)) {</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            while (days &lt; 0) {</span>
<span class="fc" id="L565">                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);</span>
<span class="fc" id="L566">                months -= 1;</span>
<span class="fc" id="L567">                start.add(Calendar.MONTH, 1);</span>
            }

<span class="fc bfc" id="L570" title="All 2 branches covered.">            while (months &lt; 0) {</span>
<span class="fc" id="L571">                months += 12;</span>
<span class="fc" id="L572">                years -= 1;</span>
            }

<span class="fc bfc" id="L575" title="All 4 branches covered.">            if (!Token.containsTokenWithValue(tokens, y) &amp;&amp; years != 0) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                while (years != 0) {</span>
<span class="fc" id="L577">                    months += 12 * years;</span>
<span class="fc" id="L578">                    years = 0;</span>
                }
            }
        } else {
            // there are no M's in the format string

<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (!Token.containsTokenWithValue(tokens, y)) {</span>
<span class="fc" id="L585">                int target = end.get(Calendar.YEAR);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                if (months &lt; 0) {</span>
                    // target is end-year -1
<span class="fc" id="L588">                    target -= 1;</span>
                }

<span class="fc bfc" id="L591" title="All 2 branches covered.">                while (start.get(Calendar.YEAR) != target) {</span>
<span class="fc" id="L592">                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);</span>

                    // Not sure I grok why this is needed, but the brutal tests show it is
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                    if (start instanceof GregorianCalendar &amp;&amp;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &amp;&amp;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">                            start.get(Calendar.DAY_OF_MONTH) == 29) {</span>
<span class="fc" id="L598">                        days += 1;</span>
                    }

<span class="fc" id="L601">                    start.add(Calendar.YEAR, 1);</span>

<span class="fc" id="L603">                    days += start.get(Calendar.DAY_OF_YEAR);</span>
                }

<span class="fc" id="L606">                years = 0;</span>
            }

<span class="fc bfc" id="L609" title="All 2 branches covered.">            while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) {</span>
<span class="fc" id="L610">                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);</span>
<span class="fc" id="L611">                start.add(Calendar.MONTH, 1);</span>
            }

<span class="fc" id="L614">            months = 0;</span>

<span class="pc bpc" id="L616" title="1 of 2 branches missed.">            while (days &lt; 0) {</span>
<span class="nc" id="L617">                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);</span>
<span class="nc" id="L618">                months -= 1;</span>
<span class="nc" id="L619">                start.add(Calendar.MONTH, 1);</span>
            }

        }

        // The rest of this code adds in values that
        // aren't requested. This allows the user to ask for the
        // number of months and get the real count and not just 0-&gt;11.

<span class="fc bfc" id="L628" title="All 2 branches covered.">        if (!Token.containsTokenWithValue(tokens, d)) {</span>
<span class="fc" id="L629">            hours += HOURS_PER_DAY * days;</span>
<span class="fc" id="L630">            days = 0;</span>
        }
<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (!Token.containsTokenWithValue(tokens, H)) {</span>
<span class="fc" id="L633">            minutes += MINUTES_PER_HOUR * hours;</span>
<span class="fc" id="L634">            hours = 0;</span>
        }
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (!Token.containsTokenWithValue(tokens, m)) {</span>
<span class="fc" id="L637">            seconds += SECONDS_PER_MINUTES * minutes;</span>
<span class="fc" id="L638">            minutes = 0;</span>
        }
<span class="fc bfc" id="L640" title="All 2 branches covered.">        if (!Token.containsTokenWithValue(tokens, s)) {</span>
<span class="fc" id="L641">            milliseconds += DateUtils.MILLIS_PER_SECOND * seconds;</span>
<span class="fc" id="L642">            seconds = 0;</span>
        }

<span class="fc" id="L645">        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);</span>
    }

    /**
     * Formats the time gap as a string.
     *
     * &lt;p&gt;The format used is the ISO 8601 period format.&lt;/p&gt;
     *
     * @param startMillis  the start of the duration to format
     * @param endMillis  the end of the duration to format
     * @return the formatted duration, not null
     * @throws IllegalArgumentException if startMillis is greater than endMillis
     */
    public static String formatPeriodISO(final long startMillis, final long endMillis) {
<span class="fc" id="L659">        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());</span>
    }

    /**
     * Parses a classic date format string into Tokens
     *
     * @param format  the format to parse, not null
     * @return array of Token[]
     */
    static Token[] lexx(final String format) {
<span class="fc" id="L669">        final ArrayList&lt;Token&gt; list = new ArrayList&lt;&gt;(format.length());</span>

<span class="fc" id="L671">        boolean inLiteral = false;</span>
        // Although the buffer is stored in a Token, the Tokens are only
        // used internally, so cannot be accessed by other threads
<span class="fc" id="L674">        StringBuilder buffer = null;</span>
<span class="fc" id="L675">        Token previous = null;</span>
<span class="fc" id="L676">        boolean inOptional = false;</span>
<span class="fc" id="L677">        int optionalIndex = -1;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">        for (int i = 0; i &lt; format.length(); i++) {</span>
<span class="fc" id="L679">            final char ch = format.charAt(i);</span>
<span class="fc bfc" id="L680" title="All 4 branches covered.">            if (inLiteral &amp;&amp; ch != '\'') {</span>
<span class="fc" id="L681">                buffer.append(ch); // buffer can't be null if inLiteral is true</span>
<span class="fc" id="L682">                continue;</span>
            }
<span class="fc" id="L684">            String value = null;</span>
<span class="fc bfc" id="L685" title="All 11 branches covered.">            switch (ch) {</span>
            // TODO: Need to handle escaping of '
            case '[':
<span class="fc bfc" id="L688" title="All 2 branches covered.">                if (inOptional) {</span>
<span class="fc" id="L689">                    throw new IllegalArgumentException(&quot;Nested optional block at index: &quot; + i);</span>
                }
<span class="fc" id="L691">                optionalIndex++;</span>
<span class="fc" id="L692">                inOptional = true;</span>
<span class="fc" id="L693">                break;</span>
            case ']':
<span class="fc bfc" id="L695" title="All 2 branches covered.">                if (!inOptional) {</span>
<span class="fc" id="L696">                    throw new IllegalArgumentException(&quot;Attempting to close unopened optional block at index: &quot; + i);</span>
                }
<span class="fc" id="L698">                inOptional = false;</span>
<span class="fc" id="L699">                break;</span>
            case '\'':
<span class="fc bfc" id="L701" title="All 2 branches covered.">                if (inLiteral) {</span>
<span class="fc" id="L702">                    buffer = null;</span>
<span class="fc" id="L703">                    inLiteral = false;</span>
                } else {
<span class="fc" id="L705">                    buffer = new StringBuilder();</span>
<span class="fc" id="L706">                    list.add(new Token(buffer, inOptional, optionalIndex));</span>
<span class="fc" id="L707">                    inLiteral = true;</span>
                }
<span class="fc" id="L709">                break;</span>
            case 'y':
<span class="fc" id="L711">                value = y;</span>
<span class="fc" id="L712">                break;</span>
            case 'M':
<span class="fc" id="L714">                value = M;</span>
<span class="fc" id="L715">                break;</span>
            case 'd':
<span class="fc" id="L717">                value = d;</span>
<span class="fc" id="L718">                break;</span>
            case 'H':
<span class="fc" id="L720">                value = H;</span>
<span class="fc" id="L721">                break;</span>
            case 'm':
<span class="fc" id="L723">                value = m;</span>
<span class="fc" id="L724">                break;</span>
            case 's':
<span class="fc" id="L726">                value = s;</span>
<span class="fc" id="L727">                break;</span>
            case 'S':
<span class="fc" id="L729">                value = S;</span>
<span class="fc" id="L730">                break;</span>
            default:
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (buffer == null) {</span>
<span class="fc" id="L733">                    buffer = new StringBuilder();</span>
<span class="fc" id="L734">                    list.add(new Token(buffer, inOptional, optionalIndex));</span>
                }
<span class="fc" id="L736">                buffer.append(ch);</span>
            }

<span class="fc bfc" id="L739" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc bfc" id="L740" title="All 4 branches covered.">                if (previous != null &amp;&amp; previous.getValue().equals(value)) {</span>
<span class="fc" id="L741">                    previous.increment();</span>
                } else {
<span class="fc" id="L743">                    final Token token = new Token(value, inOptional, optionalIndex);</span>
<span class="fc" id="L744">                    list.add(token);</span>
<span class="fc" id="L745">                    previous = token;</span>
                }
<span class="fc" id="L747">                buffer = null;</span>
            }
        }
<span class="fc bfc" id="L750" title="All 2 branches covered.">        if (inLiteral) { // i.e. we have not found the end of the literal</span>
<span class="fc" id="L751">            throw new IllegalArgumentException(&quot;Unmatched quote in format: &quot; + format);</span>
        }
<span class="fc bfc" id="L753" title="All 2 branches covered.">        if (inOptional) { // i.e. we have not found the end of the literal</span>
<span class="fc" id="L754">            throw new IllegalArgumentException(&quot;Unmatched optional in format: &quot; + format);</span>
        }
<span class="fc" id="L756">        return list.toArray(Token.EMPTY_ARRAY);</span>
    }

    /**
     * Converts a {@code long} to a {@link String} with optional
     * zero padding.
     *
     * @param value the value to convert
     * @param padWithZeros whether to pad with zeroes
     * @param count the size to pad to (ignored if {@code padWithZeros} is false)
     * @return the string result
     */
    private static String paddedValue(final long value, final boolean padWithZeros, final int count) {
<span class="fc" id="L769">        final String longString = Long.toString(value);</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">        return padWithZeros ? StringUtils.leftPad(longString, count, '0') : longString;</span>
    }

    /**
     * DurationFormatUtils instances should NOT be constructed in standard programming.
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean instance
     * to operate.&lt;/p&gt;
     *
     * @deprecated TODO Make private in 4.0.
     */
    @Deprecated
<span class="fc" id="L782">    public DurationFormatUtils() {</span>
        // empty
<span class="fc" id="L784">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>