<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3.exception</a> &gt; <span class="el_source">ExceptionUtils.java</span></div><h1>ExceptionUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang3.exception;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.StringTokenizer;
import java.util.function.Consumer;
import java.util.stream.Stream;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.MethodUtils;

/**
 * Provides utilities for manipulating and examining
 * {@link Throwable} objects.
 *
 * @since 1.0
 */
public class ExceptionUtils {

    /**
     * The names of methods commonly used to access a wrapped exception.
     */
    // TODO: Remove in Lang 4
<span class="fc" id="L49">    private static final String[] CAUSE_METHOD_NAMES = {</span>
        &quot;getCause&quot;,
        &quot;getNextException&quot;,
        &quot;getTargetException&quot;,
        &quot;getException&quot;,
        &quot;getSourceException&quot;,
        &quot;getRootCause&quot;,
        &quot;getCausedByException&quot;,
        &quot;getNested&quot;,
        &quot;getLinkedException&quot;,
        &quot;getNestedException&quot;,
        &quot;getLinkedCause&quot;,
        &quot;getThrowable&quot;,
    };

    private static final int NOT_FOUND = -1;

    /**
     * Used when printing stack frames to denote the start of a
     * wrapped exception.
     *
     * &lt;p&gt;Package private for accessibility by test suite.&lt;/p&gt;
     */
    static final String WRAPPED_MARKER = &quot; [wrapped] &quot;;

    /**
     * Throws the given (usually checked) exception without adding the exception to the throws
     * clause of the calling method. This method prevents throws clause
     * inflation and reduces the clutter of &quot;Caused by&quot; exceptions in the
     * stack trace.
     * &lt;p&gt;
     * The use of this technique may be controversial, but useful.
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  // There is no throws clause in the method signature.
     *  public int propagateExample {
     *      try {
     *          // Throws IOException
     *          invocation();
     *      } catch (Exception e) {
     *          // Propagates a checked exception.
     *          throw ExceptionUtils.asRuntimeException(e);
     *      }
     *      // more processing
     *      ...
     *      return value;
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This is an alternative to the more conservative approach of wrapping the
     * checked exception in a RuntimeException:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  // There is no throws clause in the method signature.
     *  public int wrapExample() {
     *      try {
     *          // throws IOException.
     *          invocation();
     *      } catch (Error e) {
     *          throw e;
     *      } catch (RuntimeException e) {
     *          // Throws an unchecked exception.
     *          throw e;
     *      } catch (Exception e) {
     *          // Wraps a checked exception.
     *          throw new UndeclaredThrowableException(e);
     *      }
     *      // more processing
     *      ...
     *      return value;
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * One downside to using this approach is that the Java compiler will not
     * allow invoking code to specify a checked exception in a catch clause
     * unless there is some code path within the try block that has invoked a
     * method declared with that checked exception. If the invoking site wishes
     * to catch the shaded checked exception, it must either invoke the shaded
     * code through a method re-declaring the desired checked exception, or
     * catch Exception and use the {@code instanceof} operator. Either of these
     * techniques are required when interacting with non-Java JVM code such as
     * Jython, Scala, or Groovy, since these languages do not consider any
     * exceptions as checked.
     * &lt;/p&gt;
     *
     * @param throwable
     *            The throwable to rethrow.
     * @param &lt;T&gt; The type of the returned value.
     * @return Never actually returned, this generic type matches any type
     *         which the calling site requires. &quot;Returning&quot; the results of this
     *         method, as done in the propagateExample above, will satisfy the
     *         Java compiler requirement that all code paths return a value.
     * @since 3.14.0
     * @see #wrapAndThrow(Throwable)
     */
    public static &lt;T extends RuntimeException&gt; T asRuntimeException(final Throwable throwable) {
        // claim that the typeErasure invocation throws a RuntimeException
<span class="nc" id="L146">        return ExceptionUtils.&lt;T, RuntimeException&gt;eraseType(throwable);</span>
    }

    /**
     * Claims a Throwable is another Throwable type using type erasure. This
     * hides a checked exception from the Java compiler, allowing a checked
     * exception to be thrown without having the exception in the method's throw
     * clause.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;R, T extends Throwable&gt; R eraseType(final Throwable throwable) throws T {
<span class="fc" id="L157">        throw (T) throwable;</span>
    }

    /**
     * Performs an action for each Throwable causes of the given Throwable.
     * &lt;p&gt;
     * A throwable without cause will return a stream containing one element - the input throwable. A throwable with one cause
     * will return a stream containing two elements. - the input throwable and the cause throwable. A {@code null} throwable
     * will return a stream of count zero.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This method handles recursive cause structures that might otherwise cause infinite loops. The cause chain is
     * processed until the end is reached, or until the next item in the chain is already in the result set.
     * &lt;/p&gt;
     * @param throwable The Throwable to traverse.
     * @param consumer a non-interfering action to perform on the elements.
     * @since 3.13.0
     */
    public static void forEach(final Throwable throwable, final Consumer&lt;Throwable&gt; consumer) {
<span class="fc" id="L177">        stream(throwable).forEach(consumer);</span>
<span class="fc" id="L178">    }</span>

    /**
     * Introspects the {@link Throwable} to obtain the cause.
     *
     * &lt;p&gt;The method searches for methods with specific names that return a
     * {@link Throwable} object. This will pick up most wrapping exceptions,
     * including those from JDK 1.4.
     * &lt;/p&gt;
     *
     * &lt;p&gt;The default list searched for are:&lt;/p&gt;
     * &lt;ul&gt;
     *  &lt;li&gt;{@code getCause()}&lt;/li&gt;
     *  &lt;li&gt;{@code getNextException()}&lt;/li&gt;
     *  &lt;li&gt;{@code getTargetException()}&lt;/li&gt;
     *  &lt;li&gt;{@code getException()}&lt;/li&gt;
     *  &lt;li&gt;{@code getSourceException()}&lt;/li&gt;
     *  &lt;li&gt;{@code getRootCause()}&lt;/li&gt;
     *  &lt;li&gt;{@code getCausedByException()}&lt;/li&gt;
     *  &lt;li&gt;{@code getNested()}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If none of the above is found, returns {@code null}.&lt;/p&gt;
     *
     * @param throwable  the throwable to introspect for a cause, may be null
     * @return the cause of the {@link Throwable},
     *  {@code null} if none found or null throwable input
     * @since 1.0
     * @deprecated This feature will be removed in Lang 4, use {@link Throwable#getCause} instead
     */
    @Deprecated
    public static Throwable getCause(final Throwable throwable) {
<span class="fc" id="L210">        return getCause(throwable, null);</span>
    }

    /**
     * Introspects the {@link Throwable} to obtain the cause.
     *
     * &lt;p&gt;A {@code null} set of method names means use the default set.
     * A {@code null} in the set of method names will be ignored.&lt;/p&gt;
     *
     * @param throwable  the throwable to introspect for a cause, may be null
     * @param methodNames  the method names, null treated as default set
     * @return the cause of the {@link Throwable},
     *  {@code null} if none found or null throwable input
     * @since 1.0
     * @deprecated This feature will be removed in Lang 4, use {@link Throwable#getCause} instead
     */
    @Deprecated
    public static Throwable getCause(final Throwable throwable, String[] methodNames) {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L229">            return null;</span>
        }
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (methodNames == null) {</span>
<span class="fc" id="L232">            final Throwable cause = throwable.getCause();</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            if (cause != null) {</span>
<span class="fc" id="L234">                return cause;</span>
            }
<span class="fc" id="L236">            methodNames = CAUSE_METHOD_NAMES;</span>
        }
<span class="fc" id="L238">        return Stream.of(methodNames).map(m -&gt; getCauseUsingMethodName(throwable, m)).filter(Objects::nonNull).findFirst().orElse(null);</span>
    }

    /**
     * Gets a {@link Throwable} by method name.
     *
     * @param throwable  the exception to examine
     * @param methodName  the name of the method to find and invoke
     * @return the wrapped exception, or {@code null} if not found
     */
    // TODO: Remove in Lang 4
    private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) {
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (methodName != null) {</span>
<span class="fc" id="L251">            Method method = MethodUtils.getMethodObject(throwable.getClass(), methodName);</span>
<span class="fc bfc" id="L252" title="All 4 branches covered.">            if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {</span>
                try {
<span class="fc" id="L254">                    return (Throwable) method.invoke(throwable);</span>
<span class="nc" id="L255">                } catch (final ReflectiveOperationException ignored) {</span>
                    // exception ignored
                }
            }
        }
<span class="fc" id="L260">        return null;</span>
    }

    /**
     * Gets the default names used when searching for the cause of an exception.
     *
     * &lt;p&gt;This may be modified and used in the overloaded getCause(Throwable, String[]) method.&lt;/p&gt;
     *
     * @return cloned array of the default method names
     * @since 3.0
     * @deprecated This feature will be removed in Lang 4
     */
    @Deprecated
    public static String[] getDefaultCauseMethodNames() {
<span class="nc" id="L274">        return ArrayUtils.clone(CAUSE_METHOD_NAMES);</span>
    }

    /**
     * Gets a short message summarizing the exception.
     * &lt;p&gt;
     * The message returned is of the form
     * {ClassNameWithoutPackage}: {ThrowableMessage}
     * &lt;/p&gt;
     *
     * @param th  the throwable to get a message for, null returns empty string
     * @return the message, non-null
     * @since 2.2
     */
    public static String getMessage(final Throwable th) {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (th == null) {</span>
<span class="fc" id="L290">            return StringUtils.EMPTY;</span>
        }
<span class="fc" id="L292">        final String clsName = ClassUtils.getShortClassName(th, null);</span>
<span class="fc" id="L293">        return clsName + &quot;: &quot; + StringUtils.defaultString(th.getMessage());</span>
    }

    /**
     * Walks the {@link Throwable} to obtain its root cause.
     *
     * &lt;p&gt;This method walks through the exception chain until the last element,
     * the root cause of the chain, using {@link Throwable#getCause()}, and
     * returns that exception.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains that might
     * otherwise cause infinite loops. The cause chain is processed until
     * the end, or until the next item in the chain is already
     * processed. If we detect a loop, then return the element before the loop.&lt;/p&gt;

     *
     * @param throwable  the throwable to get the root cause for, may be null
     * @return the root cause of the {@link Throwable},
     *  {@code null} if null throwable input
     */
    public static Throwable getRootCause(final Throwable throwable) {
<span class="fc" id="L314">        final List&lt;Throwable&gt; list = getThrowableList(throwable);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        return list.isEmpty() ? null : list.get(list.size() - 1);</span>
    }

    /**
     * Gets a short message summarizing the root cause exception.
     * &lt;p&gt;
     * The message returned is of the form
     * {ClassNameWithoutPackage}: {ThrowableMessage}
     * &lt;/p&gt;
     *
     * @param throwable  the throwable to get a message for, null returns empty string
     * @return the message, non-null
     * @since 2.2
     */
    public static String getRootCauseMessage(final Throwable throwable) {
<span class="fc" id="L330">        final Throwable root = getRootCause(throwable);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        return getMessage(root == null ? throwable : root);</span>
    }

    /**
     * Gets a compact stack trace for the root cause of the supplied
     * {@link Throwable}.
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * It consists of the root exception followed by each of its wrapping
     * exceptions separated by '[wrapped]'. Note that this is the opposite
     * order to the JDK1.4 display.&lt;/p&gt;
     *
     * @param throwable  the throwable to examine, may be null
     * @return an array of stack trace frames, never null
     * @since 2.0
     */
    public static String[] getRootCauseStackTrace(final Throwable throwable) {
<span class="fc" id="L348">        return getRootCauseStackTraceList(throwable).toArray(ArrayUtils.EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets a compact stack trace for the root cause of the supplied {@link Throwable}.
     *
     * &lt;p&gt;
     * The output of this method is consistent across JDK versions. It consists of the root exception followed by each of
     * its wrapping exceptions separated by '[wrapped]'. Note that this is the opposite order to the JDK1.4 display.
     * &lt;/p&gt;
     *
     * @param throwable the throwable to examine, may be null
     * @return a list of stack trace frames, never null
     * @since 3.13.0
     */
    public static List&lt;String&gt; getRootCauseStackTraceList(final Throwable throwable) {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L365">            return Collections.emptyList();</span>
        }
<span class="fc" id="L367">        final Throwable[] throwables = getThrowables(throwable);</span>
<span class="fc" id="L368">        final int count = throwables.length;</span>
<span class="fc" id="L369">        final List&lt;String&gt; frames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L370">        List&lt;String&gt; nextTrace = getStackFrameList(throwables[count - 1]);</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (int i = count; --i &gt;= 0;) {</span>
<span class="fc" id="L372">            final List&lt;String&gt; trace = nextTrace;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (i != 0) {</span>
<span class="fc" id="L374">                nextTrace = getStackFrameList(throwables[i - 1]);</span>
<span class="fc" id="L375">                removeCommonFrames(trace, nextTrace);</span>
            }
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (i == count - 1) {</span>
<span class="fc" id="L378">                frames.add(throwables[i].toString());</span>
            } else {
<span class="fc" id="L380">                frames.add(WRAPPED_MARKER + throwables[i].toString());</span>
            }
<span class="fc" id="L382">            frames.addAll(trace);</span>
<span class="fc" id="L383">        }</span>
<span class="fc" id="L384">        return frames;</span>
    }

    /**
     * Gets a {@link List} of stack frames - the message
     * is not included. Only the trace of the specified exception is
     * returned, any caused by trace is stripped.
     *
     * &lt;p&gt;This works in most cases - it will only fail if the exception
     * message contains a line that starts with:
     * {@code &amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;at&amp;quot;.}&lt;/p&gt;
     *
     * @param throwable is any throwable
     * @return List of stack frames
     */
    static List&lt;String&gt; getStackFrameList(final Throwable throwable) {
<span class="fc" id="L400">        final String stackTrace = getStackTrace(throwable);</span>
<span class="fc" id="L401">        final String linebreak = System.lineSeparator();</span>
<span class="fc" id="L402">        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);</span>
<span class="fc" id="L403">        final List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L404">        boolean traceStarted = false;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        while (frames.hasMoreTokens()) {</span>
<span class="fc" id="L406">            final String token = frames.nextToken();</span>
            // Determine if the line starts with &lt;whitespace&gt;at
<span class="fc" id="L408">            final int at = token.indexOf(&quot;at&quot;);</span>
<span class="pc bpc" id="L409" title="1 of 4 branches missed.">            if (at != NOT_FOUND &amp;&amp; token.substring(0, at).trim().isEmpty()) {</span>
<span class="fc" id="L410">                traceStarted = true;</span>
<span class="fc" id="L411">                list.add(token);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            } else if (traceStarted) {</span>
<span class="fc" id="L413">                break;</span>
            }
<span class="fc" id="L415">        }</span>
<span class="fc" id="L416">        return list;</span>
    }

    /**
     * Gets an array where each element is a line from the argument.
     *
     * &lt;p&gt;The end of line is determined by the value of {@link System#lineSeparator()}.&lt;/p&gt;
     *
     * @param stackTrace  a stack trace String
     * @return an array where each element is a line from the argument
     */
    static String[] getStackFrames(final String stackTrace) {
<span class="fc" id="L428">        final String linebreak = System.lineSeparator();</span>
<span class="fc" id="L429">        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);</span>
<span class="fc" id="L430">        final List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        while (frames.hasMoreTokens()) {</span>
<span class="fc" id="L432">            list.add(frames.nextToken());</span>
        }
<span class="fc" id="L434">        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets the stack trace associated with the specified
     * {@link Throwable} object, decomposing it into a list of
     * stack frames.
     *
     * &lt;p&gt;The result of this method vary by JDK version as this method
     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
     * On JDK1.3 and earlier, the cause exception will not be shown
     * unless the specified throwable alters printStackTrace.&lt;/p&gt;
     *
     * @param throwable  the {@link Throwable} to examine, may be null
     * @return an array of strings describing each stack frame, never null
     */
    public static String[] getStackFrames(final Throwable throwable) {
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L452">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L454">        return getStackFrames(getStackTrace(throwable));</span>
    }

    /**
     * Gets the stack trace from a Throwable as a String.
     *
     * &lt;p&gt;The result of this method vary by JDK version as this method
     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
     * On JDK1.3 and earlier, the cause exception will not be shown
     * unless the specified throwable alters printStackTrace.&lt;/p&gt;
     *
     * @param throwable  the {@link Throwable} to be examined, may be null
     * @return the stack trace as generated by the exception's
     * {@code printStackTrace(PrintWriter)} method, or an empty String if {@code null} input
     */
    public static String getStackTrace(final Throwable throwable) {
<span class="fc bfc" id="L470" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L471">            return StringUtils.EMPTY;</span>
        }
<span class="fc" id="L473">        final StringWriter sw = new StringWriter();</span>
<span class="fc" id="L474">        throwable.printStackTrace(new PrintWriter(sw, true));</span>
<span class="fc" id="L475">        return sw.toString();</span>
    }

    /**
     * Gets a count of the number of {@link Throwable} objects in the
     * exception chain.
     *
     * &lt;p&gt;A throwable without cause will return {@code 1}.
     * A throwable with one cause will return {@code 2} and so on.
     * A {@code null} throwable will return {@code 0}.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains
     * that might otherwise cause infinite loops. The cause chain is
     * processed until the end, or until the next item in the
     * chain is already in the result.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @return the count of throwables, zero on null input
     */
    public static int getThrowableCount(final Throwable throwable) {
<span class="fc" id="L495">        return getThrowableList(throwable).size();</span>
    }

    /**
     * Gets the list of {@link Throwable} objects in the
     * exception chain.
     *
     * &lt;p&gt;A throwable without cause will return a list containing
     * one element - the input throwable.
     * A throwable with one cause will return a list containing
     * two elements. - the input throwable and the cause throwable.
     * A {@code null} throwable will return a list of size zero.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains that might
     * otherwise cause infinite loops. The cause chain is processed until
     * the end, or until the next item in the chain is already
     * in the result list.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @return the list of throwables, never null
     * @since 2.2
     */
    public static List&lt;Throwable&gt; getThrowableList(Throwable throwable) {
<span class="fc" id="L518">        final List&lt;Throwable&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L519" title="All 4 branches covered.">        while (throwable != null &amp;&amp; !list.contains(throwable)) {</span>
<span class="fc" id="L520">            list.add(throwable);</span>
<span class="fc" id="L521">            throwable = throwable.getCause();</span>
        }
<span class="fc" id="L523">        return list;</span>
    }

    /**
     * Gets the list of {@link Throwable} objects in the
     * exception chain.
     *
     * &lt;p&gt;A throwable without cause will return an array containing
     * one element - the input throwable.
     * A throwable with one cause will return an array containing
     * two elements. - the input throwable and the cause throwable.
     * A {@code null} throwable will return an array of size zero.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains
     * that might otherwise cause infinite loops. The cause chain is
     * processed until the end, or until the next item in the
     * chain is already in the result array.&lt;/p&gt;
     *
     * @see #getThrowableList(Throwable)
     * @param throwable  the throwable to inspect, may be null
     * @return the array of throwables, never null
     */
    public static Throwable[] getThrowables(final Throwable throwable) {
<span class="fc" id="L546">        return getThrowableList(throwable).toArray(ArrayUtils.EMPTY_THROWABLE_ARRAY);</span>
    }

    /**
     * Tests if the throwable's causal chain have an immediate or wrapped exception
     * of the given type?
     *
     * @param chain
     *            The root of a Throwable causal chain.
     * @param type
     *            The exception type to test.
     * @return true, if chain is an instance of type or is an
     *         UndeclaredThrowableException wrapping a cause.
     * @since 3.5
     * @see #wrapAndThrow(Throwable)
     */
    public static boolean hasCause(Throwable chain,
            final Class&lt;? extends Throwable&gt; type) {
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (chain instanceof UndeclaredThrowableException) {</span>
<span class="fc" id="L565">            chain = chain.getCause();</span>
        }
<span class="fc" id="L567">        return type.isInstance(chain);</span>
    }

    /**
     * Worker method for the {@code indexOfType} methods.
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @param subclass if {@code true}, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares
     * using references
     * @return index of the {@code type} within throwables nested within the specified {@code throwable}
     */
    private static int indexOf(final Throwable throwable, final Class&lt;? extends Throwable&gt; type, int fromIndex, final boolean subclass) {
<span class="fc bfc" id="L582" title="All 4 branches covered.">        if (throwable == null || type == null) {</span>
<span class="fc" id="L583">            return NOT_FOUND;</span>
        }
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if (fromIndex &lt; 0) {</span>
<span class="fc" id="L586">            fromIndex = 0;</span>
        }
<span class="fc" id="L588">        final Throwable[] throwables = getThrowables(throwable);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (fromIndex &gt;= throwables.length) {</span>
<span class="fc" id="L590">            return NOT_FOUND;</span>
        }
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (subclass) {</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (type.isAssignableFrom(throwables[i].getClass())) {</span>
<span class="fc" id="L595">                    return i;</span>
                }
            }
        } else {
<span class="fc bfc" id="L599" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                if (type.equals(throwables[i].getClass())) {</span>
<span class="fc" id="L601">                    return i;</span>
                }
            }
        }
<span class="fc" id="L605">        return NOT_FOUND;</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified class (exactly) in the exception chain.
     * Subclasses of the specified class do not match - see
     * {@link #indexOfType(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     */
    public static int indexOfThrowable(final Throwable throwable, final Class&lt;? extends Throwable&gt; clazz) {
<span class="fc" id="L623">        return indexOf(throwable, clazz, 0, false);</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do not match - see
     * {@link #indexOfType(Throwable, Class, int)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns -1
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     */
    public static int indexOfThrowable(final Throwable throwable, final Class&lt;? extends Throwable&gt; clazz, final int fromIndex) {
<span class="fc" id="L646">        return indexOf(throwable, clazz, fromIndex, false);</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified class or subclass in the exception chain.
     * Subclasses of the specified class do match - see
     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     * @since 2.1
     */
    public static int indexOfType(final Throwable throwable, final Class&lt;? extends Throwable&gt; type) {
<span class="fc" id="L665">        return indexOf(throwable, type, 0, true);</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do match - see
     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     * @since 2.1
     */
    public static int indexOfType(final Throwable throwable, final Class&lt;? extends Throwable&gt; type, final int fromIndex) {
<span class="fc" id="L689">        return indexOf(throwable, type, fromIndex, true);</span>
    }

    /**
     * Checks if a throwable represents a checked exception
     *
     * @param throwable
     *            The throwable to check.
     * @return True if the given Throwable is a checked exception.
     * @since 3.13.0
     */
    public static boolean isChecked(final Throwable throwable) {
<span class="fc bfc" id="L701" title="All 6 branches covered.">        return throwable != null &amp;&amp; !(throwable instanceof Error) &amp;&amp; !(throwable instanceof RuntimeException);</span>
    }

    /**
     * Checks if a throwable represents an unchecked exception
     *
     * @param throwable
     *            The throwable to check.
     * @return True if the given Throwable is an unchecked exception.
     * @since 3.13.0
     */
    public static boolean isUnchecked(final Throwable throwable) {
<span class="fc bfc" id="L713" title="All 6 branches covered.">        return throwable != null &amp;&amp; (throwable instanceof Error || throwable instanceof RuntimeException);</span>
    }

    /**
     * Prints a compact stack trace for the root cause of a throwable
     * to {@code System.err}.
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to {@code printStackTrace} for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output
     * @since 2.0
     */
    public static void printRootCauseStackTrace(final Throwable throwable) {
<span class="fc" id="L735">        printRootCauseStackTrace(throwable, System.err);</span>
<span class="fc" id="L736">    }</span>

    /**
     * Prints a compact stack trace for the root cause of a throwable.
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to {@code printStackTrace} for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output, may be null
     * @param printStream  the stream to output to, may not be null
     * @throws NullPointerException if the printStream is {@code null}
     * @since 2.0
     */
    @SuppressWarnings(&quot;resource&quot;)
    public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream printStream) {
<span class="fc bfc" id="L759" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L760">            return;</span>
        }
<span class="fc" id="L762">        Objects.requireNonNull(printStream, &quot;printStream&quot;);</span>
<span class="fc" id="L763">        getRootCauseStackTraceList(throwable).forEach(printStream::println);</span>
<span class="fc" id="L764">        printStream.flush();</span>
<span class="fc" id="L765">    }</span>

    /**
     * Prints a compact stack trace for the root cause of a throwable.
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to {@code printStackTrace} for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output, may be null
     * @param printWriter  the writer to output to, may not be null
     * @throws NullPointerException if the printWriter is {@code null}
     * @since 2.0
     */
    @SuppressWarnings(&quot;resource&quot;)
    public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter printWriter) {
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L789">            return;</span>
        }
<span class="fc" id="L791">        Objects.requireNonNull(printWriter, &quot;printWriter&quot;);</span>
<span class="fc" id="L792">        getRootCauseStackTraceList(throwable).forEach(printWriter::println);</span>
<span class="fc" id="L793">        printWriter.flush();</span>
<span class="fc" id="L794">    }</span>

    /**
     * Removes common frames from the cause trace given the two stack traces.
     *
     * @param causeFrames  stack trace of a cause throwable
     * @param wrapperFrames  stack trace of a wrapper throwable
     * @throws NullPointerException if either argument is null
     * @since 2.0
     */
    public static void removeCommonFrames(final List&lt;String&gt; causeFrames, final List&lt;String&gt; wrapperFrames) {
<span class="fc" id="L805">        Objects.requireNonNull(causeFrames, &quot;causeFrames&quot;);</span>
<span class="fc" id="L806">        Objects.requireNonNull(wrapperFrames, &quot;wrapperFrames&quot;);</span>
<span class="fc" id="L807">        int causeFrameIndex = causeFrames.size() - 1;</span>
<span class="fc" id="L808">        int wrapperFrameIndex = wrapperFrames.size() - 1;</span>
<span class="fc bfc" id="L809" title="All 4 branches covered.">        while (causeFrameIndex &gt;= 0 &amp;&amp; wrapperFrameIndex &gt;= 0) {</span>
            // Remove the frame from the cause trace if it is the same
            // as in the wrapper trace
<span class="fc" id="L812">            final String causeFrame = causeFrames.get(causeFrameIndex);</span>
<span class="fc" id="L813">            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (causeFrame.equals(wrapperFrame)) {</span>
<span class="fc" id="L815">                causeFrames.remove(causeFrameIndex);</span>
            }
<span class="fc" id="L817">            causeFrameIndex--;</span>
<span class="fc" id="L818">            wrapperFrameIndex--;</span>
<span class="fc" id="L819">        }</span>
<span class="fc" id="L820">    }</span>

    /**
     * Throws the given (usually checked) exception without adding the exception to the throws
     * clause of the calling method. This method prevents throws clause
     * inflation and reduces the clutter of &quot;Caused by&quot; exceptions in the
     * stack trace.
     * &lt;p&gt;
     * The use of this technique may be controversial, but useful.
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  // There is no throws clause in the method signature.
     *  public int propagateExample() {
     *      try {
     *          // throws SomeCheckedException.
     *          return invocation();
     *      } catch (SomeCheckedException e) {
     *          // Propagates a checked exception and compiles to return an int.
     *          return ExceptionUtils.rethrow(e);
     *      }
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This is an alternative to the more conservative approach of wrapping the
     * checked exception in a RuntimeException:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  // There is no throws clause in the method signature.
     *  public int wrapExample() {
     *      try {
     *          // throws IOException.
     *          return invocation();
     *      } catch (Error e) {
     *          throw e;
     *      } catch (RuntimeException e) {
     *          // Throws an unchecked exception.
     *          throw e;
     *      } catch (Exception e) {
     *          // wraps a checked exception.
     *          throw new UndeclaredThrowableException(e);
     *      }
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * One downside to using this approach is that the Java compiler will not
     * allow invoking code to specify a checked exception in a catch clause
     * unless there is some code path within the try block that has invoked a
     * method declared with that checked exception. If the invoking site wishes
     * to catch the shaded checked exception, it must either invoke the shaded
     * code through a method re-declaring the desired checked exception, or
     * catch Exception and use the {@code instanceof} operator. Either of these
     * techniques are required when interacting with non-Java JVM code such as
     * Jython, Scala, or Groovy, since these languages do not consider any
     * exceptions as checked.
     * &lt;/p&gt;
     *
     * @param throwable
     *            The throwable to rethrow.
     * @param &lt;T&gt; The type of the return value.
     * @return Never actually returns, this generic type matches any type
     *         which the calling site requires. &quot;Returning&quot; the results of this
     *         method, as done in the propagateExample above, will satisfy the
     *         Java compiler requirement that all code paths return a value.
     * @since 3.5
     * @see #wrapAndThrow(Throwable)
     */
    public static &lt;T&gt; T rethrow(final Throwable throwable) {
        // claim that the typeErasure invocation throws a RuntimeException
<span class="nc" id="L888">        return ExceptionUtils.&lt;T, RuntimeException&gt;eraseType(throwable);</span>
    }

    /**
     * Streams causes of a Throwable.
     * &lt;p&gt;
     * A throwable without cause will return a stream containing one element - the input throwable. A throwable with one cause
     * will return a stream containing two elements. - the input throwable and the cause throwable. A {@code null} throwable
     * will return a stream of count zero.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This method handles recursive cause chains that might otherwise cause infinite loops. The cause chain is
     * processed until the end, or until the next item in the chain is already in the result.
     * &lt;/p&gt;
     *
     * @param throwable The Throwable to traverse
     * @return A new Stream of Throwable causes.
     * @since 3.13.0
     */
    public static Stream&lt;Throwable&gt; stream(final Throwable throwable) {
        // No point building a custom Iterable as it would keep track of visited elements to avoid infinite loops
<span class="fc" id="L910">        return getThrowableList(throwable).stream();</span>
    }

    /**
     * Worker method for the {@code throwableOfType} methods.
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search, subclasses match, null returns null
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns null
     * @param subclass if {@code true}, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares
     * using references
     * @return throwable of the {@code type} within throwables nested within the specified {@code throwable}
     */
    private static &lt;T extends Throwable&gt; T throwableOf(final Throwable throwable, final Class&lt;T&gt; type, int fromIndex, final boolean subclass) {
<span class="fc bfc" id="L926" title="All 4 branches covered.">        if (throwable == null || type == null) {</span>
<span class="fc" id="L927">            return null;</span>
        }
<span class="fc bfc" id="L929" title="All 2 branches covered.">        if (fromIndex &lt; 0) {</span>
<span class="fc" id="L930">            fromIndex = 0;</span>
        }
<span class="fc" id="L932">        final Throwable[] throwables = getThrowables(throwable);</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">        if (fromIndex &gt;= throwables.length) {</span>
<span class="fc" id="L934">            return null;</span>
        }
<span class="fc bfc" id="L936" title="All 2 branches covered.">        if (subclass) {</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">                if (type.isAssignableFrom(throwables[i].getClass())) {</span>
<span class="fc" id="L939">                    return type.cast(throwables[i]);</span>
                }
            }
        } else {
<span class="fc bfc" id="L943" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">                if (type.equals(throwables[i].getClass())) {</span>
<span class="fc" id="L945">                    return type.cast(throwables[i]);</span>
                }
            }
        }
<span class="fc" id="L949">        return null;</span>
    }

    /**
     * Returns the first {@link Throwable}
     * that matches the specified class (exactly) in the exception chain.
     * Subclasses of the specified class do not match - see
     * {@link #throwableOfType(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfThrowable(final Throwable throwable, final Class&lt;T&gt; clazz) {
<span class="fc" id="L969">        return throwableOf(throwable, clazz, 0, false);</span>
    }

    /**
     * Returns the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do not match - see
     * {@link #throwableOfType(Throwable, Class, int)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns null
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfThrowable(final Throwable throwable, final Class&lt;T&gt; clazz, final int fromIndex) {
<span class="fc" id="L994">        return throwableOf(throwable, clazz, fromIndex, false);</span>
    }

    /**
     * Returns the throwable of the first {@link Throwable}
     * that matches the specified class or subclass in the exception chain.
     * Subclasses of the specified class do match - see
     * {@link #throwableOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfType(final Throwable throwable, final Class&lt;T&gt; type) {
<span class="fc" id="L1014">        return throwableOf(throwable, type, 0, true);</span>
    }

    /**
     * Returns the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do match - see
     * {@link #throwableOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns null
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfType(final Throwable throwable, final Class&lt;T&gt; type, final int fromIndex) {
<span class="fc" id="L1039">        return throwableOf(throwable, type, fromIndex, true);</span>
    }

    /**
     * Tests whether the specified {@link Throwable} is unchecked and throws it if so.
     *
     * @param &lt;T&gt; The Throwable type.
     * @param throwable the throwable to test and throw or return.
     * @return the given throwable.
     * @since 3.13.0
     * @deprecated Use {@link #throwUnchecked(Throwable)}.
     */
    @Deprecated
    public static &lt;T&gt; T throwUnchecked(final T throwable) {
<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (throwable instanceof RuntimeException) {</span>
<span class="nc" id="L1054">            throw (RuntimeException) throwable;</span>
        }
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        if (throwable instanceof Error) {</span>
<span class="nc" id="L1057">            throw (Error) throwable;</span>
        }
<span class="nc" id="L1059">        return throwable;</span>
    }

    /**
     * Tests whether the specified {@link Throwable} is unchecked and throws it if so.
     *
     * @param &lt;T&gt; The Throwable type.
     * @param throwable the throwable to test and throw or return.
     * @return the given throwable.
     * @since 3.14.0
     */
    public static &lt;T extends Throwable&gt; T throwUnchecked(final T throwable) {
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        if (isUnchecked(throwable)) {</span>
<span class="nc" id="L1072">            throw asRuntimeException(throwable);</span>
        }
<span class="fc" id="L1074">        return throwable;</span>
    }

    /**
     * Throws a checked exception without adding the exception to the throws
     * clause of the calling method. For checked exceptions, this method throws
     * an UndeclaredThrowableException wrapping the checked exception. For
     * Errors and RuntimeExceptions, the original exception is rethrown.
     * &lt;p&gt;
     * The downside to using this approach is that invoking code which needs to
     * handle specific checked exceptions must sniff up the exception chain to
     * determine if the caught exception was caused by the checked exception.
     * &lt;/p&gt;
     *
     * @param throwable
     *            The throwable to rethrow.
     * @param &lt;R&gt; The type of the returned value.
     * @return Never actually returned, this generic type matches any type
     *         which the calling site requires. &quot;Returning&quot; the results of this
     *         method will satisfy the Java compiler requirement that all code
     *         paths return a value.
     * @since 3.5
     * @see #asRuntimeException(Throwable)
     * @see #hasCause(Throwable, Class)
     */
    public static &lt;R&gt; R wrapAndThrow(final Throwable throwable) {
<span class="fc" id="L1100">        throw new UndeclaredThrowableException(throwUnchecked(throwable));</span>
    }

    /**
     * Public constructor allows an instance of {@link ExceptionUtils} to be created, although that is not
     * normally necessary.
     *
     * @deprecated TODO Make private in 4.0.
     */
    @Deprecated
<span class="fc" id="L1110">    public ExceptionUtils() {</span>
        // empty
<span class="fc" id="L1112">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>