<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Validate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3</a> &gt; <span class="el_source">Validate.java</span></div><h1>Validate.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang3;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.regex.Pattern;

/**
 * This class assists in validating arguments. The validation methods are
 * based along the following principles:
 * &lt;ul&gt;
 *   &lt;li&gt;An invalid {@code null} argument causes a {@link NullPointerException}.&lt;/li&gt;
 *   &lt;li&gt;A non-{@code null} argument causes an {@link IllegalArgumentException}.&lt;/li&gt;
 *   &lt;li&gt;An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;All exceptions messages are
 * &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax&quot;&gt;format strings&lt;/a&gt;
 * as defined by the Java platform. For example:
 *
 * &lt;pre&gt;
 * Validate.isTrue(i &amp;gt; 0, &quot;The value must be greater than zero: %d&quot;, i);
 * Validate.notNull(surname, &quot;The surname must not be %s&quot;, null);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @see String#format(String, Object...)
 * @since 2.0
 */
public class Validate {

    private static final String DEFAULT_NOT_NAN_EX_MESSAGE =
        &quot;The validated value is not a number&quot;;
    private static final String DEFAULT_FINITE_EX_MESSAGE =
        &quot;The value is invalid: %f&quot;;
    private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE =
        &quot;The value %s is not in the specified exclusive range of %s to %s&quot;;
    private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE =
        &quot;The value %s is not in the specified inclusive range of %s to %s&quot;;
    private static final String DEFAULT_MATCHES_PATTERN_EX = &quot;The string %s does not match the pattern %s&quot;;
    private static final String DEFAULT_IS_NULL_EX_MESSAGE = &quot;The validated object is null&quot;;
    private static final String DEFAULT_IS_TRUE_EX_MESSAGE = &quot;The validated expression is false&quot;;
    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE =
        &quot;The validated array contains null element at index: %d&quot;;
    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE =
        &quot;The validated collection contains null element at index: %d&quot;;
    private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = &quot;The validated character sequence is blank&quot;;
    private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = &quot;The validated array is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE =
        &quot;The validated character sequence is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = &quot;The validated collection is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = &quot;The validated map is empty&quot;;
    private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = &quot;The validated array index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE =
        &quot;The validated character sequence index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE =
        &quot;The validated collection index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_STATE_EX_MESSAGE = &quot;The validated state is false&quot;;
    private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = &quot;Cannot assign a %s to a %s&quot;;
    private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = &quot;Expected type: %s, actual: %s&quot;;

    /**
     * Validate that the specified primitive value falls between the two
     * exclusive values specified; otherwise, throws an exception.
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0.1, 2.1, 1.1);&lt;/pre&gt;
     *
     * @param start the exclusive start value
     * @param end   the exclusive end value
     * @param value the value to validate
     * @throws IllegalArgumentException if the value falls out of the boundaries
     * @since 3.3
     */
    @SuppressWarnings(&quot;boxing&quot;)
    public static void exclusiveBetween(final double start, final double end, final double value) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L95" title="All 4 branches covered.">        if (value &lt;= start || value &gt;= end) {</span>
<span class="fc" id="L96">            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L98">    }</span>

    /**
     * Validate that the specified primitive value falls between the two
     * exclusive values specified; otherwise, throws an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0.1, 2.1, 1.1, &quot;Not in range&quot;);&lt;/pre&gt;
     *
     * @param start the exclusive start value
     * @param end   the exclusive end value
     * @param value the value to validate
     * @param message the exception message if invalid, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @since 3.3
     */
    public static void exclusiveBetween(final double start, final double end, final double value, final String message) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L116" title="All 4 branches covered.">        if (value &lt;= start || value &gt;= end) {</span>
<span class="fc" id="L117">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L119">    }</span>

    /**
     * Validate that the specified primitive value falls between the two
     * exclusive values specified; otherwise, throws an exception.
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param start the exclusive start value
     * @param end   the exclusive end value
     * @param value the value to validate
     * @throws IllegalArgumentException if the value falls out of the boundaries
     * @since 3.3
     */
    @SuppressWarnings(&quot;boxing&quot;)
    public static void exclusiveBetween(final long start, final long end, final long value) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L136" title="All 4 branches covered.">        if (value &lt;= start || value &gt;= end) {</span>
<span class="fc" id="L137">            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L139">    }</span>

    /**
     * Validate that the specified primitive value falls between the two
     * exclusive values specified; otherwise, throws an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1, &quot;Not in range&quot;);&lt;/pre&gt;
     *
     * @param start the exclusive start value
     * @param end   the exclusive end value
     * @param value the value to validate
     * @param message the exception message if invalid, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @since 3.3
     */
    public static void exclusiveBetween(final long start, final long end, final long value, final String message) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L157" title="All 4 branches covered.">        if (value &lt;= start || value &gt;= end) {</span>
<span class="fc" id="L158">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L160">    }</span>

    /**
     * Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception.
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable, String, Object...)
     * @since 3.0
     */
    public static &lt;T&gt; void exclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L178" title="All 4 branches covered.">        if (value.compareTo(start) &lt;= 0 || value.compareTo(end) &gt;= 0) {</span>
<span class="fc" id="L179">            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L181">    }</span>

    /**
     * Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1, &quot;Not in boundaries&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable)
     * @since 3.0
     */
    public static &lt;T&gt; void exclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value, final String message, final Object... values) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L202" title="All 4 branches covered.">        if (value.compareTo(start) &lt;= 0 || value.compareTo(end) &gt;= 0) {</span>
<span class="fc" id="L203">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L205">    }</span>

    /**
     * Validates that the specified argument is not infinite or Not-a-Number (NaN);
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.finite(myDouble);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The value is invalid: %f&amp;quot;.&lt;/p&gt;
     *
     * @param value  the value to validate
     * @throws IllegalArgumentException if the value is infinite or Not-a-Number (NaN)
     * @see #finite(double, String, Object...)
     * @since 3.5
     */
    public static void finite(final double value) {
<span class="fc" id="L221">        finite(value, DEFAULT_FINITE_EX_MESSAGE, value);</span>
<span class="fc" id="L222">    }</span>

    /**
     * Validates that the specified argument is not infinite or Not-a-Number (NaN);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.finite(myDouble, &quot;The argument must contain a numeric value&quot;);&lt;/pre&gt;
     *
     * @param value the value to validate
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message
     * @throws IllegalArgumentException if the value is infinite or Not-a-Number (NaN)
     * @see #finite(double)
     * @since 3.5
     */
    public static void finite(final double value, final String message, final Object... values) {
<span class="fc bfc" id="L238" title="All 4 branches covered.">        if (Double.isNaN(value) || Double.isInfinite(value)) {</span>
<span class="fc" id="L239">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L241">    }</span>

    /**
     * Gets the message using {@link String#format(String, Object...) String.format(message, values)}
     * if the values are not empty, otherwise return the message unformatted.
     * This method exists to allow validation methods declaring a String message and varargs parameters
     * to be used without any message parameters when the message contains special characters,
     * e.g. {@code Validate.isTrue(false, &quot;%Failed%&quot;)}.
     *
     * @param message the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values the optional values for the formatted message
     * @return formatted message using {@link String#format(String, Object...) String.format(message, values)}
     * if the values are not empty, otherwise return the unformatted message.
     */
    private static String getMessage(final String message, final Object... values) {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        return ArrayUtils.isEmpty(values) ? message : String.format(message, values);</span>
    }

    /**
     * Validate that the specified primitive value falls between the two
     * inclusive values specified; otherwise, throws an exception.
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0.1, 2.1, 1.1);&lt;/pre&gt;
     *
     * @param start the inclusive start value
     * @param end   the inclusive end value
     * @param value the value to validate
     * @throws IllegalArgumentException if the value falls outside the boundaries (inclusive)
     * @since 3.3
     */
    @SuppressWarnings(&quot;boxing&quot;)
    public static void inclusiveBetween(final double start, final double end, final double value) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L274" title="All 4 branches covered.">        if (value &lt; start || value &gt; end) {</span>
<span class="fc" id="L275">            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L277">    }</span>

    /**
     * Validate that the specified primitive value falls between the two
     * inclusive values specified; otherwise, throws an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0.1, 2.1, 1.1, &quot;Not in range&quot;);&lt;/pre&gt;
     *
     * @param start the inclusive start value
     * @param end   the inclusive end value
     * @param value the value to validate
     * @param message the exception message if invalid, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @since 3.3
     */
    public static void inclusiveBetween(final double start, final double end, final double value, final String message) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L295" title="All 4 branches covered.">        if (value &lt; start || value &gt; end) {</span>
<span class="fc" id="L296">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L298">    }</span>

    /**
     * Validate that the specified primitive value falls between the two
     * inclusive values specified; otherwise, throws an exception.
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param start the inclusive start value
     * @param end   the inclusive end value
     * @param value the value to validate
     * @throws IllegalArgumentException if the value falls outside the boundaries (inclusive)
     * @since 3.3
     */
    @SuppressWarnings(&quot;boxing&quot;)
    public static void inclusiveBetween(final long start, final long end, final long value) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L315" title="All 4 branches covered.">        if (value &lt; start || value &gt; end) {</span>
<span class="fc" id="L316">            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L318">    }</span>

    /**
     * Validate that the specified primitive value falls between the two
     * inclusive values specified; otherwise, throws an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1, &quot;Not in range&quot;);&lt;/pre&gt;
     *
     * @param start the inclusive start value
     * @param end   the inclusive end value
     * @param value the value to validate
     * @param message the exception message if invalid, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @since 3.3
     */
    public static void inclusiveBetween(final long start, final long end, final long value, final String message) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L336" title="All 4 branches covered.">        if (value &lt; start || value &gt; end) {</span>
<span class="fc" id="L337">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L339">    }</span>

    /**
     * Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception.
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable, String, Object...)
     * @since 3.0
     */
    public static &lt;T&gt; void inclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L357" title="All 4 branches covered.">        if (value.compareTo(start) &lt; 0 || value.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L358">            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L360">    }</span>

    /**
     * Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1, &quot;Not in boundaries&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable)
     * @since 3.0
     */
    public static &lt;T&gt; void inclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value, final String message, final Object... values) {
        // TODO when breaking BC, consider returning value
<span class="fc bfc" id="L381" title="All 4 branches covered.">        if (value.compareTo(start) &lt; 0 || value.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L382">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L384">    }</span>

    /**
     * Validates that the argument can be converted to the specified class, if not, throws an exception.
     *
     * &lt;p&gt;This method is useful when validating that there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message format of the exception is &amp;quot;Cannot assign {type} to {superType}&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class must be validated against, not null
     * @param type  the class to check, not null
     * @throws IllegalArgumentException if type argument is not assignable to the specified superType
     * @see #isAssignableFrom(Class, Class, String, Object...)
     * @since 3.0
     */
    public static void isAssignableFrom(final Class&lt;?&gt; superType, final Class&lt;?&gt; type) {
        // TODO when breaking BC, consider returning type
<span class="fc bfc" id="L403" title="All 6 branches covered.">        if (type == null || superType == null || !superType.isAssignableFrom(type)) {</span>
<span class="fc" id="L404">            throw new IllegalArgumentException(</span>
<span class="fc" id="L405">                String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, ClassUtils.getName(type, &quot;null type&quot;), ClassUtils.getName(superType, &quot;null type&quot;)));</span>
        }
<span class="fc" id="L407">    }</span>

    /**
     * Validates that the argument can be converted to the specified class, if not throws an exception.
     *
     * &lt;p&gt;This method is useful when validating if there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object can not be converted to the&amp;quot;
     * followed by the name of the class and &amp;quot;class&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class must be validated against, not null
     * @param type  the class to check, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument can not be converted to the specified class
     * @see #isAssignableFrom(Class, Class)
     */
    public static void isAssignableFrom(final Class&lt;?&gt; superType, final Class&lt;?&gt; type, final String message, final Object... values) {
        // TODO when breaking BC, consider returning type
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (!superType.isAssignableFrom(type)) {</span>
<span class="fc" id="L429">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L431">    }</span>

    /**
     * Validates that the argument is an instance of the specified class, if not throws an exception.
     *
     * &lt;p&gt;This method is useful when validating according to an arbitrary class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.class, object);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;Expected type: {type}, actual: {obj_type}&amp;quot;&lt;/p&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object, String, Object...)
     * @since 3.0
     */
    public static void isInstanceOf(final Class&lt;?&gt; type, final Object obj) {
        // TODO when breaking BC, consider returning obj
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if (!type.isInstance(obj)) {</span>
<span class="fc" id="L451">            throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(), ClassUtils.getName(obj, &quot;null&quot;)));</span>
        }
<span class="fc" id="L453">    }</span>

    /**
     * Validate that the argument is an instance of the specified class; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary class
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.class, object, &quot;Wrong class, object is of class %s&quot;,
     *   object.getClass().getName());&lt;/pre&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object)
     * @since 3.0
     */
    public static void isInstanceOf(final Class&lt;?&gt; type, final Object obj, final String message, final Object... values) {
        // TODO when breaking BC, consider returning obj
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (!type.isInstance(obj)) {</span>
<span class="fc" id="L474">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L476">    }</span>

    /**
     * Validate that the argument condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &amp;gt; 0);
     * Validate.isTrue(myObject.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated expression is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(final boolean expression) {
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (!expression) {</span>
<span class="fc" id="L499">            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);</span>
        }
<span class="fc" id="L501">    }</span>

    /**
     * Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.
     *
     * &lt;pre&gt;Validate.isTrue(d &amp;gt; 0.0, &quot;The value must be greater than zero: &amp;#37;s&quot;, d);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the double value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(final boolean expression, final String message, final double value) {
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (!expression) {</span>
<span class="fc" id="L524">            throw new IllegalArgumentException(String.format(message, Double.valueOf(value)));</span>
        }
<span class="fc" id="L526">    }</span>

    /**
     * Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.
     *
     * &lt;pre&gt;Validate.isTrue(i &amp;gt; 0.0, &quot;The value must be greater than zero: &amp;#37;d&quot;, i);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the long value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(final boolean expression, final String message, final long value) {
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (!expression) {</span>
<span class="fc" id="L549">            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));</span>
        }
<span class="fc" id="L551">    }</span>

    /**
     * Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.
     *
     * &lt;pre&gt;{@code
     * Validate.isTrue(i &gt;= min &amp;amp;&amp;amp; i &lt;= max, &quot;The value must be between %d and %d&quot;, min, max);}&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     */
    public static void isTrue(final boolean expression, final String message, final Object... values) {
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (!expression) {</span>
<span class="fc" id="L572">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L574">    }</span>

    /**
     * Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.matchesPattern(&quot;hi&quot;, &quot;[a-z]*&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String, String, Object...)
     * @since 3.0
     */
    public static void matchesPattern(final CharSequence input, final String pattern) {
        // TODO when breaking BC, consider returning input
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (!Pattern.matches(pattern, input)) {</span>
<span class="fc" id="L593">            throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));</span>
        }
<span class="fc" id="L595">    }</span>

    /**
     * Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.matchesPattern(&quot;hi&quot;, &quot;[a-z]*&quot;, &quot;%s does not match %s&quot;, &quot;hi&quot; &quot;[a-z]*&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String)
     * @since 3.0
     */
    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {
        // TODO when breaking BC, consider returning input
<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (!Pattern.matches(pattern, input)) {</span>
<span class="fc" id="L616">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L618">    }</span>

    /**
     * Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated iterable contains null element at index:
     * &amp;quot; followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable, String, Object...)
     */
    public static &lt;T extends Iterable&lt;?&gt;&gt; T noNullElements(final T iterable) {
<span class="fc" id="L642">        return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);</span>
    }

    /**
     * Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection, &quot;The collection contains null at position %d&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.
     *
     * &lt;p&gt;If the iterable has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable)
     */
    public static &lt;T extends Iterable&lt;?&gt;&gt; T noNullElements(final T iterable, final String message, final Object... values) {
<span class="fc" id="L669">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc" id="L670">        int i = 0;</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">        for (final Iterator&lt;?&gt; it = iterable.iterator(); it.hasNext(); i++) {</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">            if (it.next() == null) {</span>
<span class="fc" id="L673">                final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));</span>
<span class="fc" id="L674">                throw new IllegalArgumentException(getMessage(message, values2));</span>
            }
        }
<span class="fc" id="L677">        return iterable;</span>
    }

    /**
     * Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated array contains null element at index:
     * &amp;quot; followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[], String, Object...)
     */
    public static &lt;T&gt; T[] noNullElements(final T[] array) {
<span class="fc" id="L702">        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE);</span>
    }

    /**
     * Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray, &quot;The array contain null at position %d&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.
     *
     * &lt;p&gt;If the array has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[])
     */
    public static &lt;T&gt; T[] noNullElements(final T[] array, final String message, final Object... values) {
<span class="fc" id="L729">        Objects.requireNonNull(array, &quot;array&quot;);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">            if (array[i] == null) {</span>
<span class="fc" id="L732">                final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));</span>
<span class="fc" id="L733">                throw new IllegalArgumentException(getMessage(message, values2));</span>
            }
        }
<span class="fc" id="L736">        return array;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notBlank(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated character
     * sequence is blank&amp;quot;.
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence, String, Object...)
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T notBlank(final T chars) {
<span class="fc" id="L758">        return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);</span>
    }

    /**
     * Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception with the specified
     * message.
     *
     * &lt;pre&gt;Validate.notBlank(myString, &quot;The string must not be blank&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence)
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T notBlank(final T chars, final String message, final Object... values) {
<span class="fc" id="L780">        Objects.requireNonNull(chars, toSupplier(message, values));</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (StringUtils.isBlank(chars)) {</span>
<span class="fc" id="L782">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L784">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated collection is
     * empty&amp;quot;.
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Collection, String, Object...)
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T notEmpty(final T collection) {
<span class="fc" id="L804">        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated map is
     * empty&amp;quot;.
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Map, String, Object...)
     */
    public static &lt;T extends Map&lt;?, ?&gt;&gt; T notEmpty(final T map) {
<span class="fc" id="L824">        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE);</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated
     * character sequence is empty&amp;quot;.
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence, String, Object...)
     */
    public static &lt;T extends CharSequence&gt; T notEmpty(final T chars) {
<span class="fc" id="L845">        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection, &quot;The collection must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T notEmpty(final T collection, final String message, final Object... values) {
<span class="fc" id="L865">        Objects.requireNonNull(collection, toSupplier(message, values));</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">        if (collection.isEmpty()) {</span>
<span class="fc" id="L867">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L869">        return collection;</span>
    }

    /**
     * Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap, &quot;The map must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T extends Map&lt;?, ?&gt;&gt; T notEmpty(final T map, final String message, final Object... values) {
<span class="fc" id="L889">        Objects.requireNonNull(map, toSupplier(message, values));</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L891">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L893">        return map;</span>
    }

    /**
     * Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString, &quot;The string must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence)
     */
    public static &lt;T extends CharSequence&gt; T notEmpty(final T chars, final String message, final Object... values) {
<span class="fc" id="L913">        Objects.requireNonNull(chars, toSupplier(message, values));</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">        if (chars.length() == 0) {</span>
<span class="fc" id="L915">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L917">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated array is
     * empty&amp;quot;.
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[], String, Object...)
     */
    public static &lt;T&gt; T[] notEmpty(final T[] array) {
<span class="fc" id="L937">        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE);</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray, &quot;The array must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T&gt; T[] notEmpty(final T[] array, final String message, final Object... values) {
<span class="fc" id="L957">        Objects.requireNonNull(array, toSupplier(message, values));</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">        if (array.length == 0) {</span>
<span class="fc" id="L959">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L961">        return array;</span>
    }

    /**
     * Validates that the specified argument is not Not-a-Number (NaN); otherwise
     * throwing an exception.
     *
     * &lt;pre&gt;Validate.notNaN(myDouble);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated value is not a
     * number&amp;quot;.&lt;/p&gt;
     *
     * @param value  the value to validate
     * @throws IllegalArgumentException if the value is not a number
     * @see #notNaN(double, String, Object...)
     * @since 3.5
     */
    public static void notNaN(final double value) {
<span class="fc" id="L979">        notNaN(value, DEFAULT_NOT_NAN_EX_MESSAGE);</span>
<span class="fc" id="L980">    }</span>

    /**
     * Validates that the specified argument is not Not-a-Number (NaN); otherwise
     * throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notNaN(myDouble, &quot;The value must be a number&quot;);&lt;/pre&gt;
     *
     * @param value  the value to validate
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message
     * @throws IllegalArgumentException if the value is not a number
     * @see #notNaN(double)
     * @since 3.5
     */
    public static void notNaN(final double value, final String message, final Object... values) {
<span class="fc bfc" id="L996" title="All 2 branches covered.">        if (Double.isNaN(value)) {</span>
<span class="fc" id="L997">            throw new IllegalArgumentException(getMessage(message, values));</span>
        }
<span class="fc" id="L999">    }</span>

    /**
     * Validate that the specified argument is not {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notNull(myObject, &quot;The object must not be null&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object is
     * null&amp;quot;.
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object, String, Object...)
     * @deprecated Use {@link Objects#requireNonNull(Object)}.
     */
    @Deprecated
    public static &lt;T&gt; T notNull(final T object) {
<span class="fc" id="L1019">        return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE);</span>
    }

    /**
     * Validate that the specified argument is not {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notNull(myObject, &quot;The object must not be null&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see Objects#requireNonNull(Object)
     */
    public static &lt;T&gt; T notNull(final T object, final String message, final Object... values) {
<span class="fc" id="L1037">        return Objects.requireNonNull(object, toSupplier(message, values));</span>
    }

    private static Supplier&lt;String&gt; toSupplier(final String message, final Object... values) {
<span class="fc" id="L1041">        return () -&gt; getMessage(message, values);</span>
    }

    /**
     * Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated collection index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @return the validated collection (never {@code null} for method chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int, String, Object...)
     * @since 3.0
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T validIndex(final T collection, final int index) {
<span class="fc" id="L1064">        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    /**
     * Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated character sequence index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int, String, Object...)
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T validIndex(final T chars, final int index) {
<span class="fc" id="L1091">        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    /**
     * Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2, &quot;The collection index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the collection is {@code null}, then the message of the
     * exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int)
     * @since 3.0
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T validIndex(final T collection, final int index, final String message, final Object... values) {
<span class="fc" id="L1115">        Objects.requireNonNull(collection, &quot;collection&quot;);</span>
<span class="fc bfc" id="L1116" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= collection.size()) {</span>
<span class="fc" id="L1117">            throw new IndexOutOfBoundsException(getMessage(message, values));</span>
        }
<span class="fc" id="L1119">        return collection;</span>
    }

    /**
     * Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception with the
     * specified message.
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2, &quot;The string index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int)
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T validIndex(final T chars, final int index, final String message, final Object... values) {
<span class="fc" id="L1144">        Objects.requireNonNull(chars, &quot;chars&quot;);</span>
<span class="fc bfc" id="L1145" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= chars.length()) {</span>
<span class="fc" id="L1146">            throw new IndexOutOfBoundsException(getMessage(message, values));</span>
        }
<span class="fc" id="L1148">        return chars;</span>
    }

    /**
     * Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception is
     * &amp;quot;The validated array index is invalid: &amp;quot; followed by the
     * index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int, String, Object...)
     * @since 3.0
     */
    public static &lt;T&gt; T[] validIndex(final T[] array, final int index) {
<span class="fc" id="L1174">        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    /**
     * Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2, &quot;The array index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int)
     * @since 3.0
     */
    public static &lt;T&gt; T[] validIndex(final T[] array, final int index, final String message, final Object... values) {
<span class="fc" id="L1198">        Objects.requireNonNull(array, &quot;array&quot;);</span>
<span class="fc bfc" id="L1199" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= array.length) {</span>
<span class="fc" id="L1200">            throw new IndexOutOfBoundsException(getMessage(message, values));</span>
        }
<span class="fc" id="L1202">        return array;</span>
    }

    /**
     * Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.
     *
     * &lt;pre&gt;
     * Validate.validState(field &amp;gt; 0);
     * Validate.validState(this.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated state is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean, String, Object...)
     * @since 3.0
     */
    public static void validState(final boolean expression) {
<span class="fc bfc" id="L1224" title="All 2 branches covered.">        if (!expression) {</span>
<span class="fc" id="L1225">            throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE);</span>
        }
<span class="fc" id="L1227">    }</span>

    /**
     * Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.
     *
     * &lt;pre&gt;Validate.validState(this.isOk(), &quot;The state is not OK: %s&quot;, myObject);&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean)
     * @since 3.0
     */
    public static void validState(final boolean expression, final String message, final Object... values) {
<span class="fc bfc" id="L1245" title="All 2 branches covered.">        if (!expression) {</span>
<span class="fc" id="L1246">            throw new IllegalStateException(getMessage(message, values));</span>
        }
<span class="fc" id="L1248">    }</span>

    /**
     * Constructs a new instance. This class should not normally be instantiated.
     */
<span class="fc" id="L1253">    public Validate() {</span>
<span class="fc" id="L1254">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>